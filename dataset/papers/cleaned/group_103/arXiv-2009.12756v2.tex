\title{Answering Complex Open-Domain Questions with Multi-Hop Dense Retrieval}

\begin{document}

\maketitle

\begin{abstract}
We propose a simple and efficient multi-hop dense retrieval approach for answering complex open-domain questions, which achieves state-of-the-art performance on two multi-hop datasets, HotpotQA and multi-evidence FEVER. Contrary to previous work, our method does not require access to any corpus-specific information, such as inter-document hyperlinks or human-annotated entity markers, and can be applied to any unstructured text corpus. Our system also yields a much better efficiency-accuracy trade-off, matching the best published accuracy on HotpotQA while being 10 times faster at inference time.\footnote{\url{https://github.com/facebookresearch/multihop_dense_retrieval}.}

\end{abstract}

\section{Introduction}

\emph{Open domain question answering} is a challenging task where the answer to a given question needs to be extracted from a large pool %of millions 
of documents.  
The prevailing approach~\citep{drqa} tackles the problem in two stages. Given a question, a \emph{retriever} first produces a %short 
list of $k$ candidate documents, and a \emph{reader} then extracts the answer from this %reduced 
set.
Until recently, retrieval models were dependent on traditional term-based information retrieval (IR) methods, which fail to capture the semantics of the question beyond lexical matching and remain a major performance bottleneck for the task. Recent work on dense retrieval methods instead uses pretrained encoders to cast the question and documents into dense representations in a vector space and relies on fast maximum inner-product search (MIPS) to complete the retrieval. These approaches~\citep{ORQA,REALM,DPR} have demonstrated significant retrieval improvements over traditional IR baselines.  

However, such methods remain limited to \emph{simple} questions, where the answer to the question is explicit in a single piece of text evidence. In contrast, \emph{complex} questions typically involve aggregating information from multiple documents, requiring logical reasoning or sequential (multi-hop) processing in order to infer the answer (see Figure \ref{fig:example} for an example). %Due to the potentially sequential nature of such questions,
Since the process for answering such questions might be sequential in nature, single-shot approaches to retrieval are insufficient. Instead, iterative methods are needed to recursively retrieve new information at each step, conditioned on the information already at hand.
Beyond further expanding the scope of existing textual open-domain QA systems, answering more complex questions usually involves \textit{multi-hop reasoning}, which poses unique challenges for existing neural-based AI systems. With its practical and research values,
multi-hop QA has been extensively studied recently~\citep{ComplexWebQ,HotpotQA,Wikihop} and remains an active research area in NLP~\citep{GoldEn,SMR,DecomQA,Transformer-XH,GraphRecurrentRetriever,UQD}.

The main problem in answering multi-hop open-domain questions is that the search space grows exponentially with each retrieval hop. Most recent work tackles this issue by constructing a document graph utilizing either entity linking or existing hyperlink structure in the underlying Wikipedia corpus~\citep{SMR,GraphRecurrentRetriever}. The problem then becomes finding the best path in this graph, where the search space is bounded by the number of hyperlinks in each passage. However, such methods may not generalize to new domains, where entity linking might perform poorly, or where hyperlinks might not be as abundant as in Wikipedia. Moreover, efficiency remains a challenge despite using these data-dependent pruning heuristics, with the best model~\citep{GraphRecurrentRetriever} needing hundreds of calls to large pretrained models to produce a single answer.  

In contrast, we propose to employ dense retrieval to the multi-hop setting with a simple recursive framework.
Our method iteratively encodes the question and previously retrieved documents as a query vector and retrieves the next relevant documents using efficient MIPS methods. 
With high-quality, dense representations derived from strong pretrained encoders, our work first demonstrates that the sequence of documents that provide sufficient information to answer the multi-hop question can be 
accurately discovered from unstructured text, \emph{without} the help of corpus-specific hyperlinks. 
When evaluated on two multi-hop benchmarks, HotpotQA~\citep{HotpotQA} and a multi-evidence subset of FEVER~\citep{FEVER}, our approach improves greatly over the traditional linking-based retrieval methods. %(e.g., 28\% relative gain in Recall@20 for HotpotQA). 
More importantly, the better retrieval results also lead to state-of-the-art downstream results on both datasets. On HotpotQA, we demonstrate a vastly improved efficiency-accuracy trade-off achieved by our system: by limiting the amount of retrieved contexts fed into downstream models, our system can match the best published result while being 10x faster.

\begin{figure}[t]
\vspace{-0.2in}
\includegraphics[width=\linewidth]{overview.pdf}
\vspace{-0.2in}
 \caption{An overview of the multi-hop dense retrieval approach.}
\vspace{-0.2in}
\label{fig:example}
\end{figure}

\section{Method}

\subsection{Problem Definition} 

The retrieval task considered in this work can be described as follows~(see also Figure~\ref{fig:example}). 
Given a multi-hop question~$q$ and a large text corpus $\mathcal{C}$, the retrieval module needs to retrieve a sequence of passages $\mathcal{P}_{seq} :\{p_1, p_2, ..., p_{n}\}$ that provide \emph{sufficient} information for answering $q$.  
Practically, the retriever returns the $k$ best-scoring sequence candidates, $\{\mathcal{P}_{seq}^1, \mathcal{P}_{seq}^2, ..., \mathcal{P}_{seq}^{k}\}$ ($k \ll |\mathcal{C}|$), with the hope that at least one of them has the desired qualities. 
$k$ should be small enough for downstream modules to process in a reasonable time while maintaining adequate recall.
In general, retrieval also needs to be efficient enough to handle real-world corpora containing millions of documents.

\subsection{Multi-Hop Dense Retrieval} 
\label{sec:model}

\paragraph{Model} Based on the sequential nature of the multi-hop retrieval problem, our system solves it in an iterative fashion. We model the probability of selecting a certain passage sequence as follows:
\begin{align*}
    P(\mathcal{P}_{seq}|q) = \prod_{t=1}^{n} P(p_t|q,p_1, ..., p_{t-1}),
\end{align*}
where for $t=1$, we only condition on the original question for retrieval. At each retrieval step, we construct a new query representation based on previous results and the retrieval is implemented as maximum inner product search over the dense representations of the whole corpus:
\begin{align*}
    P(p_t|q,p_1, ..., p_{t-1}) = \frac{\exp{(\langle \vp_t, \vq_t \rangle})}{\sum_{p \in \mathcal{C}} \exp{(\langle \vp, \vq_t \rangle)}},  \textrm{ where } \vq_t = g(q, p_1, ..., p_{t-1}) \textrm{ and } \vp_t = h(p_t).
\end{align*}
Here $\langle\cdot,\cdot\rangle$ is the inner product between the query and passage vectors. $h(\cdot)$ and and $g(\cdot)$ are passage and query encoders that produce the dense representations. In order to reformulate the query representation to account for previous retrieval results at time step $t$, 
we simply concatenate the question and the retrieved passages as the inputs to $g(\cdot)$. Note that our formulation for each retrieval step is similar to existing single-hop dense retrieval methods~\citep{ORQA,REALM,DPR} except that we add the query reformulation process conditioned on previous retrieval results. Additionally, instead of using a bi-encoder architecture with separately parameterized encoders for queries and passages, we use a shared  RoBERTa-base~\citep{RoBERTa} encoder for both $h(\cdot)$ and $g(\cdot)$. In~\cref{sec:ablation}, we show this simple modification yields considerable improvements.
Specifically, we apply layer normalization over the start token's representations from RoBERTa to get the final dense query/passage vectors. 

\paragraph{Training and Inference} The retriever model is trained as in~\citet{DPR}, where each input query (which at each step consists of a question and previously retrieved passages) is paired with a positive passage and $m$ negative passages to approximate the softmax over all passages.  The positive passage is the gold annotated evidence at step $t$.  Negative passages are a combination of passages in the current batch which correspond to other questions (\emph{in-batch}), and \emph{hard} negatives which are false adversarial passages.  In our experiments, we obtain hard negatives from TF-IDF retrieved passages and their linked pages in Wikipedia.  We note that using hyperlinked pages as additional negatives is neither necessary nor critical for our approach.  In fact we observe only a very small degradation in performance if we remove them from training (\cref{sec:ablation}). In addition to in-batch negatives, we use a memory bank ($\mathcal{M}$) mechanism~\citep{MemoryBank} to further increase the number of negative examples for each question. The memory bank stores a large number of dense passage vectors. As we block the gradient back-propagation in the memory bank, its size ($|\mathcal{M}| \gg$ batch size) is less restricted by the GPU memory size. Specifically, after training to convergence with the shared encoder, we freeze a copy of the encoder as the new passage encoder and collect a bank of passage representations across multiple batches to serve as the set of negative passages. This simple extension results in further improvement in retrieval. (\cref{sec:ablation}).

For inference, we first encode the whole corpus into an index of passage vectors. Given a question, we use beam search to obtain top-$k$ passage sequence candidates, where the candidates to beam search at each step are generated by MIPS using the query encoder at step $t$, and 
the beams are scored by the sum of inner products
as suggested by the probabilistic formulation discussed above.  Such inference relies only on the dense passage index and the query representations, and does not need explicit graph construction using hyperlinks or entity linking. The top-$k$ sequences will then be fed into task-specific downstream modules to produce the desired outputs. 

\section{Experiments} 
\label{sec:task}

\paragraph{Datasets} 
Our experiments focus on two datasets: \emph{HotpotQA} and \emph{Multi-evidence FEVER}.
HotpotQA~\citep{HotpotQA} includes 113k multi-hop questions.
Unlike other multi-hop QA datasets~\citep{MetaQA,ComplexWebQ,Wikihop}, where the information sources of the answers are knowledge bases, 
HotpotQA uses documents in Wikipedia. Thus, its questions are not restricted by the fixed KB schema and can cover more diverse topics. Each question in HotpotQA is also provided with ground truth support passages, which enables us to evaluate the intermediate retrieval performance.
Multi-evidence FEVER includes 20k claims from the FEVER~\citep{FEVER} fact verification dataset, where the claims can only be verified using multiple documents. 
We use this dataset to validate the general applicability of our method.

\paragraph{Implementation Details} 
All the experiments are conducted on a machine with 8 32GB V100 GPUs. Our code is based on Huggingface Transformers~\citep{wolf2019huggingface}. Our best retrieval results are predicted using the exact inner product search index (IndexFlatIP) in FAISS~\citep{FAISS}. Both datasets assume 2 hops, so we fix $n=2$ for all experiments. Since HotpotQA does not provide the order of the passage sequences, as a heuristic, we consider the passage that includes the answer span as the final passage.
\footnote{If the answer span is in both, the one that has its title mentioned in the other passage is treated as the second.}
In \cref{sec:ablation}, we show that the order of the passages is important for effective retriever training. The hyperparameters can be found in Appendix~\ref{appendix:hyperparameter}. 

\subsection{Experiments: Retrieval}
\label{sec:exp}

We evaluate our multi-hop dense retriever (\method) in two different use cases: \emph{direct} and \emph{reranking}, where the former outputs the top-$k$ results directly using the retriever scores and the latter applies a task-specific reranking model to the initial results from \method.

\subsubsection{Direct}

We first compare \method with several efficient retrieval methods that can directly find the top-$k$ passage sequences from a large corpus, including TF-IDF, TF-IDF + Linked, DrKIT and Entity Linking. \textbf{TF-IDF} is the standard term-matching baseline, while \textbf{TF-IDF + Linked} is a straightforward extension that also extracts the hyperlinked passages from TF-IDF passages, and then reranks both TF-IDF and hyperlinked passages with BM25~\footnote{https://pypi.org/project/rank-bm25} scores. \textbf{DrKIT}~\citep{DrKIT} is a recently proposed dense retrieval approach, which builds a entity-level (mentions of entities) dense index for retrieval. It relies on hyperlinks to extract entity mentions and prunes the search space with a binary mask that restricts the next hop to using hyperlinked entities. 
On FEVER, we additionally consider an entity linking baseline~\citep{UKP} that is commonly used in existing fact verification pipelines. This baseline first uses a constituency parser to extract potential entity mentions in the fact claim and then uses the MediaWiki API to search documents with titles that match the mentions. 

Table~\ref{tab:efficient_baselines} shows the performance of different retrieval methods. On HotpotQA the metric is recall at the top $k$ paragraphs\footnote{As the sequence length is 2 for HotpotQA, we pick the top $k$/2 sequences predicted by \method.}, while on FEVER the metrics are precision, recall and F$_1$ in order to be consistent with previous results. On both datasets, \method substantially outperforms all baselines.

\begin{table}
    \centering
    \small
    \vspace{-0.4in}
    \caption{Retrieval performance in recall at $k$ retrieved passages and precision/recall/F$_1$.}
    \begin{tabular}{c|ccc|ccc}
    \toprule
        \multirow{2}{*}{Method} & \multicolumn{3}{c|}{HotpotQA} & \multicolumn{3}{c}{FEVER} \\
        & R@2 & R@10 & R@20 & Precision & Recall & F$_1$ \\ 
        \midrule
    TF-IDF & 10.3 & 29.1 & 36.8 & 14.9 & 28.2 & 19.5 \\
    TF-IDF + Linked  & 17.3 & 50.0 & 62.7 & 18.6 & 35.8 & 24.5 \\
    DrKIT & 38.3 &  67.2 & 71.0 & - & - & - \\
    Entity Linking & - & - & - & 30.6 & 53.8 & 39.0\\
    \midrule
    \method & \textbf{65.9} & \textbf{77.5} & \textbf{80.2} & \textbf{45.7} & \textbf{69.1} & \textbf{55.0}\\
    \bottomrule
    \end{tabular}
    \vspace{-0.2in}
    \label{tab:efficient_baselines}
\end{table}

\subsubsection{Reranking}
\label{sec:reranking}

\emph{Reranking} documents returned by efficient retrieval methods with a more sophisticated model is a common strategy for improving retrieval quality.
For instance, state-of-the-art multi-hop QA systems usually augment traditional IR techniques with large pretrained language models to select a more compact but precise passage set.
On HotpotQA, we test the effectiveness of \method after a simple cross-attention reranking: each of the top $k$ passage sequences from \method is first prepended with the original question and then fed into a pretrained Transformer encoder, i.e., ELECTRA-large~\citep{ELECTRA}, that predicts relevant scores. We train this reranking model with a binary cross-entropy loss, with the target being whether the passage sequence cover both groundtruth passages.
We empirically compare our approach with two other existing reranking-based retrieval methods:
\textbf{Semantic Retrieval}~\citep{SMR} uses BERT at both passage-level and sentence-level to select context from the initial TF-IDF and hyperlinked passages; \textbf{Graph Recurrent Retriever}~\citep{GraphRecurrentRetriever} learns to recursively select the best passage sequence on top of a hyperlinked passage graph, where each passage node is encoded with BERT.

\begin{table}[h]
    \vspace{-0.20in}
    \begin{minipage}[t]{.45\textwidth}
    \centering
    \small
    \caption{HotpotQA reranked retrieval results (input passages for final answer prediction).}
    \begin{tabular}{lcc}
    \toprule
    Method & SP EM & Ans Recall \\
    \midrule
    Semantic Retrieval  & 63.9 & 77.9 \\
    Graph Rec Retriever & 75.7 & 87.5 \\
    \midrule 
    \method (direct)     & 65.9 & 75.4 \\
    \method (reranking) & \textbf{81.2} & \textbf{88.2} \\
    \bottomrule
    \end{tabular}
    \label{tab:retrieval_rerank}
    \end{minipage}%
    \hfill
    \begin{minipage}[t]{.5\textwidth}
    \centering
    \small
    \caption{Retriever Model Ablation on HotpotQA retrieval. \emph{Single-hop} here is equivalent to the DPR method~\citep{DPR}.}
    \begin{tabular}{l|ccc}
    \toprule
    Retriever variants & R@2 & R@10 & R@20 \\
    \midrule
    Full Retrieval Model & 65.9 & 77.5 & 80.2 \\
    - w/o linked negatives & 64.6 & 76.8 & 79.6\\
    - w/o memory bank & 63.7 & 74.2 & 77.2\\
    - w/o shared encoder & 59.9 & 70.6 & 73.1 \\
    - w/o order & 17.6 & 55.6 & 62.3\\
    Single-hop & 25.2 & 45.4 & 52.1\\
    \bottomrule
    \end{tabular}
    \label{tab:ablation}
    \end{minipage}
\end{table}

Table~\ref{tab:retrieval_rerank} shows the reranking results. 
Following \citet{GraphRecurrentRetriever}, we use \emph{Answer Recall} and \emph{Support Passage Exact Match (SP EM)} \footnote{Whether the final predicted sequence covers both gold passages.} as the evaluation metrics.
Even without reranking, \method is already better than Semantic Retrieval, which requires around 50 BERT encoding (where each encoding involves cross-attention over a concatenated question-passage pair). After we rerank the top-100 sequences from the dense retriever, our passage recall is better than the state-of-the-art Graph Recurrent Retriever, which uses BERT to process more than 500 passages. 
We do not compare the reranked results on FEVER, as most FEVER systems directly use BERT encoder to select the top evidence \textit{sentences} from the retrieved documents, instead of the reranking the documents.

\subsubsection{Analysis}
\label{sec:retrieval_analysis}
\label{sec:error_analysis}

To understand the strengths and weaknesses of \method, we conduct further analysis on HotpotQA dev. %the HotpotQA dev set

\paragraph{Retrieval Error Analysis}

\begin{wrapfigure}{r}{0.45\textwidth}
\includegraphics[width=\linewidth]{retrieva_types.pdf}
\vspace{-20pt}
\caption{The retrieval performance gap between comparison and bridge questions. Left: recall of groundtruth passage sequences without reranking. Right: Top-1 chain exact match after reranking.}
\vspace{-10pt}
\label{fig:typed_retrieval}
\end{wrapfigure}

HotpotQA contains two question categories: \emph{bridge} questions in which an intermediate entity is missing and needs to be retrieved before inferring the answer; and \emph{comparison} questions where two entities are mentioned simultaneously and compared in some way. In Figure~\ref{fig:typed_retrieval}, we show the retrieval performance of both question types.  The case of \textit{comparison} questions proves easier, since both entities needed for retrieval are present in the question. 

This case appears almost solved, confirming recent work demonstrating that dense retrieval is very effective at entity linking~\citep{blink}.

For the case of \textit{bridge} questions, we manually inspect 50 randomly sampled erroneous examples after reranking. We find that in half of these cases, our retrieval model predicts an alternative passage sequence that is also valid (see Appendix~\ref{sec:false_errors} for examples). This gives an estimated top-1 passage sequence accuracy of about 90\%. 
Other remaining errors are due to the dense method's inability to capture the exact n-gram match between the question and passages. This is a known issue~\citep{ORQA, DPR} of dense retrieval methods when dealing with questions that have high lexical overlap with the passages. To this end, a hybrid multi-hop retrieval method with both term and dense index might be used to further improve the performance on \textit{bridge} questions. 

\paragraph{Retriever Ablation Study} % If this part is not removed, then the goal is to test the impact of different retriever to the end task.
\label{sec:ablation}
In Table~\ref{tab:ablation}, we examine our model with different variations on HotpotQA to show the effectiveness of each proposed component. We see that further training with a memory bank results in modest gains, while using a shared encoder is crucial for the best performance. Respecting the ordering of passages in two hops is essential - training in an order-agnostic manner hardly works at all, and underperforms even the single-hop baseline. Finally, not using hyperlinked paragraphs from TF-IDF passages as additional negatives has only a minor impact on performance.

\paragraph{Question Decomposition for Retrieval}
\label{sec:decomposition}
As multi-hop questions have more complex structures than simple questions, recent studies~\citep{DecomQA,UQD} propose to use explicit question decomposition to simplify the problem. 
\citet{Break} shows that with TF-IDF, using decomposed questions improves the retrieval results. 
We investigate whether the conclusion still holds with stronger dense retrieval methods. 
We use the human-annotated question decomposition from the QDMR dataset~\citep{Break} for analysis. For a question like \texttt{Q:Mick Carter is the landlord of a public house located at what address?}, QDMR provides two subquestions, \texttt{SubQ1: What is the public house that Mick Carter is the landlord of?} and \texttt{SubQ2: What is the address that \#1 is located at?}.
We sample 100 bridge questions and replace \texttt{\#1} in \texttt{SubQ2} with the correct answer (The Queen Victoria) to \texttt{SubQ1}. 
Note that this gives advantages to the decomposed method as we ignore any intermediate errors. 
We estimate the performance of potential decomposed methods with the state-of-the-art single-hop dense retrieval model~\citep{DPR}.

\begin{wraptable}{r}{7.5cm}
    \centering
    \small
    \vspace{-0.1in}
    \caption{Comparison with decomposed dense retrieval which uses oracle question decomposition (test on 100 bridge questions). See text for details about the decomposed settings.}
    \begin{tabular}{lccc}
    \toprule
      Method & R@2 & R@10 & R@20 \\
    \midrule
     \method & 54.9 & 63.7 & 70.6\\
     Decomp (SubQ1;SubQ2) & 50.0 & 64.7 & 67.6 \\
     Decomp (Q;SubQ2) & 51.0 & 64.7 & 68.6 \\
    \bottomrule
    \end{tabular}
    \label{tab:decomposition}
\end{wraptable}

As shown in Table~\ref{tab:decomposition}, we did not observe any strong improvements from explicit question decomposition, which is contrary to the findings by \citet{Break} when using term-based IR methods. Moreover, as shown in the third row of the table, when the 1st hop of the decomposed retrieval (i.e., \texttt{SubQ1}) is replaced with the original question, no performance degradation is observed. This suggests that strong pretrained encoders can effectively learn to select necessary information from the multi-hop question at each retrieval step. Regarding the performance drop when using explicit compositions, we hypothesize that it is because some information in one decomposed subquestion could be useful for the other retrieval hop. Examples supporting this hypothesis can be found in Appendix \ref{appendix:decomposed_exmaples}. While this could potentially be addressed by a different style of decomposition, our analysis suggests that decomposition approaches might be sub-optimal in the context of dense retrieval with strong pretrained encoders.

\subsection{Experiments: HotpotQA}
\label{sec:exp-hotpotqa}

We evaluate how the better retrieval results of \method improve multi-hop question answering in this section. As our retriever system is agnostic to downstream models, we test two categories of answer prediction architectures: 
the \emph{extractive} span prediction models based on pretrained masked language models, such as BERT~\citep{BERT} and ELECTRA~\citep{ELECTRA},
and the retrieval-augmented \emph{generative} reader models~\citep{RAG,FiD}, which are based on pretrained sequence-to-sequence (seq2seq) models such as BART~\citep{BART} and T5~\citep{t5}. 
Note that compared to more complicated graph reasoning models~\citep{HGN,Transformer-XH}, these two classes of models do not rely on hyperlinks and can be applied to any text.

\textbf{Extractive} reader models learn to predict an answer span from the concatenation of the question and passage sequence ([$q$, $p_1$, ..., $p_n$]). On top of the token representations produced by pretrained models, we add two prediction heads to predict the start and end position of the answer span.\footnote{To account for yes/no questions, we prepend \emph{yes} and \emph{no} tokens to the context.} To predict the supporting sentences, we add another prediction head and predict a binary label at each sentence start. For simplicity, the same encoder is also responsible for reranking the top $k$ passage sequences. The reranking detail has been discussed in \cref{sec:reranking}. Our best reader model is based on ELECTRA~\citep{ELECTRA}, which has achieved the best single-model performance on the standard SQuAD~\citep{SQuAD} benchmark. Additionally, we also report the performance of BERT-large with whole word masking (BERT-wwm) to fairly compare with~\citet{GraphRecurrentRetriever}. 

\textbf{Generative} models, such as RAG~\citep{RAG} and FiD~\citep{FiD}, are based on pretrained seq2seq models. These methods finetune pretrained models with the concatenated questions and retrieved documents as inputs, and answer tokens as outputs. This generative paradigm has shown state-of-the-art performance on single-hop open-domain QA tasks. Specifically, FiD first uses the T5 encoder to process each retrieved passage sequence independently and then uses the decoder to perform attention over the representations of all input tokens while generating answers. RAG is built on the smaller BART model. Instead of only tuning the seq2seq model, it also jointly train the question encoder of the dense retriever. We modified it to allow multi-hop retrieval. 

More details about these two classes of reader models are described in Appendix~\ref{appendix:multihop_rag}.

\subsubsection{Results}
\begin{table*}[h]
    \centering
    \small
    \vspace{-0.3in}
    \caption{HotpotQA-fullwiki test results.}
    \begin{tabular}{lcccccc}
    \toprule
       \multirow{2}{*}{Methods} &  \multicolumn{2}{c}{Answer} & \multicolumn{2}{c}{Support} & \multicolumn{2}{c}{Joint}\\ & EM & F1 & EM & F1 & EM & F1 \\
    \midrule
    GoldEn Retriever~\citep{GoldEn} & 37.9 & 48.6 & 30.7 & 64,2 & 18.9 & 39.1\\
    Semantic Retrieval~\citep{SMR} & 46.5 & 58.8 & 39.9 & 71.5 & 26.6 & 49.2\\
    Transformer-XH~\citep{Transformer-XH} & 51.6 & 64.1 & 40.9 & 71.4 & 26.1 & 51.3 \\
    HGN~\citep{HGN} & 56.7 & 69.2 & 50.0 & 76.4 & 35.6 & 59.9\\
    DrKIT~\citep{DrKIT} & 42.1 &  51.7 & 37.1 & 59.8 & 24.7 & 42.9\\
    Graph Recurrent Retriever \citep{GraphRecurrentRetriever} & 60.0 & 73.0 & 49.1 & 76.4 & 35.4 & 61.2 \\

    \midrule 
    \method (ELECTRA Reader) & \textbf{62.3} & \textbf{75.3} & \textbf{57.5} & \textbf{80.9} & \textbf{41.8} & \textbf{66.6}\\
    \bottomrule
    \end{tabular}
    \label{tab:QA}
    \vspace{-0.2in}
\end{table*}\paragraph{Comparison with Existing Systems} Table~\ref{tab:QA} compares the HotpotQA test performance of our best ELECTRA reader with recently published systems, using the numbers from the official leaderboard, which measure answer and supporting sentence exact match (EM)/F1 and joint EM/F1. 
Among these methods, only GoldEn Retriever~\citep{GoldEn} does not exploit hyperlinks. In particular, Graph Recurrent Retriever trains a graph traversal model for chain retrieval; TransformerXH~\citep{Transformer-XH} and HGN~\citep{HGN} explicitly encode the hyperlink graph structure within their answer prediction models. In fact, this particular inductive bias provides a perhaps unreasonably strong advantage in the specific context of HotpotQA, which by construction guarantees ground-truth passage sequences to follow hyperlinks.  
Despite not using such prior knowledge, our model outperforms all previous systems by large margins, especially on supporting fact prediction, which benefits more directly from better retrieval. 

\paragraph{Reader Model Variants}
\label{sec:reader_comparison}
    
 

\begin{wraptable}{r}{7.5cm}
    \centering
    \small
    \vspace{-0.1in}
    \caption{Reader comparison on HotpotQA dev set.}
    \begin{tabular}{l|l|l|cc}
    \toprule
    \textbf{}                   & Model & Top k & EM    & F1    \\ \midrule
        \multirow{3}{*}
    {Extractive}
    & ELECTRA & Top 50 &  61.7 & 74.3 \\
    & ELECTRA & Top 250 &  63.4 & 76.2 \\ & BERT-wwm & Top 250 & 61.5 & 74.7 \\
    \midrule
    \multirow{2}{*}{Generative} & Multi-hop RAG  &  Top 4*4 & 51.2 & 63.9 \\
                                & FiD   & Top 50  & 61.7 &  73.1 \\ 
 
     \bottomrule
    \end{tabular}
    \label{tab:reader}
\end{wraptable}

Results for reader model variants are shown in Table~\ref{tab:reader}.\footnote{For the compute-heavy generative models, we feed in as many passages as possible without running into memory issues (Muli-hop RAG takes top 4 passages from hop1, and for each of those, takes another top 4 from hop2. They are not necessarily the same as the top 16 passages sequences.). As extractive models encode each passage sequence separately, we can use arbitrary number of input sequences. However, the performance mostly plateaus as we use over 200 input sequences.}
First, we see that the BERT-wwm reader is 1-2\% worse than the ELECTRA reader when using enough passages. However, it still outperforms the results in \citep{GraphRecurrentRetriever} which also uses BERT-wwm for answer prediction.
While RAG and FiD have shown strong improvements over extractive models on single-hop datasets such as NaturalQuestions~\citep{NQ}, they do not show an advantage in the multi-hop case. Despite having twice as many parameters as ELECTRA, FiD fails to outperform it using the same amount of context (top 50). 
In contrast, on NaturalQuestions, FiD is 4 points better than a similar extractive reader when using the top 100 passages in both.\footnote{We implemented NQ extractive readers with both RoBERTa-large and ELECTRA-large, and RoBERTa-large yielded a better answer EM of 47.3, which is much lower than the 51.4 answer EM achieved by FiD.}
We hypothesize that the improved performance on single-hop questions is due to the ability of larger pretrained models to more effectively memorize single-hop knowledge about real-world entities.\footnote{As shown by \citet{t5close}, a large pretrained seq2seq model can be finetuned to directly decode answers with questions as the only inputs. However, we find that this retrieval-free approach performs poorly on multi-hop questions. See Appendix~\ref{appendix:retrieval_free} for the exact numbers.}
Compared to multi-hop questions that involve multiple relations and missing entities, simple questions usually only ask about a certain property of an entity. It is likely that such simple entity-centric information is explicitly mentioned by a single text piece in the pretraining corpus, while the evidence for multihop questions is typically dispersed, making the complete reasoning chain nontrivial to memorize. More analysis on RAG can be found in Appendix \ref{appendix: reader}.

    

\paragraph{Inference Efficiency}
\label{sec:qa_analysis}

\begin{wrapfigure}{r}{0.5\textwidth}
\vspace{-10pt}
\includegraphics[width=\linewidth]{figures/efficiency.pdf}
\vspace{-20pt}
\caption{Efficiency-performance trade-off comparison with published HotpotQA systems. The curve is plotted with different number of top $k$ ($k$=1,5,10,20,50,100,200) passage sequences we feed into the reader model. seq/Q denotes the time required for each query.}
\vspace{-5pt}
\label{fig:efficiency}
\end{wrapfigure}

To compare with existing multi-hop QA systems in terms of efficiency, we follow \citet{DrKIT} and measure the inference time with 16 CPU cores and batch size 1. We implement our system with a fast approximate nearest neighbor search method, \emph{i.e.}, HNSW~\citep{HNSW}, which achieves nearly the same performance as exact search. With an in-memory index, we observe that the retrieval time is negligible compared to the forward pass of large pretrained models. Similarly, for systems that use term-based indices, the BERT calls for passage reranking cause the main efficiency bottleneck. Thus, for systems that do not release the end-to-end code, we estimate the running time based on the number of BERT cross-attention forward passes (the same estimation strategy used by \citet{DrKIT}), and ignore the overhead caused by additional processing such as TF-IDF or linking graph construction. As shown in Figure~\ref{fig:efficiency}, our method is about 10 times faster than current state-of-the-art systems while achieving a similar level of performance. Compared to two efficient systems (DrKIT and GoldEn), we achieve over 10 points improvement while only using the top-1 retrieval result for answer and supporting sentence prediction.

\subsection{Experiments: Multi-Evidence FEVER}

\begin{table}[t]
    \centering
    \small
    \vspace{-0.2in}
    \caption{Multi-Evidence FEVER Fact Verification Results. \textbf{Loose-Multi} represents the subset that requires multiple evidence \textit{sentences}. \textbf{Strict-Multi} is a subset of \textbf{Loose-Multi} that require multiple evidence sentences from different \textit{documents}.}
    \begin{tabular}{l|cccc}
        \toprule
      \multirow{2}{*}{Method} &  \multicolumn{2}{c}{Loose-Multi (1,960)} &  \multicolumn{2}{c}{Strict-Multi (1,059)} \\
      & LA & FEVER & LA & FEVER \\
        \midrule
       GEAR & 66.4 & 38.0 & - & - \\
       GAT & 66.1 & 38.2 & - & -\\
       KGAT with ESIM rerank & 65.9 & 39.2 & 51.5 & 7.7\\
       KGAT with BERT rerank & 65.9 & 40.1 & 51.0 & 6.2 \\
       \midrule
       Ours + KGAT with BERT rerank  & \textbf{77.9} & \textbf{42.0} & \textbf{72.1} & \textbf{16.2}\\
        \bottomrule
    \end{tabular}
    \label{tab:fever_final}
    \vspace{-0.15in}
\end{table}
For FEVER claim verification, we reuse the best open-sourced verification system, \emph{i.e.}, KGAT~\citep{KGAT}, to show the benefit of our retrieval approach over existing retrieval methods. 
We report the results in verification \emph{label accuracy} (LA) and the \emph{FEVER score}\footnote{FEVER scores takes into account both support sentence accuracy and label accuracy, similar as the joint metrics in HotpotQA.} in Table~\ref{tab:fever_final}, where the numbers of competitive baselines, GEAR~\citep{GEAR}, graph attention network (GAT)~\citep{GAT} and variants of KGAT
are from the KGAT~\citep{KGAT} paper.
All these baselines use entity linking for document retrieval, then rerank the sentences of the retrieved documents, and finally use different graph attention mechanisms over the fully-connected sentence graph to predict verification labels.
Since some instances in the multi-evidence subset used by previous studies only needs multiple evidence \textit{sentences} from the same document, we additionally test on a strict multi-hop subset with instances that need multiple \textit{documents}.
As shown by the results, even without finetuning the downstream modules, simply replacing the retrieval component with \method leads to significant improvements, especially on the strict multi-evidence subset.

\section{Related Work}
\label{sec:related_work}

\paragraph{Open-domain QA with Dense Retrieval}

In contrast to sparse term-index IR methods that are widely used by existing open-domain QA systems~\citep{drqa,wang2017r,yang2019end}, recent systems ~\citep{ORQA,REALM,DPR} typically uses dense passage retrieval techniques that better capture the semantic matching beyond simple n-gram overlaps. To generate powerful dense question and passage representations, these methods either conduct large-scale pretraining with self-supervised tasks that are close to the underlying question-passage matching in retrieval, or directly use the human-labeled question-passage pairs to finetune pretrained masked language models. On single-hop information-seeking QA datasets such as NaturalQuestions~\citep{NQ} or WebQuestions~\citep{WebQ}, these dense methods have achieved significant improvements over traditional IR methods. Prior to these methods based on pretrained models, \citet{das2019multi} use RNN encoder to get dense representations of questions and passages. They also consider an iterative retrieval process and reformulate the query representation based on reader model's hidden states. However, their method requires an initial round of TF-IDF/BM25 retrieval and a sophisticated RL-based training paradigm to work well. Finally, like the aforementioned methods, only single-hop datasets are considered in their experiments. More akin to our approach, \citet{feldman-el-yaniv-2019-multi} use a similar recursive dense retrieval formulation for multi-hop QA. In contrast to their biattenional reformulation component, which is applied on top of the token-level representations of the query and passages, we adopt a more straightforward query reformulation strategy, by simply concatenating the original query and previous retrieval as the inputs to the query encoder. Together with stronger pretrained encoders and more effective training methods (in-batch + memory bank negative sampling  vs their binary ranking loss), \method is able to double the accuracy of their system.  

\paragraph{Query Expansion Techniques in IR} As our dense encoder augments the original question with the initial retrieved results to form the updated query representation, our work is also relevant to query expansion techniques~\citep{rocchio1971relevance,voorhees1994query,ruthven2003survey} that are widely used in traditional IR systems. In particular, our system is similar in spirit to pseudo-relevance feedback techniques~\citep{croft1979using,cao2008selecting,lv2010positional}, where no additional user interaction is required at the query reformulation stage. Existing studies mainly focus on alleviating the uncertainty of the user query~\citep{collins2007estimation} by adding relevant terms from the first round of retrieval, where the retrieval target remains the same throughout the iterative process. In contrast, the query reformulation in our approach aims to follow the multi-hop reasoning chain and effectively retrieves different targets at each step. Furthermore, instead of explicitly selecting terms to expand the query, we simply concatenate the whole passage and rely on the pretrained encoder to choose useful information from the last retrieved passage.

\paragraph{Other Multi-hop QA Work} Apart from HotpotQA, other multi-hop QA datasets~\citep{Wikihop,ComplexWebQ,MetaQA} are mostly built from knowledge bases (KBs). Compared to questions in HotpotQA, questions in these datasets are rather synthetic and less diverse. As multi-hop relations in KBs could be mentioned together in a single text piece, these datasets are not designed for an open-domain setting which necessitates multi-hop retrieval. Existing methods on these datasets either retrieve passages from a small passage pool pruned based on the the specific dataset~\citep{sun2019pullnet,DrKIT}, or focus on a non-retrieval setting where a compact documents set is already given~\citep{de2018question,zhong2019coarse,tu2019multi,beltagy2020longformer}. Compared to these research, our work aims at building an efficient multi-hop retrieval model that easily scales to large real-world corpora that include millions of open-domain documents.

\section{Conclusion}
In this work, we generalized the recently proposed successful dense retrieval methods by extending them to the multi-hop setting.  This allowed us to handle complex multi-hop queries with much better accuracy and efficiency than the previous best methods.  We demonstrated the versatility of our approach by applying it to two different tasks, using a variety of downstream modules.  In addition, the simplicity of the framework and the fact that it does not depend on a corpus-dependent graph structure opens the possibility of applying such multi-hop retrieval methods more easily and broadly cross different domains and settings.

\clearpage

\clearpage

\appendix
\section{Qualitative Analysis}

\subsection{False Bridge Question Error Cases}
\label{sec:false_errors}
As mentioned in \cref{sec:error_analysis}, half of the errors of bridge questions are not real errors. In Table~\ref{tab:bridge_errors}, we can see that the model predicts alternative passage sequences that could also be used to answer the questions.

\begin{table*}[h]
    \centering
    \caption{Error cases where our model predicts a passage sequence that is also correct. Important clues are marked in \textcolor{blue}{blue}.}
    \begin{tabular}{p{0.95\columnwidth}}
    \toprule
    \textbf{Q:} What languages did the son of Sacagawea speak? \\
    \textbf{Ground-truth SP Passage Titles:}  \underline{Charbonneau, Oregon}; \underline{Jean Baptiste Charbonneau}\\
    \textbf{Predicted:} \\
    1. \underline{Museum of Human Beings}: Museum of Human Beings, included in the National American Indian Heritage Month Booklist, November 2012 and 2013 is a novel written by Colin Sargent, which delves into the heart-rending life of \textcolor{blue}{Jean-Baptiste Charbonneau, the son of Sacagawea}. Sacagawea was the Native American guide, who at 16 led the Lewis and Clark expedition. \\
    2. \underline{Jean Baptiste Charbonneau}: Jean Baptiste Charbonneau (February 11, 1805 – May 16, 1866) was an American Indian explorer, guide, fur trapper trader, military scout during the Mexican-American War, "alcalde" (mayor) of Mission San Luis Rey de Francia and a gold prospector and hotel operator in Northern California. He spoke French and English, and learned German and Spanish during his six years in Europe from 1823 to 1829. He spoke Shoshone, his mother tongue, and other western American Indian languages...\\
    \midrule
    \textbf{Q:} Altnahinch is located in a county that has a population density of how many per square mile? \\
    \textbf{Ground-truth SP Passage Titles:} \underline{Altnahinch Dam}; \underline{County Antrim}\\
    \textbf{Predicted:}\\
    1. \underline{Altnahinch}: Altnahinch is a townland \textcolor{blue}{in County Antrim}, Northern Ireland.\\
    2. \underline{County Antrim}: County Antrim (named after the town of Antrim, from Irish: "Aontroim" , meaning "lone ridge" , )) is one of six counties that form Northern Ireland. Adjoined to the north-east shore of Lough Neagh, the county covers an area of 3046 km2 and has a population of about 618,000. County Antrim has a population density of 203 people per square kilometer / 526 people per square mile...\\
    \midrule
    \textbf{Q:} What foundation do scholars give for the likelihood of collaboration on a William Shakespeare Play written between 1588 and 1593? \\
    \textbf{Ground-truth SP Passage Titles:}\\ \underline{Authorship of Titus Andronicus}, \underline{William Shakespeare's collaborations}\\
    \textbf{Predicted:}\\
    1. \underline{Titus Andronicus}: Titus Andronicus is a tragedy by William Shakespeare, \textcolor{blue}{believed to have been written between 1588 and 1593}, probably in collaboration with George Peele. It is thought to be Shakespeare's first tragedy, and is often seen as his attempt to emulate the violent and bloody revenge plays of his contemporaries, which were extremely popular with audiences throughout the 16th century.\\
    2. \underline{William Shakespeare's collaborations}:  Like most playwrights of his period, William Shakespeare did not always write alone... Some of the following attributions, such as "The Two Noble Kinsmen", have well-attested contemporary documentation; others, such as "Titus Andronicus", are dependent on linguistic analysis by modern scholars...\\
    \midrule 
    \textbf{Q:} Zach Parise's father played in which league? \\
    \textbf{Ground-truth SP Passage Titles:} \underline{Jordan Parise}; \underline{Zach Parise} \\
    \textbf{Predicted:}\\
    1. \underline{Zach Parise}: Zachary Justin Parise (born July 28, 1984) is an American professional ice hockey left winger who is currently serving as an alternate captain for the Minnesota Wild in the National Hockey League (NHL). He has also played for the New Jersey Devils, where he served as team captain and led the team to the 2012 Stanley Cup Finals. Parise's father, J. P. Parisé... \\
    2.\underline{ J. P. Parisé}: Jean-Paul Joseph-Louis Parisé (December 11, 1941 – January 7, 2015) was a Canadian professional ice hockey coach and player. \textcolor{blue}{Parise played in the National Hockey League (NHL)}, most notably for the Minnesota North Stars and the New York Islanders. \\
    \bottomrule
    \end{tabular}
    
    \label{tab:bridge_errors}
\end{table*}

\clearpage

\subsection{Examples from the question decomposition analysis}
\label{appendix:decomposed_exmaples}
\begin{table*}[h]
    \centering
    \caption{Sampled retrieval errors (marked in \textcolor{red}{red}) \textit{only} made by the decomposed system. These errors could be potentially avoided if the model has access to the full information in the original question or previous hop results. The important clue for correctly retrieving the documents or avoiding errors is marked in \textcolor{blue}{blue}. Once decomposed, the marked information are not longer available in one of the decomposed retrieval hop.}
    \begin{tabular}{p{0.95\columnwidth}}
    \toprule
     \textbf{Multi-hop Question}:  What is the birthday of the \textcolor{blue}{author} of "She Walks These Hills"?\\
     \textbf{Decomposed Questions}:\\
     1. Who is the author of She Walks These Hills?\\
     2. What is the birthday of Sharyn McCrumb?\\
     \textbf{Ground-truth SP Passages}: \\
     \underline{She Walks These Hills}: She Walks These Hills is a book written by Sharyn McCrumb and published by Charles Scribner's Sons in 1994, which later went on to win the Anthony Award for Best Novel in 1995.\\
     \underline{Sharyn McCrumb}: Sharyn McCrumb (born February 26, 1948) is an American writer whose books celebrate the history and folklore of Appalachia. McCrumb is the winner of numerous literary awards... \\
     \textbf{Decomposed Error Case:} \\
     1. \underline{She Walks These Hills} ($\checkmark$)\\
     2. \textcolor{red}{\underline{Tané McClure}}: Tané M. McClure (born June 8, 1958) is an American \textcolor{blue}{singer and actress}. \\
     \midrule
    \textbf{Multi-hop Question:} When was the album with the song Unbelievable by \textcolor{blue}{American rapper The Notorious B.I.G} released? \\
    \textbf{Decomposed Questions:} \\
    1. What is the album with the song Unbelievable by American rapper The Notorious B.I.G?\\
    2. When was the album Ready to Die released? \\
    \textbf{Ground-truth SP Passages:} \\
    \underline{Unbelievable (The Notorious B.I.G. song)}: Unbelievable is a song by American rapper The Notorious B.I.G., recorded for his debut studio album Ready to Die... \\
    \underline{Ready to Die}: Ready to Die is the debut studio album by American rapper The Notorious B.I.G.; it was released on September 13, 1994, by Bad Boy Records and Arista Records... \\
    \textbf{Decomposed Error Case:} \\
    1. \underline{Unbelievable (The Notorious B.I.G. song)} ($	\checkmark$)\\
    2.\textcolor{red}{\underline{ Ready to Die (The Stooges album)}}: Ready to Die is the fifth and final studio album by \textcolor{blue}{American rock band Iggy and the Stooges}. The album was released on April 30, 2013...\\
    \midrule
    \textbf{Multi-hop Question:} Whose death \textcolor{blue}{dramatized} in a stage play helped end the death penalty in Australia? \\
    \textbf{Decomposed Questions:} \\
    1. What is the stage play that helped end the death penalty in Australia?\\
    2. Whose death was dramatized in Remember Ronald Ryan?\\
    \textbf{Ground-truth SP Passages}:\\
    \underline{Barry Dickins}: Barry Dickins (born 1949) is a prolific Australian playwright, author, artist, actor, educator and journalist... His most well-known work is the award winning stage play "Remember Ronald Ryan", a \textcolor{blue}{dramatization} of the life and subsequent death of Ronald Ryan, the last man executed in Australia...\\
    \underline{Ronald Ryan}: Ronald Joseph Ryan (21 February 1925 – 3 February 1967) was the last person to be legally executed in Australia. Ryan was found guilty of shooting and killing warder George Hodson during an escape from Pentridge Prison, Victoria, in 1965...\\
    \textbf{Decomposed Error Case:}\\
    1. \textcolor{red}{\underline{Capital punishment in Australia}}: Capital punishment in Australia has been abolished in all jurisdictions. Queensland abolished the death penalty in 1922. Tasmania did the same in 1968, the federal government abolished the death penalty in 1973, with application also in the Australian Capital Territory and the Northern Territory...\\
    2.\underline{Ronald Ryan}($\checkmark$)\\
    \bottomrule
    \end{tabular}
    \label{tab:decomposed_errors}
\end{table*}

\subsection{Extractive \& Generative Reader Model}
\begin{wraptable}{r}{6cm}
    \centering
    \small
    \vspace{-0.3in}
    \caption{Answer EM using top 50 retrieved passage chains}
    \begin{tabular}{l|ccc}
    \toprule
    Model   & Overall & \begin{tabular}[c]{@{}l@{}}Comp\\ (20\%)\end{tabular} & \begin{tabular}[c]{@{}l@{}}Bridge\\ (80\%)\end{tabular} \\\midrule
    ELECTRA & 61.7    & 79.0        & 57.4          \\
    FiD     & 61.7    & 75.3        & 58.3  \\ \bottomrule
    \end{tabular}
    \vspace{-0.2in}
    \label{tab:fid_vs_electra}

\end{wraptable}
\label{appendix: reader}
Table~\ref{tab:reader} demonstrates the answer prediction performance for four different reader models. The extractive models predict answers given the top 250 retrieved passage sequences (pairs of passage from hop1 and hop2). Since generative models are generally heavier on the computation side, we can only use fewer passages. Besides the observations alredy discussed in \cref{sec:reader_comparison}, we hypothesize the worse performance of multi-hop RAG compared to FiD is partially due to the smaller pretrained model used in RAG, i.e., BART is only half the size of T5-large. Also, as RAG back-propagate the gradients to the query encoder, it needs more memory footprint and can only take in fewer retrieved contexts. Our RAG implementation largely follows the implementation of the original paper and we did not use the PyTorch checkpoint (as used by FiD) to trade computation for memory. We conjecture the multi-hop RAG performance will also improve if we augment the current implementation with memory-saving tricks. However, given the same amount of context and read model size, the multi-hop RAG is still worse than the extractive ELECTRA reader, i.e., with only the top 1 retrieved passage sequence, our ELECTRA reader gets 53.8 EM compared to the 51.2 answer EM achieved by multi-hop RAG when using more context.

 
Given the same number of retrieved passage sequences (top 50) as shown in table \ref{tab:fid_vs_electra}, FiD obtains similar performance to ELECTRA, despite that the generative model can generate arbitrary answers for the given input. (We tried constrained decoding for the generative model. However, no significant performance improvements were observed, indicating that the errors from the generative model are not due to the free-form generation task.) Further question type analysis in HotpotQA showed that the main difference comes from the comparison type of question, while for bridge question, FiD performs slightly better than ELECTRA. This finding might indicate that for generation models, numerical comparison is still a bigger issue compared to extractive models.

\section{Model Details}

\subsection{Best Model Hyperparameters}
\label{appendix:hyperparameter}
\begin{table}[h]
    \centering
    \caption{Hyperparameters of Retriever}
    \begin{tabular}{lc}
    \toprule
        learning rate & 2e-5\\
        batch size & 150 \\
        maximum passage length & 300 \\
        maximum query length at initial hop & 70 \\
        maximum query length at 2nd hop & 350 \\
        warmup ratio & 0.1 \\
        gradient clipping norm & 2.0 \\
        traininig epoch & 50 \\
        weight decay & 0 \\
    \bottomrule
    \end{tabular}
    \label{tab:my_label}
\end{table}

\begin{table}[h]
    \centering
    \caption{Hyperparameters of Extractive Reader (ELECTRA)}
    \begin{tabular}{lc}
    \toprule
        learning rate & 5e-5\\
        batch size & 128 \\
        maximum sequence length & 512 \\
        maximum answer length & 30 \\
        warmup ratio & 0.1 \\
        gradient clipping norm & 2.0 \\
        traininig epoch & 7 \\
        weight decay & 0 \\
        \# of negative context per question & 5 \\
        weight of SP sentence prediction loss & 0.025 \\
    \bottomrule
    \end{tabular}
    \label{tab:my_label}
\end{table}

\subsection{Further Details about Reader Models}
\label{appendix:multihop_rag}

\subsubsection{Extractive Reader}
The extractive reader is trained with four loss functions. With the \texttt{[CLS]} token, we predict a reranking score based on whether the passage sequence match the groundtruth supporting passages. On top of the representation of each token, we predict a answer start score and answer end score. Finally, we prepend each sentence with the \texttt{[unused0]} special token and predict whether the sentence is one of the supporting sentences using the representations of the special token. At training time, we pair each question with 1 groundtruth passage sequence and 5 negative passage sequence which do not contain the answer. At inference time, we feed in the top 250 passage sequences from \method. We rank the predicted answer for each sequence with a linear combination of the reranking score and the answer span score. The combination weight is selected based on the dev results.

\subsubsection{Fusion-in-Decoder}
The FiD model uses T5-large as the underlying seq2seq model. It is twice as large as the extractive models and has 770M parameters. We reuse the hyperparameters as described in \citet{FiD}. The original FiD uses the top 100 passages for NaturalQuestions. In our case, we use the top 50 retrieved passage sequences and concatenate the passages in each sequence before feeding into T5. In order to fit this model into GPU, we make use of PyTorch checkpoint~\footnote{https://pytorch.org/docs/stable/checkpoint.html} for training. 

\subsubsection{Multi-Hop RAG}

The RAG model aims to generate answer $y$ given question $x$ and the retrieved documents $z$. Similarly, the goal of multi-hop RAG can be expressed as: generate answer $y$ given question $x$ and retrieved documents in hop one $z_1$ and hop two $z_2$ (Limiting to two hops for HotpotQA). The model has three components: 
\begin{itemize}
    \item Hop-one retriever $p_{\eta_1}(z_1|x)$ with parameter $\eta_1$ to represent the retrieved top-k passage distribution (top-k truncated distribution) given the input question $x$. 
    \item Hop-two retriever $p_{\eta_2}(z_2|x, z_1)$ with parameter $\eta_2$ to represent the hop-two retrieved top-k passage distribution given not only the question $x$ but also the retrieved document $z_1$ from hop-one. 
    \item A generator $p_\theta(y_i|x, z_1, z_2, , y_{1:i-1})$ to represent the next token distribution given input question $x$, hop-one retrieved document $z_1$, hop-two retrieved document $z_2$ and previous predicted token $y_{1:i-1}$ parametrized by $\theta$
\end{itemize}
 \paragraph{Multi-Hop RAG Sequence Model}
 As the RAG Sequence model, this model generates the answer sequence given the fixed set of documents from hop-one retriever and hop-two retriever. In order to the get the probability of the generated sequence, we marginalize through the two latent variables corresponding to the two retrieval hops:
\begin{align*}
& p_{\textit{sequence}}(y|x) = \\
& \sum_{z_1}  p_{\eta_1}(z_1|x)\sum_{z_2} p_{\eta_2}(z_2|x, z_1) \prod_{i}^{N} p_\theta(y_i|x, z_1, z_2, y_{1:i-1}) \\
& \sum_{z_1} \sum_{z_2}  p_{\eta_1}(z_1|x) p_{\eta_2}(z_2|x, z_1) \prod_{i}^{N} p_\theta(y_i|x, z_1, z_2, y_{1:i-1})
\end{align*}
where $z_1$ and $z_2$ are top k document from the respective retrieval modules.

 \paragraph{Multi-Hop RAG Token Model}
 Moreover, the model can make predictions based on different passage extracted at each token. 
\begin{align*}
& p_{\textit{token}}(y|x) = \\
& \prod_{i}^{N}  \sum_{z_1}  \sum_{z_2} p_{\eta_1}(z_1|x) p_{\eta_2}(z_2|x, z_1) p_\theta(y_i|x, z_1, z_2, y_{1:i-1})
\end{align*}

The predicted probability for each token is the following
\begin{align*}
& p_{\textit{token}}(y_{i}|(x, y_{j})) = \\
& \sum_{z_1}  \sum_{z_2} p_{\eta_1}(z_1|x) p_{\eta_2}(z_2|x, z_1) p_\theta(y_i|x, z_1, z_2, y_{1:i-1})
\end{align*}

\section{Retrieval-free Approaches}
\label{appendix:retrieval_free}
Inspired by a recent work~\citep{t5close} that trains the T5 seq2seq model to directly decode answers from  questions (\textit{retrieval-free}), we conduct similar experiments on HotpotQA using BART~\citep{BART}. As shown in Figure~\ref{fig:retrieval_free}, the performance gap between retrieval-based methods and retrieval-free methods on multi-hop QA is much larger than the gap in the case of simple single-hop questions. 

\begin{figure*}[h]
\centering
\includegraphics[width=.7\linewidth]{retrieval_free.pdf}
\vspace{-0.2in}
\caption{Performance gap between retrieval-free and retrieval-based methods on different QA datasets.}
\label{fig:retrieval_free}
\end{figure*}

\section{A Unified QA Retrieval System}

In practice, when a fixed text corpus is given for open-domain systems, we do not know beforehand whether the incoming questions require single or multiple text evidence. Thus, it is essential to build a unified system that adaptively retrieves for multiple hops. Due to the simplicity of the approach, our method can easily be extended in the unified setup. To the best of our knowledge, only \citep{GraphRecurrentRetriever} test the same retrieval method on both single and multi-hop questions but with separate trained models. Here we take a further step and explore the possibility of using a single retrieval model for both types of questions.
 
To enable adaptive retrieval, we add a binary prediction head on top of the question encoder. Once the retriever finishes the 1-hop retrieval, it encodes concatenation of $q$ and $p_1$ and predicts whether to stop retrieval using the final hidden state of the first token. We construct this unified setting with NaturalQuestions-Open~\citep{ORQA} (NQ) as single-hop and HotpotQA as multi-hop. As the two datasets use different corpora, we merge the two\footnote{The Wikipedia corpus of NQ is taken from DPR~\citep{DPR}.} for easy comparison. As baselines, we use the retrieval models trained only on the respective dataset. For HotpotQA, the baseline is the best multi-hop retrieval model discussed in the main text. For NQ, we follow the training method in DPR~\citep{DPR}, but with a shared question and passage encoder, which achieves stronger results. As the NQ corpus includes multiple passages of the same document and the HotpotQA corpus only uses the introduction passage, we are not able to compute the strict title-based support passage recall for HotpotQA as in \cref{sec:exp-hotpotqa}. Thus, we only evaluate answer recall. Results are in Table~\ref{tab:unified}. In contrast to existing studies that train different models for each dataset, we show that a unified dense retrieval model can maintain competitive performance on both, despite the vastly different nature of both datasets. Note that the information-seeking questions in NQ is usually noisier and more ambiguous, while HotpotQA questions are more complicated and contains more lexical overlaps with the evidence passages. Specifically, for NQ, the unified retrieval model achieves very similar performance as the single-dataset DPR model, while the performance on HotpotQA decreases more. We conjecture that this is because the information-seeking questions in NQ cover more diverse patterns, and the added HotpotQA training questions do not cause a dramatic distribution shift from the NQ test data. We leave the development of a more general retrieval system that handles different styles of questions to future work.

\begin{table}[h]
    \centering
    \small
    \caption{Comparing the unified retrieval model with models specifically trained for each task. We test the retrieval performance with a single merged corpus. For easy comparison, all three models are based on BERT-base encoder which we find achieves stronger performance than RoBERTa-base on NQ. AR@K denotes answer recall at top-K retrieved passage sequences.}
    \begin{tabular}{c|cccc}
    \toprule
    \multirow{2}{*}{Model} &  \multicolumn{2}{c}{NQ} & \multicolumn{2}{c}{HotpotQA} \\
              & AR@20 & AR@100 & AR@20 & AR@100\\
        \midrule
        single-hop only & 80.7 & 87.3 & - & -\\
        multi-hop only & - & - & 83.4 & 89.4  \\
        unified & 79.5 & 86.1 & 78.1 & 83.0 \\
        \bottomrule
    \end{tabular}
    
    \label{tab:unified}
\end{table}

\end{document}