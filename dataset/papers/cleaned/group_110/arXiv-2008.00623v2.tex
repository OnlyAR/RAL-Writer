\title{DeLighT: Deep and Light-weight Transformer}

\begin{document}

\maketitle

\begin{abstract}
We introduce a deep and light-weight transformer, DeLighT , that delivers similar or better performance than standard transformer-based models with significantly fewer parameters. DeLighT ~more efficiently allocates parameters both (1) within each Transformer block using the DeLighT transformation , a deep and light-weight transformation and (2) across blocks using block-wise scaling, that allows for shallower and narrower DeLighT ~blocks near the input and wider and deeper DeLighT ~blocks near the output. Overall, DeLighT ~networks are 2.5 to 4 times deeper than standard transformer models and yet have fewer parameters and operations. Experiments on benchmark machine translation and language modeling tasks show that DeLighT ~matches or improves the performance of baseline Transformers with 2 to 3 times fewer parameters on average. 
\end{abstract}

\section{Introduction}
Attention-based transformer networks~\citep{vaswani2017attention} are widely used for sequence modeling tasks, including language modeling and machine translation. To improve performance, models are often scaled to be either wider, by increasing the dimension of hidden layers, or deeper, by stacking more transformer blocks. For example, T5 \citep{raffel2019exploring} uses a dimension of 65K and GPT-3 \citep{brown2020language} uses 96 transformer blocks. However, such scaling increases the number of network parameters significantly (e.g., T5 and GPT-3 have 11 billion and 175 billion parameters, respectively), and complicates learning, i.e., these models either require very large training corpora \citep{raffel2019exploring,devlin2018bert,brown2020language} or careful regularization \citep{hinton2012improving,wan2013regularization,merity2018regularizing}. In this paper, we introduce a new parameter-efficient attention-based architecture that can be easily scaled to be both wide and deep. 

Our \texttt{De}ep and \texttt{Ligh}t-weight \texttt{T}ransformer architecture, DeLighT , extends the transformer architecture of \citet{vaswani2017attention} and delivers similar or better performance with significantly fewer parameters and operations. At the heart of DeLighT ~is the DeLighT transformation ~that uses the group linear transformations (GLTs) of \citet{mehta2018pyramidal} with an expand-reduce strategy for varying the width and depth of the DeLighT ~block efficiently. Since GLTs are local by nature, the DeLighT transformation ~uses feature shuffling, which is analogous to channel shuffling in convolutional networks \citep{zhang2018shufflenet}, to share information between different groups. Such wide and deep representations facilitate replacing the multi-head attention and feed-forward layers in transformers with single headed attention and light-weight feed-forward layers, reducing total network parameters and operations. Importantly, unlike transformers, the DeLighT transformation ~decouples the depth and width from the input size, allowing us to allocate parameters more efficiently across blocks by using shallower and narrower DeLighT ~blocks near the input and deeper and wider DeLighT ~blocks near the output.

We demonstrate that DeLighT ~models achieve similar or better performance than transformer models with significantly fewer parameters and operations, on two common sequence modeling tasks, (i) machine translation and (ii)  language modeling. On the low resource WMT'16 En-Ro machine translation dataset, DeLighT ~attains transformer performance using $2.8\times$ fewer parameters. On the high resource WMT'14 En-Fr dataset, DeLighT ~delivers better performance (+0.4 BLEU score) with $1.8\times$ fewer parameters than baseline transformers. Similarly, on language modeling, DeLighT ~matches the performance of  Transformer-XL~\citep{dai2019transformer} with $1.5\times$ fewer parameters on the WikiText-103 dataset. Our source code is open-source and is available at: \textcolor{blue}{\url{https://github.com/sacmehta/delight}}

\section{Related Work}
\label{sec:related_work}

\noindent{\bf Improving transformers:} Several methods have been introduced to improve the transformer architecture. The first line of research addresses the challenge of computing self attention on long input sequences \citep{child2019generating,Kitaev2020Reformer,Beltagy2020Longformer}. These methods can be combined with our architecture. The second line of research focuses on explaining multi-head attention \citep{raganato2018analysis,Brunner2020On}. They show that increasing the number of transformer heads can lead to redundant representations \citep{voita2019bottom,michel2019sixteen} and using fixed attention heads with predefined patterns \citep{raganato2020fixed} or synthetic attention matrices \citep{tay2020synthesizer} improves performance. 
%These results support our design choice of using single-head attention. 
The third line of research focuses on improving transformers by learning better representations \citep{wu2018pay,Wu2020Lite,so2019evolved}. These works aim to improve the expressiveness of transformers using different transformations -- for example, using convolutions \citep{wu2018pay, gehring2017convolutional}, gated linear units \citep{dauphin2017language}, or multi-branch feature extractors \citep{so2019evolved,Wu2020Lite}. Our work falls into this category. Unlike previous works, we show that it is possible to efficiently allocate parameters both at the block-level using the DeLighT transformation ~and across blocks using block-wise scaling.

\noindent{\bf Model scaling:} Model scaling is a standard method to improve the performance of sequence models \citep{vaswani2017attention,raffel2019exploring,lan2020ALBERT,devlin2018bert,shoeybi2019megatron,tan2019efficientnet,brown2020language}. Model dimensions are increased in width-wise scaling \citep{vaswani2017attention,devlin2018bert} while more blocks (e.g., Transformer blocks) are stacked in depth-wise scaling \citep{shoeybi2019megatron,brown2020language,wang2019learning}. In both cases (and their combination), parameters inside each block of the network are the same, which may lead to a sub-optimal solution. To further improve the performance of sequence models, this paper introduces \textit{block-wise scaling} that allows for variably-sized blocks and efficient allocation of parameters in the network. Our results show that (1) shallower and narrower DeLighT ~blocks near the input and deeper and wider DeLighT ~blocks near the output deliver the best performance, and (2) models with block-wise scaling coupled with model scaling achieve better performance compared to model scaling alone. We note that convolutional neural networks (CNNs) also learn shallower and narrower representations near the input and deeper and wider representations near the output. Unlike CNNs (e.g., ResNet of \citealt{he2016deep}) that perform a fixed number of operations at each convolutional layer, the proposed block-wise scaling uses a variable number of operations in each layer and block. 

\noindent{\bf Improving sequence models:} There is also significant recent work on other related methods for improving sequence models, including (1) improving accuracy using better token-level representations -- for example, using BPE \citep{sennrich2015neural}, adaptive inputs \citep{baevski2018adaptive} and outputs \citep{grave2017efficient}, and DeFINE \citep{mehta2020DeFINE}, and (2) improving efficiency -- for example, using compression \citep{chen2018groupreduce,sun2020mobilebert}, pruning \citep{han2015deep,voita2019analyzing}, and distillation \citep{hinton2015distilling,sanh2019distilbert}. The closest to our work is the DeFINE transformation, which also learns representations using an expand-reduce strategy. The key difference between the DeFINE transformation (Figure \ref{fig:hgt}) and the DeLighT transformation ~(Figure \ref{fig:ihgt}) is that the DeLighT transformation ~more efficiently allocates parameters within expansion and reduction layers. Unlike DeFINE, which uses fewer groups in group linear transformations to learn wider representations, DeLighT transformation ~uses more groups to learn wider representations with fewer parameters. The DeLighT transformation ~achieves comparable performance to the DeFINE transformation but with significantly fewer parameters.

\section{DeLighT: Deep and Light-weight Transformer}
\label{sec:arcitecture}

A standard transformer block (Figure \ref{fig:transformer_sa}) comprises of multi-head attention that uses a query-key-value decomposition to model relationships between sequence tokens, and a feed forward network (FFN) to learn wider representations. Multi-head attention obtains query $\mathbf{Q}$, key $\mathbf{K}$, and value $\mathbf{V}$ by applying three projections to the input, each consisting of $h$ linear layers (or heads) that map the $d_m$-dimensional input into a $d_h$-dimensional space, where $d_h=d_m/h$ is the head dimension. The FFN consists of two linear layers, where the first expands the dimensions from $d_m$ to $d_f$ and the second reduces the dimensions from $d_f$ to $d_m$. The depth of a transformer block is 4, consisting of (1) three parallel branches for queries, keys, and values, (2) a fusion layer that combines the output of multiple heads, and (3) two sequential linear layers in the FFN. In general, transformer-based networks sequentially stacks transformer blocks to increase network capacity and depth.

This paper extends the transformer architecture and introduces a deep and light-weight transformer, DeLighT . Our model uses a deep and light-weight expand-reduce transformation, DeLighT transformation ~(Section \ref{ssec:dextra}), that enables learning wider representations efficiently. It also enables replacing multi-head attention and feed forward network (FFN) layers with single-head attention and a light-weight FFN (Section \ref{ssec:dextra_transformer}). DeLighT transformation ~decouples attention dimensions from the depth and width, allowing us to learn representations efficiently using block-wise scaling instead of uniform stacking of transformer blocks (Section \ref{ssec:layer_wise_scaling}).
%
\begin{figure}[t!]
    \centering
    \begin{subfigure}[b]{0.35\columnwidth}
        \centering
        \resizebox{!}{160px}{
            \input{tikz/self_attention_units.tikz}\transformer
        }
        \caption{Transformer block}
        \label{fig:transformer_sa}
    \end{subfigure}
    \hfill
    \begin{subfigure}[b]{0.33\columnwidth}
        \centering
        \resizebox{!}{165px}{
            \input{tikz/self_attention_units.tikz}\redefine
        }
        \caption{DeLighT ~ block}
        \label{fig:redefine_transformer_sa}
    \end{subfigure}
    \hfill
    \begin{subfigure}[b]{0.3\columnwidth}
        \centering
        \begin{subfigure}[b]{\columnwidth}
            \centering
            \resizebox{!}{70px}{
                \input{tikz/dextra_new}\define
            }
            \caption{DeFINE transformation}
            \label{fig:hgt}
            \end{subfigure}
            \vfill
            \begin{subfigure}[b]{\columnwidth}
            \centering
            \resizebox{!}{70px}{
                \input{tikz/dextra_new}\invHGTShuffle
            }
            \caption{DeLighT transformation }
            \label{fig:ihgt}
        \end{subfigure}
    \end{subfigure}
    \caption{\textbf{(a, b)} Block-wise comparison between the standard transformer block of \citet{vaswani2017attention} and the DeLighT ~block. In the DeLighT transformation , the number of operations in computing attention are reduced by half while the number of parameters (and operations) in the FFN are reduced by $16\times$. Transformations with learnable parameters (\colorbox{cyan!40}{Linear} and \colorbox{green!20}{DeLighT }) are shown in color. The shape of linear transformations indicate their operation (expansion, reduction, etc.). \textbf{(c, d)} compares the DeFINE transformation \citep{mehta2020DeFINE} with the DeLighT transformation . Compared to the DeFINE transformation, the DeLighT transformation ~uses group linear transformations (GLTs) with more groups to learn wider representations with fewer parameters. Different colors are used to show groups in GLTs. For simplicity, feature shuffling is not shown in (d).}
    \label{fig:compare_tam_ram_sa}
\end{figure}
%%
%
\subsection{DeLighT Transformation}
\label{ssec:dextra}
DeLighT transformation ~maps a  $d_m$ dimensional input vector into a high dimensional space (expansion) and then reduces it down to a  $d_o$ dimensional output vector (reduction) using  $N$ layers of the group transformations of \citet{mehta2018pyramidal}, as shown in Figure \ref{fig:ihgt}. During these expansion and reduction phases, DeLighT transformation ~uses group linear transformations (GLTs) because they learn local representations by deriving the output from a specific part of the input and are more efficient than linear transformations. To learn global representations, the DeLighT transformation ~shares information between different groups in the group linear transformation using feature shuffling, analogous to channel shuffling in convolutional networks \citep{zhang2018shufflenet}. 

A standard approach to increase the expressivity and capacity of transformers is to increase the input dimensions, $d_m$. However, increasing $d_m$ linearly also increases the number of operations in multi-head attention ($\mathcal{O}(n^2 d_m)$, where $n$ is the sequence length) in a standard transformer block (Figure \ref{fig:transformer_sa}). In contrast, to increase the expressivity and capacity of the DeLighT ~block, we increase the depth and width of its intermediate DeLighT ~ transformations using expansion and reduction phases. This enables us to use smaller dimensions for computing attention, requiring fewer operations. 

Formally, the DeLighT transformation ~is controlled by five configuration parameters: (1) number of GLT layers $N$, (2) width multiplier $w_m$, (3) input dimension $d_m$, (4) output dimension $d_o$, and (5) maximum groups $g_{max}$ in a GLT. In the expansion phase, the DeLighT transformation ~projects the $d_m$-dimensional input to a high-dimensional space, $d_{max}=w_m d_m$, linearly using $\lceil \frac{N}{2} \rceil$ layers. In the reduction phase, the DeLighT transformation ~projects the $d_{max}$-dimensional vector to a $d_o$-dimensional space using the remaining $N - \lceil \frac{N}{2} \rceil$ GLT layers. Mathematically, we  define the output $\mathbf{Y}$ at each GLT layer $l$ as:
\begin{equation}
    \mathbf{Y}^l = \left\{
    \begin{array}{ll}
        \mathcal{F} \left(\mathbf{X}, \mathbf{W}^l, \mathbf{b}^l, g^l\right), & l = 1 \\
        \mathcal{F} \left( \mathcal{H}\left(\mathbf{X}, \mathbf{Y}^{l-1}\right), \mathbf{W}^l,  \mathbf{b}^l, g^l\right), &  \text{Otherwise}
    \end{array}
    \right.
    \label{eq:glt}
\end{equation}
where $\mathbf{W}^l = \left\{ \mathbf{W}^l_1, \cdots, \mathbf{W}^l_{g^l}\right\}$ and $\mathbf{b}^l = \left\{ \mathbf{b}^l_1, \cdots, \mathbf{b}^l_{g^l}\right\}$ are the learnable weights and biases of group linear transformation $\mathcal{F}$ with $g^l$ groups at the $l$-th layer. Briefly, the $\mathcal{F}$ function takes the input $\mathbf{X}$ $\left(\text{or } \mathcal{H}\left(\mathbf{X}, \mathbf{Y}^{l-1}\right)\right)$ and splits into $g^l$ non-overlapping groups such that $\mathbf{X} = \left\{\mathbf{X}_1, \cdots, \mathbf{X}_{g^l} \right\}$. The function $\mathcal{F}$ then linearly transforms each $\mathbf{X}_i$ with weights $\mathbf{W}^l_i$ and bias $\mathbf{b}^l_i$ to produce output $\mathbf{Y}^l_i = \mathbf{X}_i \mathbf{W}_i^l + \mathbf{b}_i^l$. The outputs of each group $\mathbf{Y}^l_i$ are then concatenated to produce the output $\mathbf{Y}^l$. The function $\mathcal{H}$ first shuffles the output of each group in $\mathbf{Y}^{l-1}$ and then combines it with the input $\mathbf{X}$ using the input mixer connection of \citet{mehta2020DeFINE} to avoid vanishing gradient problems. Figure \ref{fig:delight_layer_vis} visualizes the expansion phase in the DeLighT ~transformation with group linear transformation, feature shuffling, and the input mixer connection.

The number of groups at the $l$-th GLT in DeLighT transformation ~are computed as:
\begin{equation}
    g^l = \left\{
    \begin{array}{lr}
       \text{min}(2^{l-1}, g_{max}), & 1 \leq l \leq \ceil*{N/2} \\
       g^{N-l}, & \text{Otherwise}
    \end{array}
    \right.
    \label{eq:group}
\end{equation}
In our experiments, we use $g_{max} = \lceil \frac{d_m}{32} \rceil$ so that each group has at least 32 input elements. 

\begin{figure}[t!]
    \centering
    \includegraphics[height=110px]{glt_images/glt_shuffle_inp_hr.pdf}
    \caption{Example illustrating the expansion phase in the DeLighT ~transformation that uses GLTs, feature shuffling, and an input mixer connection, to learn deeper and wider representations efficiently. For illustrative purposes, we have used the same input and output dimensions.}
    \label{fig:delight_layer_vis}
\end{figure}

\subsection{DeLighT block}  
\label{ssec:dextra_transformer} 
Figure \ref{fig:redefine_transformer_sa} shows how we integrate DeLighT transformation ~into the transformer block to improve its efficiency. The $d_m$-dimensional inputs are first fed to the DeLighT transformation ~to  produce $d_o$-dimensional outputs, where $d_o < d_m$. These $d_o$-dimensional outputs are then fed into a single head attention, followed by a light-weight FFN to model their relationships. 

\noindent{\bf DeLighT ~layer and single head attention:} Let us assume we have a sequence of $n$ input tokens, each of dimensionality $d_m$. These $n$, $d_m$-dimensional inputs are first fed to the DeLighT transformation ~to produce $n$, $d_o$-dimensional outputs, where $d_o < d_m$.  These $n$, $d_o$-dimensional outputs are then projected simultaneously using three linear layers to produce $d_o$-dimensional queries $\mathbf{Q}$, keys $\mathbf{K}$, and  values $\mathbf{V}$. We then model contextual relationships between these $n$ tokens using scaled dot-product attention (Eq. \ref{eq:espda}). To enable the use of residual connections \citep{he2016deep}, the $d_o$-dimensional outputs of this attention operation are  linearly projected into a $d_m$-dimensional space.
\begin{equation}
    \text{Attention}(\mathbf{K}, \mathbf{Q}, \mathbf{V}) = \text{softmax}\left(\frac{\mathbf{Q}\mathbf{K}^T}{\sqrt{d_o}}\right) \mathbf{V}
    \label{eq:espda}
\end{equation}
We hypothesize that the ability of DeLighT ~to learn wider representations allows us to replace multi-head attention with single-head attention. The computational costs for computing attention in the standard transformer and the DeLighT ~block are $\mathcal{O}(d_m n^2)$ and $\mathcal{O}(d_o n^2)$ respectively, where $d_o < d_m$. Therefore, the DeLighT ~block reduces the cost for computing attention by a factor of $d_m/d_o$. In our experiments, we used $d_o=d_m/2$, thus requiring $2\times$ fewer multiplication-addition operations as compared to the transformer architecture. 

\noindent {\textbf{Light-weight FFN:}} Similar to FFNs in transformers, this block also consists of two linear layers. Since the DeLighT ~block has already incorporated wider representations using the DeLighT transformation , it allows us to invert the functionality of FFN layers in the transformer. The first layer reduces the dimensionality of the input from $d_m$ to $d_m/r$ while the second layer expands the dimensionality from $d_m/r$ to $d_m$, where $r$ is the reduction factor  (see Figure \ref{fig:redefine_transformer_sa}). Our light-weight FFN reduces the number of parameters and operations in the FFN by a factor of $r d_f/d_m$. In the standard transformer, the FFN dimensions are expanded by a factor of $4$.\footnote{Transformer-base uses $d_m$=512 and $d_f$=2048 while Transformer-large uses $d_m$=1024 and $d_f$=4096.} In our experiments, we used $r=4$. Thus, the light-weight FFN reduces the number of parameters in the FFN by $16\times$. 

\noindent {\textbf{Block depth:}} The DeLighT ~block stacks (1) a DeLighT transformation ~with $N$ GLTs, (2) three parallel linear layers for key, query, and value, (3) a projection layer, and  (4) two linear layers of a light-weight FFN. Thus, the depth of DeLighT ~block is $N + 4$. Compared to the standard transformer block (depth is 4), DeLighT ~block is deeper.

\subsection{Block-wise scaling}
\label{ssec:layer_wise_scaling}
Standard methods for improving the performance of sequence models include increasing the model dimensions (width scaling), stacking more blocks (depth scaling), or both. However, such scaling is not very effective on small datasets. For example, when a Transformer-Base ($d_m=512$)  network is replaced with Transformer-Large ($d_m=1024$) on the WMT'16 En-Ro corpus, the number of parameters increases by approximately $4\times$ while the performance does not change appreciably (BLEU: 34.28 vs. 34.35). We hypothesize that this happens because scaling model width and depth allocates parameters uniformly across blocks, which may lead to learning redundant parameters. To create deep and wide networks, we extend model scaling to the block level (see Figure \ref{fig:fixed_vs_layer_wise}).
\begin{figure}[t!]
    \centering
    \begin{subfigure}[b]{0.28\columnwidth}
        \centering
        \resizebox{!}{80px}{
            \input{tikz/scaling_new.tikz}\scaling
        }
        \caption{Uniform vs. block-wise}
        \label{fig:com_tam_ram}
    \end{subfigure}
    \hfill
    \begin{subfigure}[b]{0.7\columnwidth}
        \centering
        \begin{tabular}{cc}
            \includegraphics[height=80px]{images/redef_params_uni_layer.pdf} &  \includegraphics[height=80px]{images/redef_ops_uni_layer.pdf}
        \end{tabular}
        \caption{Distribution of parameters and operations within each block}
    \end{subfigure}
    \caption{\textbf{Block-wise scaling} efficiently allocates parameters and operations across blocks, leading to shallower and narrower DeLighT ~blocks near the input and deeper and wider DeLighT ~blocks near the output. In (b), DeLighT ~networks with both uniform ($N$=$N_{min}$=$N_{max}$=8) and block-wise ($N_{min}$=4, $N_{max}$=8) scaling have about 16.7 M parameters and perform 3.5 B operations (computed for a sequence length of $n=30$), however, the DeLighT ~network with block-wise scaling delivered 2 points better perplexity.} 
    \label{fig:fixed_vs_layer_wise}
\end{figure}
%%

\noindent{\bf Scaling the DeLighT block:} The DeLighT ~block learns deep and wide representations using the DeLighT transformation , whose depth and width are controlled by two configuration parameters: the number of GLT layers $N$ and the width multiplier $w_m$, respectively (Figure \ref{fig:com_tam_ram}). These configuration parameters allow us to increase the number of learnable parameters inside the DeLighT ~block independently of the input $d_m$ and output $d_o$ dimensions. Such calibration is not possible with the standard transformer block because their expressiveness and capacity are a function of the input (input dimension = number of heads $\times$ head dimension). Here, we introduce block-wise scaling that creates a network with variably-sized DeLighT ~blocks, allocating shallower and narrower DeLighT ~blocks near the input and deeper and wider DeLighT ~blocks near the output.

To do so, we introduce two network-wide configuration parameters: minimum $N_{min}$ and maximum $N_{max}$ number of GLTs in a DeLighT transformation . For the $b$-th DeLighT ~block, we  compute the number of GLTs $N^b$ and the width multiplier $w_m^b$ in a DeLighT transformation ~using linear scaling (Eq. \ref{eq:mw}). With this scaling, each DeLighT ~block has a different depth and width (Figure \ref{fig:com_tam_ram}). 
\begin{equation}
       N^{b} = N_{min} + \frac{(N_{max} - N_{min})\ b}{\mathcal{B}-1}, \quad w_m^{b} =  w_m + \frac{(N_{max} - N_{min})\ b}{N_{min}(\mathcal{B}-1)}, \quad 0 \le b \le \mathcal{B}-1
    \label{eq:mw}
\end{equation}
Here, $\mathcal{B}$ denotes the number of DeLighT ~blocks in the network. We add superscript $b$ to number of GLT layers $N$ and width multiplier $w_m$ to indicate that these parameters are for the $b$-th block. 

\noindent{\bf Network depth:} The depth of transformer block is fixed, i.e., 4. Therefore, previous works \citep{raffel2019exploring,brown2020language,wang2019learning} have associated the depth of transformer-based networks with the number of transformer blocks. In DeLighT , we present a different perspective to learn deeper representations, wherein each block is variably-sized. To compute the network depth, we use the standard definition across different domains, including computer vision (e.g., ResNet of \citealt{he2016deep}) and theoretical machine learning \citep{telgarsky2016benefits}. These works measures network depth as the number of sequential learnable layers (e.g., convolution, linear, or group linear). Similarly, the depth of DeLighT ~and transformer networks with $\mathcal{B}$ blocks is $\sum_{b=0}^{\mathcal{B}-1} (N^b + 4)$ and $4\mathcal{B}$, respectively.

\section{Experimental results}
\label{sec:results}
We evaluate the performance of DeLighT ~on two standard sequence modeling tasks: (1) machine translation (Section \ref{ssec:machine_translation}) and (2) language modeling (Section \ref{ssec:language_mdoeling}).

\subsection{Machine Translation}
\label{ssec:machine_translation}
\noindent {\bf Datasets and evaluation:} We benchmark DeLighT ~models on four datasets: (1) IWSLT'14 German-English (De-En), (2) WMT'16 English-Romanian (En-Ro), (3) WMT'14 English-German (WMT'14 En-De), and (4) WMT'14 English-French (WMT'14 En-Fr). For the IWSLT'14 De-En dataset, we replicate the setup of \citet{wu2018pay} and \citet{edunov2018classical}, which uses 160K/7K/7K sentence pairs for training, validation, and testing with a joint BPE vocabulary of about 10K tokens, respectively. For the WMT'14 English-German (En-De) dataset, we follow the setup of \citet{vaswani2017attention}. The dataset has 3.9M/39K/3K sentence pairs for training, validation, and testing respectively with a joint BPE vocabulary size of 44K.\footnote{We use training and validation data that is compatible with the Tensor2Tensor library \citep{tensor2tensor} in order to have fair comparisons with recent works (e.g., Evolved Transformer).} For the WMT'14 English-French (En-Fr) dataset, we replicate the setup of \citet{gehring2017convolutional}, which uses 36M/27K/3K sentence pairs for training, validation, and testing respectively with a joint BPE vocabulary size of 44K. The performance is evaluated in terms of \textit{BLEU} \citep{papineni2002bleu} (higher is better) on the test set. We follow \citet{wu2018pay} for beam search related hyper-parameters.

\noindent {\bf Architecture:} We follow the symmetric encoder-decoder architecture of \citet{vaswani2017attention} with sinusoidal positional encodings. Both the encoder and the decoder have $\mathcal{B}$ DeLighT ~blocks. Decoder blocks are identical to the encoder blocks (Figure \ref{fig:redefine_transformer_sa}), except that they have an additional source-target single-head attention unit before the light-weight FFN. In the source-target single-head attention unit, keys and values are projections over the encoder output (full details in Appendix \ref{sec:appendix_enc_dec_arch}).  In our experiments, we use $w_m=2$, $N_{min}=4$, and $N_{max}=8$ for WMT'16 En-Ro, WMT'14 En-De, and WMT'14 En-Fr; resulting in 222 layer deep DeLighT ~networks. For IWSLT'14 De-En, we used $w_m=1$, $N_{min}=3$, and $N_{max}=9$ for IWSLT'14 De-En; resulting in 289 layer deep network. For simplicity, we set $\mathcal{B}=N_{max}$. We use a learnable look-up table that maps every token in the vocabulary to a 128-dimensional vector. We implement our models using Fairseq \citep{ott2019fairseq} and use their provided scripts for data pre-processing, training, and evaluation.

\noindent {\bf Training:} For IWSLT'14 De-En models, we follow the setup of \cite{wu2018pay} and train all our models for 50K iterations with a batch size of 4K tokens on a single NVIDIA GTX 1080 GPU. For WMT'16 En-Ro, we follow the training setup of \cite{ghazvininejad2019mask} and train models for 100K iterations on 16 NVIDIA Tesla V100 GPUs with an effective batch size of 64K tokens. For WMT'14 En-De and WMT'14 En-Fr, we follow the training set-up of \cite{wu2018pay} and train our models on 16 V100 GPUs for 30K and 50K iterations, respectively. We use Adam \citep{kingma2014adam} to minimize cross entropy loss with a label smoothing value of 0.1 during training. For a fair comparison, we trained baseline transformer models using the same training set-up.


\subsubsection{Results}

\noindent {\bf Comparison with baseline transformers:} Table \ref{tab:compare_delight_trans} compares the performance of DeLighT ~with the baseline transformers of \citet{vaswani2017attention} on different corpora. DeLighT ~delivers better performance with fewer parameters than transformers, across different corpora. Specifically, on low-resource (WMT'16 En-Ro) and high resource (WMT'14 En-De \& WMT'14 En-Fr) corpora, DeLighT ~delivers similar or better performance with $2.8\times$ and $1.8\times$ fewer parameters, respectively. When the number of parameters are increased, DeLighT ~outperforms transformers. For example, on WMT'14 En-Fr dataset, DeLighT ~is $3.7\times$ deeper than transformers and improves its BLEU score by 1.3 points yet with 13 million fewer parameters and 3 billion fewer operations (see Table \ref{tab:results_depth_macs}).

Particularly interesting are the performance comparisons of DeLighT ~with the baseline transformers of \citet{vaswani2017attention} and its neural search variant, i.e., Evolved Transformer of \citet{so2019evolved}, at two different parametric settings on WMT'14 En-De corpora in Figure \ref{fig:perf_compare_param}. For small models (< 10 M parameters), DeLighT ~models delivers better performance and for attaining the same performance as these models, DeLighT ~models requires fewer parameters. 

\begin{table}[t!]
    \centering
    \begin{subtable}[b]{\columnwidth}
        \centering
    \resizebox{0.88\columnwidth}{!}{
        \begin{tabular}{lcc||cc c cc||cc}
            \toprule[1.5pt]
            \multicolumn{1}{c}{} &  \multicolumn{4}{c}{\textbf{IWSLT'14 De-En}} & \hfill & \multicolumn{4}{c}{\textbf{WMT'16 En-Ro}} \\
            \cmidrule[1.25pt]{2-5} \cmidrule[1.25pt]{7-10}
            \textbf{Model} & \textbf{\# Params} & \textbf{Ratio} & \textbf{BLEU} & $\Delta$ \textbf{BLEU} &\hfill & \textbf{\# Params} & \textbf{Ratio} & \textbf{BLEU} & $\Delta$ \textbf{BLEU} \\
            \midrule
            Transformer \citep{vaswani2017attention} & -- & -- & 34.4$^\dagger$ & -- && 62 M & -- & 34.3$^\ddagger$ & -- \\
            \midrule
            Transformer (Our impl.) & 42 M & $1.0\times$ & 34.3 & -- && 62 M & $1.0\times$ & 34.3 & -- \\
            DeLighT                    & 14 M & $0.3\times$ & 33.8 & -0.5 && 22 M & $0.35\times$ & 34.3 & 0.0 \\
            DeLighT                    & 30 M & $0.7\times$ & \textbf{35.3} & \textbf{+1.0} && 53 M & $0.85\times$ & \textbf{34.7} & \textbf{+0.4} \\
            \bottomrule
        \end{tabular}
    }
    \caption{Results on small corpora}
    \end{subtable}
    \vfill
    \begin{subtable}[b]{\columnwidth}
        \centering
    \resizebox{0.88\columnwidth}{!}{
        \begin{tabular}{lcc||cc p{0.25cm} cc||cc}
            \toprule[1.5pt]
            \multicolumn{1}{c}{} &  \multicolumn{4}{c}{\textbf{WMT'14 En-De}} & \hfill & \multicolumn{4}{c}{\textbf{WMT'14 En-Fr}} \\
            \cmidrule[1.25pt]{2-5} \cmidrule[1.25pt]{7-10}
            \textbf{Model} & \textbf{\# Params} & \textbf{Ratio} & \textbf{BLEU} & $\Delta$ \textbf{BLEU} &\hfill & \textbf{\# Params} & \textbf{Ratio} & \textbf{BLEU} & $\Delta$ \textbf{BLEU} \\
            \midrule
            Transformer \citep{vaswani2017attention} & 62 M & -- & 27.3 & -- && -- & 62 M & 38.1 & -- \\
            \midrule
            Transformer (Our impl.) & 67 M & $1.0\times$ & 27.7 & -- && 67 M & $1.0\times$ & 39.2 & -- \\
            DeLighT                    & 37 M & $0.55\times$ & 27.6 & -0.1 && 37 M & $0.55\times$ & 39.6 & +0.4 \\
            DeLighT                    & 54 M & $0.80\times$ & \textbf{28.0} & \textbf{+0.3} && 54 M & $0.80\times$ & \textbf{40.5} & \textbf{+1.3} \\
            \bottomrule[1.5pt]
        \end{tabular}
    }
    \caption{Results on large corpora}
    \end{subtable}
    \caption{\textbf{Comparison with baseline transformers on machine translation corpora}. DeLighT ~models require significantly fewer parameters to achieve similar performance. Here, $^\dagger$ and $^\ddagger$ indicate the best reported transformer baselines from \citet{wu2018pay} and \citet{ghazvininejad2019mask}, respectively.}
    \label{tab:compare_delight_trans}
\end{table}
%
\begin{figure}[t!]
    \begin{minipage}[b]{0.46\columnwidth}
        \vspace{0pt}
        \centering
        \resizebox{\columnwidth}{!}{
        \begin{tabular}{lrrrr}
            \toprule[1.5pt]
             & \textbf{Depth} & \textbf{\# Params} & \textbf{\# MACs} & \textbf{BLEU}  \\
             \midrule[1.25pt]
            Transformer & 60 & 67 M & 11.1 B & 39.2\\
            DeLighT  & 222 & 37 M  & 5.6 B & 39.6 \\
            DeLighT  & 222 & 54 M & 8.1 B & 40.5 \\
            \bottomrule[1.5pt]
        \end{tabular}
    }
        \captionof{table}{\textbf{DeLighT ~networks are deep, light-weight and efficient} as compared to transformers. BLEU score is reported on the WMT'14 En-Fr dataset. To compute network depth, we count the number of sequential layers in the network (Section \ref{ssec:layer_wise_scaling}). We used 20 source and 20 target tokens for computing multiplication-addition operations (MACs). See Appendex \ref{sec:appendix_mac} for details.}
        \label{tab:results_depth_macs}
    \end{minipage}
    \hfill
    \begin{minipage}[b]{0.5\columnwidth}
        \vspace{0pt}
        \centering
        \includegraphics[height=85px]{graphs/scale_tra_e.pdf}
        \caption{Comparison of DeLighT ~with Transformers and Evolved Transformers at two different settings, on the WMT'14 En-De corpus: (1) the number of parameters is the same and (2) the performance is the same.}
        \label{fig:perf_compare_param}
    \end{minipage}
\end{figure}

\noindent {\bf Comparison with \sota~methods:} Most \sota~methods have evaluated the performance on WMT'14 En-De while some have also evaluated on IWSLT'14 De-En. Table \ref{tab:comapre_nmt_sota} compares the performance of DeLighT ~with \sota~methods on these two corpora. DeLighT ~delivers similar or better performance than existing methods. It is important to note that existing methods have improved baseline transformers with different design choices -- for example, the asymmetric encoder-decoder structure \citep{wang2019learning} and neural architecture search \citep{so2019evolved}. We believe that DeLighT , in the future, would also benefit from such design choices. 

\begin{table}[t!]
    \centering
    \begin{subtable}[b]{0.52\columnwidth}
        \resizebox{0.9\columnwidth}{!}{
        \begin{tabular}{lrr}
            \toprule[1.5pt]
          \textbf{Model} & \textbf{\# Params} & \textbf{BLEU} \\
          \midrule
            Transformers \citep{vaswani2017attention} & 42 M & 34.3 \\
            Variational Attention \citep{deng2018latent} & -- & 33.1 \\
             Dynamic convolutions \citep{vaswani2017attention} & 43 M & \textbf{35.2} \\
             Lite Transformer$^\ddagger$ \citep{Wu2020Lite} & -- & 33.6 \\
             DeLighT ~(Ours) & \textbf{30 M} & \textbf{35.3} \\
            \bottomrule[1.5pt]
        \end{tabular}
        }
        \caption{IWSLT'14 De-En}
    \end{subtable}
    \hfill
    \begin{subtable}[b]{0.47\columnwidth}
        \resizebox{0.9\columnwidth}{!}{
        \begin{tabular}{lrr}
            \toprule[1.5pt]
          \textbf{Model} & \textbf{\# Params} & \textbf{BLEU} \\
          \midrule
            Transformer \citep{vaswani2017attention} & 62 M & 27.3 \\
            DLCL \citep{wang2019learning} & 62 M & 27.3 \\
            Evolved Transformer $^\dagger$ \citep{so2019evolved} & 46 M & \textbf{27.7} \\
            Lite Transformer$^\ddagger$ \citep{Wu2020Lite} & -- & 26.5 \\
            DeLighT ~(Ours) & \textbf{37 M} & \textbf{27.6} \\
            \bottomrule[1.5pt]
        \end{tabular}
        }
        \caption{WMT'14 En-De}
    \end{subtable}
    \caption{\textbf{Comparison with \sota~methods on machine translation corpora}. DeLighT ~delivers similar or better performance than \sota~models with fewer parameters. Here, $\dagger$ indicates that the network uses neural architecture search (NAS) and $\ddagger$ indicates that full network parameters are not reported. }
    \label{tab:comapre_nmt_sota}
\end{table}

\noindent {\bf Scaling up DeLighT ~models:} Figure \ref{fig:nmt_perf_curve} shows the performance of DeLighT ~models improves with increase in network parameters; suggesting their ability to learn representations across different corpora, including low-resource.

\begin{figure}[t!]
    \centering
    \begin{subfigure}[b]{0.24\columnwidth}
        \centering
        \includegraphics[width=\columnwidth]{graphs/delight_nmt_de2en.pdf}
        \caption{IWSLT'14 De-En}
    \end{subfigure}
    \hfill
    \begin{subfigure}[b]{0.24\columnwidth}
        \centering
        \includegraphics[width=\columnwidth]{graphs/delight_nmt_en2ro.pdf}
        \caption{WMT'16 En-Ro}
    \end{subfigure}
    \hfill
    \begin{subfigure}[b]{0.24\columnwidth}
        \centering
        \includegraphics[width=\columnwidth]{graphs/delight_nmt_en2de.pdf}
        \caption{WMT'14 En-De}
    \end{subfigure}
    \hfill
    \begin{subfigure}[b]{0.24\columnwidth}
        \centering
        \includegraphics[width=\columnwidth]{graphs/delight_nmt_en2fr.pdf}
        \caption{WMT'14 En-Fr}
    \end{subfigure}
    \caption{\textbf{Scaling up DeLighT ~models.} The performance of DeLighT ~improves with an increase in the number of network parameters, across different corpora, including low-resource (WMT'16 En-Ro).}
    \label{fig:nmt_perf_curve}
\end{figure}

\subsection{Language Modeling}
\label{ssec:language_mdoeling}

\noindent {\bf Datasets and evaluation:} We evaluate on the WikiText-103 dataset \citep{merity2017pointer} that has 103M/217K/245K tokens for training, validation, and testing. It has a word-level vocabulary of about 260K tokens. Following recent works \citep{baevski2018adaptive,dai2019transformer}, we report performance in terms of \textit{perplexity} (lower is better) on the test set.

\noindent {\bf Architecture:} We use the transformer-based decoder architecture of \citet{baevski2018adaptive} with $\mathcal{B}$ DeLighT ~blocks. We use $w_m$=$2$, $N_{min}$=$4$, and $N_{max}$=$12$. We scale $d_m$ using values $\{384, 512, 784, 1024\}$ for increasing network parameters. For simplicity, we set $\mathcal{B}=N_{max}$. Following standard practice, we use adaptive input \citep{baevski2018adaptive} as a look-up table and adaptive output \citep{grave2017efficient} as the classification layer with one head (head dimension is 128) and two tails (tail dimensions are 64 and 32). We also share weights between the input and the output layers.

\vspace{0.5mm}
\noindent {\bf Training:} We follow the training setup of \citet{baevski2018adaptive}, except that we train our models on 8 NVIDIA Tesla V100 GPUs for 100K iterations with a context length of 512 and an effective batch size of 64K tokens. We use Adam during training and use a context length of 480 during test.

\noindent {\bf Results:} Table \ref{tab:wiki_sota} compares the performance of DeLighT ~with previous methods on WikiText-103. Table \ref{tab:wiki_txl} plots the variation of perplexity with number of parameters for DeLighT ~and Transformer-XL \citep{dai2019transformer} -- which outperforms other transformer-based implementations (e.g., \citealt{baevski2018adaptive}). Both tables show that DeLighT ~delivers better performance than \sota~methods (including Transformer-XL) and it does this using a smaller context length and significantly fewer parameters, suggesting that the DeLighT transformation ~helps learn strong contextual relationships.

%\noindent {\bf Ablations:} We also did an extensive set of ablation studies to better understand which parts of the architecture contribute the most to improve performance and we include these in the Appendix~\ref{sec:appendix_ablations}. We varied different hyper-parameters including minimum $N_{min}$ and maximum $N_{max}$ number of GLTs, width multiplier $w_m$, and model dimension $d_m$. Overall, the differing settings either hurt performance or increase the parameter count with no further performance gains. 

\begin{table}[t!]
    \centering
    \begin{subtable}[b]{0.33\columnwidth}
        \centering
        \includegraphics[width=0.8\columnwidth]{images/wiki_103.pdf}
        \caption{DeLighT ~vs. Transformer-XL}
        \label{tab:wiki_txl}
    \end{subtable}
    \hfill
    \begin{subtable}[b]{0.65\columnwidth}
        \centering
        \resizebox{\columnwidth}{!}{
        \begin{tabular}{lcccc}
            \toprule[1.5pt]
           \multirow{2}{*}{\textbf{Method}} & \textbf{Network} & \textbf{Context}  & \textbf{\# Params} & \textbf{Perplexity} \\
            & \textbf{Depth} & \textbf{Length}  & \textbf{ (in million)} & \textbf{(Test)} \\
           \midrule[1pt]
            LSTM \citep{grave2016improving} &--& -- & -- & 48.70 \\
            LSTM + Neural Cache \citep{grave2016improving} &--&-- & --& 40.80 \\
            QRNN \citep{merity2018analysis} &--& -- & 151 M & 33.00 \\
            \midrule
            Transformer-XL \citep{dai2019transformer} & 64 & 640 & 151 M & \textbf{24.03} \\
            Transformer-XL (Our impl.)$^\dagger$  & 64 & 640 & 151 M & 24.34 \\
            Transformer-XL (Our impl.)$^\dagger$  & 64 & 480 & 151 M & 24.91 \\
            DeLighT ~(Ours) & 158 & \textbf{480} & \textbf{99 M} & \textbf{24.14} \\
            \bottomrule[1.5pt]
        \end{tabular}
        }
        \caption{Comparison with existing methods}
        \label{tab:wiki_sota}
    \end{subtable}
    \caption{\textbf{Results on the WikiText-103 dataset}. Compared to Transformer-XL, DeLighT ~delivers similar or better performance (lower perplexity) with fewer parameters. $^\dagger$For Transformer-XL, we reproduce results using the official source code. For evaluating Transformer-XL with a context length of 480, we set the mem\_len hyper-parameter to 480 in the official evaluation scripts.}%\protect\footnotemark }}
    \label{tab:wiki103_results}
\end{table}

\begin{table}[t!]
    \centering
    \resizebox{0.75\columnwidth}{!}{
    \begin{tabular}{llcccc}
        \toprule[1.5pt]
        \multirow{2}{*}{\textbf{Row \#}} & \multirow{2}{*}{\textbf{Model}} & \textbf{\# Params} & \textbf{BLEU} & \textbf{Training} & \textbf{Memory} \\
         &  & \textbf{(in million)} & \textbf{(WMT'14 En-Fr)} & \textbf{time} & \textbf{(in GB)} \\
        \midrule[1pt]
        R1 & Transformer (unoptimized) & 67 M & 39.2 & 37 hours & 12.5 GB \\
        R2 & DeLighT ~(unoptimized) & 54 M & 40.5 & 23 hours & 14.5 GB \\
        R3 & Transformer (w/ Apex optimized) & 67 M & 39.2 & 16 hours & 11.9 GB \\
        R4 & DeLighT ~(w/ optimized grouping) & 54 M & 40.5 & 19 hours & 11.5 GB \\
        \bottomrule[1.5pt]
    \end{tabular}
    }
    \caption{Comparison with baseline transformers in terms of training speed and memory consumption. In R4, we implemented CUDA kernels for grouping and ungrouping functions only (see Appendix \ref{sec:append_source}). We expect DeLighT ~to be more efficient with a single and dedicated CUDA kernel for grouping, transformation, feature shuffling, and ungrouping. Memory consumption is measured on a single NVIDIA GP100 GPU (16 GB memory) with a maximum of 4096 tokens per batch and without any gradient accumulation.}
    \label{tab:compute_compare}
\end{table}

\begin{table}[t!]
    \centering
    \resizebox{0.35\columnwidth}{!}{
        \begin{tabular}{lcc}
            \toprule[1.5pt]
           \textbf{Model}  & \textbf{Dropout} & \textbf{BLEU} \\
           \midrule[1pt]
            Transformer (62 M) & 0.10 & 27.3 \\
            Transformer (62 M) & 0.30 & 27.7 \\
            DeLighT ~(37 M) & 0.05 & 27.6 \\
            \toprule[1.5pt]
        \end{tabular}
    }
    \caption{DeLighT ~requires less regularization as compared to baseline transformers (Dataset: WMT'14 En-De).}
    \label{tab:dropout_effect}
\end{table}

\section{Analysis and Discussions on Computational Efficiency}

\noindent \textbf{Training time and memory consumption:} Table \ref{tab:compute_compare} compares the training time and memory consumption of DeLighT ~with baseline transformers. For an apples-to-apples comparisons, we implemented the Transformer unit without NVIDIA's dedicated CUDA kernel, and trained both transformer and DeLighT ~full-precision networks for 30K iterations on 16 NVIDIA V100 GPUs. The transformer and DeLighT ~models took about 37 and 23 hours for training and consumed about 12.5 GB and 14.5 GB of GPU memory, respectively (R1 vs. R2). When we enabled the dedicated CUDA kernel provided by APEX library\footnote{https://github.com/NVIDIA/apex} for multi-head attention in Transformers, the training time of the transformer model reduced from 37 to 16 hours while we did not observe any significant change in memory consumption. Motivated by this observation, we implemented dedicated CUDA kernels for grouping and ungrouping functions in GLTs (see Appendix \ref{sec:append_source}). With these changes, training time and GPU memory consumption of DeLighT ~reduced by about 4 hours and 3 GB, respectively. We emphasize that grouping, linear transformation, feature shuffling, and ungrouping, can be implemented efficiently using a single CUDA kernel. In future, we expect a dedicated CUDA kernel for these operations would further reduce the memory consumption as well as training/inference time.

\vspace{0.5mm}
\noindent \textbf{Regularization:} Table \ref{tab:dropout_effect} shows that DeLighT ~delivers similar performance to  baseline transformers, but with fewer parameters and less regularization. This suggests that learning representations with better transformation functions alleviates the need for dropout.

\section{Conclusion}
This paper introduces a deep and light-weight transformer architecture, DeLighT , that efficiently allocates parameters both within the DeLighT ~block and across DeLighT ~blocks. Compared to state-of-the-art transformer models, DeLighT ~models are (1) deep and light-weight and (2) deliver similar or better performance. In the future, we plan to apply DeLighT ~to other tasks, including language model pre-training, question answering, and language generation.

\vspace{0.5mm}
\noindent \textbf{Acknowledgements:} This research was supported by ONR N00014-18-1-2826, DARPA N66001-19-2-403, NSF (IIS-1616112, IIS1252835), and an Allen Distinguished Investigator Award. Authors would also like to thank members of the UW-NLP and the H2Lab at The University of Washington for their valuable feedback and comments.

\small{
\bibliographystyle{unsrtnat}
\bibliography{main}
}

\clearpage

\appendix

\section{DeLighT ~Architectures for Language Modeling and Machine Translation}
\label{sec:appendix_enc_dec_arch}
DeLighT ~architectures for language modeling and machine translation are shown in Figure \ref{fig:appendix_arch}. For language modeling, we follow the architecture in \citet{baevski2018adaptive} while for machine translation, we follow the architecture in \citet{vaswani2017attention}. 

\begin{figure}[b!]
    \centering
    \begin{subfigure}[b]{0.38\columnwidth}
        \centering
        \resizebox{\columnwidth}{!}{
            \input{tikz/enc_dec.tikz}\decattn
        }
        \caption{Language Modeling}
        \label{fig:appendix_arch_lm}
    \end{subfigure}
    \hfill
    \begin{subfigure}[b]{0.6\columnwidth}
         \centering
        \resizebox{\columnwidth}{!}{
            \input{tikz/enc_dec.tikz}\encdecattn
        }
        \caption{Machine translation}
        \label{fig:appendix_arch_enc_dec}
    \end{subfigure}
    \caption{Sequence modeling with DeLighT . Here, \colorbox{green}{green color hexagon} represents the DeLighT transformation .}
    \label{fig:appendix_arch}
\end{figure}

\vspace{1mm}
\noindent {\bf Language modeling:} Figure \ref{fig:appendix_arch_lm} shows the architecture for language modeling. The architecture stacks $\mathcal{B}$ DeLighT ~blocks, the configuration of each block is determined using block-wise scaling. Each block has three sub-layers. The first layer is a DeLighT transformation ~that learns representations in high-dimensional space. The second layer is a single-head attention that encodes contextual relationships. The third layer is a position-wise light-weight feed-forward network. Similar to  \citet{vaswani2017attention}, we employ a residual connections \citep{he2016deep}. Similar to previous works \citep{baevski2018adaptive,dai2019transformer}, we use tied adaptive input \citep{baevski2018adaptive} and adaptive softmax \citep{grave2017efficient} to map tokens to vectors and vectors to tokens, respectively.

\vspace{1mm}
\noindent {\bf Machine translation:} Figure \ref{fig:appendix_arch_enc_dec} shows the architecture for machine translation. The encoder stacks $\mathcal{B}$ DeLighT ~blocks, the configuration of each block is determined using block-wise scaling. Similar to language modeling, each encoder block has three sub-layers. The first layer is a DeLighT transformation ~that learns representations in high-dimensional space. The second layer is a single-head attention that encodes contextual relationships. The third layer is a position-wise light-weight feed-forward network. Similar to \citet{vaswani2017attention}, we employ a residual connections \citep{he2016deep}. We use learnable look-up table to map tokens to vectors. Similar to the encoder, the decoder also stacks  $\mathcal{B}$ blocks. Decoder blocks are identical to encoder blocks, except that they have an additional source-target single-head attention unit before the light-weight FFN. Keys and values in source-target single-head attention unit are projections over the encoder output. We use standard learnable look-up table to map tokens to vectors and linear classification layer to map vectors to tokens. 

\section{Group linear transformation with Input-mixer connection}
\label{sec:glt_explain}
Group linear transformation (GLT) $\mathcal{F}$ splits a $d_m$-dimensional input $\mathbf{X}$ into $g$ non-overlapping groups such that $\mathbf{X} = \text{Concat}(\mathbf{X}_1, \cdots, \mathbf{X}_g)$, where $\mathbf{X}_i$ is a $\frac{d_m}{g}$-dimensional vector. $\mathbf{X}_i$'s are then simultaneously transformed using $g$ linear transforms $\mathbf{W}_i \in \mathbf{R}^{\frac{d_m}{g} \times \frac{d_o}{g}}$ to produce $g$ outputs $\mathbf{Y}_i = \mathbf{X}_i \mathbf{W}_i$. $\mathbf{Y}_i$'s are then concatenated to produce the final $d_o$-dimensional output $\mathbf{Y} = \text{Concat}(\mathbf{Y}_1, \cdots, \mathbf{Y}_g)$. 

Figure \ref{fig:glt_app} shows an example of GLT in the expansion phase of DeLighT transformation . For illustrative purposes, we have used the same dimensions in this example. Recall that as we go deeper in the expansion phase, the number of groups increases. In this example, the first layer has one group, the second layer has two groups and the third layer has four groups. GLTs learns group-specific representations and are local.  To allow GLT to learn global representations, we use feature shuffle. An example of GLT with feature shuffle is shown in Figure \ref{fig:glt_shuff_app}. Furthermore, training deep neural networks by merely stacking linear or group linear (with or without feature shuffle) is challenging because of vanishing gradient problem. Residual connections introduced by \citet{he2016deep} mitigates this problem and helps train deep neural networks. However, such connections cannot be employed when input and output dimensions are not the same (e.g., during the expansion and reduction phases in DeLighT transformation ). To stabilize the training and learn deeper representations, we use input-mixer connection of \citet{mehta2020DeFINE}. Figure \ref{fig:glt_shuff_mix_app} shows an example of GLT with feature shuffle and input mixer connection.

\begin{figure}[h!]
    \centering
    \begin{subfigure}[b]{0.3\columnwidth}
    \includegraphics[height=200px]{glt_images/glt.pdf}
    \caption{GLT}
    \label{fig:glt_app}
    \end{subfigure}
    \hfill
    \begin{subfigure}[b]{0.3\columnwidth}
        \includegraphics[height=200px]{glt_images/glt_shuffle.pdf}
        \caption{GLT with feature shuffle}
        \label{fig:glt_shuff_app}
    \end{subfigure}
    \hfill
    \begin{subfigure}[b]{0.33\columnwidth}
        \includegraphics[width=\columnwidth]{glt_images/glt_shuffle_inp.pdf}
        \caption{GLT with feature shuffle and input mixture connection}
        \label{fig:glt_shuff_mix_app}
    \end{subfigure}
    \caption{This figure visualizes different variants of group linear transformations that are used in the DeLighT transformation .}
    \label{fig:glt_vis}
\end{figure}

\section{Multiplication-Addition Operations in DeLighT }
\label{sec:appendix_mac}
The DeLighT ~block is built using linear transformations, GLTs, and scaled dot-product attention. Total number of multiplication-addition operations (MACs) in a network is an accumulation of these individual operations. 

Let $n$ denotes the number of source tokens, $m$ denotes the number of target tokens, $d_m$ denotes the input dimension, $d_o$ denotes the output dimension, and $g$ denotes the number of groups in GLT. The procedure for counting MACs for each of these operations is described below. 

\paragraph{Group linear transformation (GLT):} GLT $\mathcal{F}$ has $g$ learnable matrices $\mathbf{W}_i \in \mathbf{R}^{\frac{d_m}{g} \times \frac{d_o}{g}}$. Therefore, GLT learns \colorbox{red!20}{$\frac{d_md_o}{g}$} parameters and performs \colorbox{red!20}{$\frac{d_md_o}{g}$} MACs to transform $d_m$-dimensional input to $d_o$-dimensional output. Following a standard practice, e.g., ResNet of \citet{he2016deep}, we count addition and multiplication as one operation instead of two because these operations can be fused in recent hardwares.

Importantly, when $g=1$, the GLT is the same as linear transformation.

\paragraph{Self-attention in DeLighT :} The scaled dot-product self-attention in DeLighT ~is defined as:
\begin{equation}
    \text{Attention}(\mathbf{K}, \mathbf{Q}, \mathbf{V}) = \text{softmax}\left(\frac{\mathbf{Q}\mathbf{K}^T}{\sqrt{d_o}}\right) \mathbf{V}
\end{equation}
where $\mathbf{Q} \in \mathbb{R}^{n \times d_o}$, $\mathbf{K} \in \mathbb{R}^{n \times d_o}$, $\mathbf{V} \in \mathbb{R}^{n \times d_o}$ denotes query, key, and value, respectively.

The attention operation involves two dot-products. The first dot product between $\mathbf{Q}$ and $\mathbf{K}$ while the second dot product is between the output of first dot product and $\mathbf{V}$. Both dot products require $d_on^2$ MACs. Therefore, total number of MACs in computing scaled dot-product self-attention are \colorbox{red!20}{$2d_on^2$}.

In case of a source-target attention (as in machine translation), $\mathbf{K}$'s and $\mathbf{V}$'s are from the source (encoder) and $\mathbf{Q}$'s are incrementally decoded (one token at a time). Therefore, the number of MACs required to decode $m$ target tokens given $n$ source tokens are \colorbox{red!20}{$\sum\limits_{k=1}^{m} 2knd_o$}.

\section{Ablations on the WikiText-103 dataset}
\label{sec:appendix_ablations}
Table \ref{tab:scaling_ablte} studies the impact of DeLighT ~block parameters on the WikiText-103 dataset, namely (1) minimum number of GLTs $N_{min}$, (2) maximum number of GLTs $N_{max}$, (3) width multiplier $w_m$, and (4) model dimension $d_m$ (see Figure \ref{fig:redefine_transformer_sa}). Figure~\ref{fig:dextra_define}, Figure~\ref{fig:shuffling}, and Figure~\ref{fig:reduction_fac} shows the impact of the DeLighT transformation , feature shuffling, and the light-weight FFN. Table \ref{tab:dextra_position} shows the effect of position of DeLighT transformation ~in the DeLighT ~block while Figure \ref{fig:appendix_delight_scaling} shows the effect of scaling DeLighT ~networks. We choose the WikiText-103 dataset for ablations because it has very large vocabulary compared to other datasets (267K vs. 30-40K), allowing us to test the ability under large vocabulary sizes. The performance is reported in terms of perplexity (lower is better) on the validation set. In our ablation studies, we used the same settings for training as in Section \ref{ssec:language_mdoeling} except that we train only for 50K iterations.

\noindent{\bf DeLighT block:} Overall, Table~\ref{tab:scaling_ablte} shows that scaling depth and width using DeLighT transformation ~and block-wise scaling improves performance. We make following observations: 
\vspace{-1mm}
\begin{enumerate}[leftmargin=*, label=\alph*)]
\setlength\itemsep{0em}
\item Block-wise scaling (R4, R5) delivers better performance compared to uniform scaling (R1-R3). For instance, DeLighT ~with $N_{min}=4$ and $N_{max}=8$ (R4) is $1.25\times$ shallower than DeLighT ~with $N_{min}=8$ and $N_{max}=8$ (R2), but delivers better performance with a similar  number of parameters and operations. Scaling $w_m$ improves performance (R2 vs. R3), however, the improvement is significantly lower than for the model with block-wise scaling (R3 vs. R5). This suggests that non-uniform distribution of parameters across blocks allows the network to learn better representations.  

\item Different ratios between $N_{max}$ and $N_{min}$ yields different results. We observe significant performance improvements when the ratio is greater than or equal to two. For example, when we scale $\frac{N_{max}}{N_{min}}$ from 2 to 3 (R6 vs. R8), the perplexity improves by ${\sim}5$ points with only a moderate increase in network parameters. On the other hand, when the $\frac{N_{max}}{N_{min}}$ is close to 1 (R6 vs. R7), performance does not change appreciably. This is likely because the allocation of parameters across blocks is close to uniform (Eq. \ref{eq:mw}). This is consistent with our previous observation. 

\item Learning shallower and narrower representations near the input and deeper and wider representations near the output achieves better performance. For example, when we scaled $N_{max}$ from 8 to 12 for $N_{min}=4$ (R6, R8), DeLighT ~delivered better performance with a similar number of parameters compared to a model with $N_{min}=6$ (R7, R9). This is likely because the ratio of $N_{max}$ and $N_{min}$ is higher when $N_{min}=4$, which helps allocate parameters per block more effectively. 
\item Deeper and wider representations near the input and shallower and narrower representations near the output hurts performance (R13 vs. R16). 
\item Scaling width using $w_m$ and $d_m$ improves performance (R10-R15), however, their impact is different. For example, when we scale $w_m$ and $d_m$ by two, the rate of increase in number of parameters and operations is more rapid with  $d_m$ compared to $w_m$. DeLighT 's~ability to learn wider representations in different ways may be useful in selecting application specific models.
\end{enumerate}

\begin{table}[t!]
    \centering
        \resizebox{0.8\columnwidth}{!}{
            \begin{tabular}{l|cccc|cccc}
              \toprule[1.5pt]
              \rowcolor{white}
              \textbf{Row \#} & $N_{min}$  & $N_{max}$ & $w_m$ & $d_m$ & \textbf{Depth} & \textbf{Parameters}  & \textbf{MACs} & \textbf{Perplexity} \\
              \toprule[1.25pt]
              \multicolumn{9}{c}{\textbf{Uniform vs. block-wise scaling}} \\
              \midrule
                R1 & 4 & 4 & 2 & 256 & 43 & 14.1 M & 2.96 B  & 56.19 \\
                R2 & 8 & 8 & 2 & 256 & 115 & 16.6 M & 3.49 B & 48.58 \\
                R3 & 8 & 8 & 4 & 256 & 115 & 22.1 M & 4.64 B & 45.10 \\
                \cmidrule[0.25pt]{2-9}
                R4 & 4 & 8 & 2 & 256 & 92 & 16.7 M & 3.51 B & 46.30 \\
                R5 & \cellcolor{red!25} 4 & \cellcolor{red!25} 12 & \cellcolor{red!25} 2 & \cellcolor{red!25} 256 & 158 & 21.0 M & 4.41 B & 41.18 \\
              \toprule[1pt]
              \multicolumn{9}{c}{\textbf{Varying depth ($N_{min}$ and $N_{max}$ (Eq. \ref{eq:mw})}} \\
              \midrule
                R6 & 4 & 8 & 2 & 256 & 92 & 16.7 M & 3.51 B & 46.30 \\
                R7 & 6 & 8 & 2 & 256 & 102 & 16.5 M & 3.46 B & 46.68 \\
                R8 & \cellcolor{red!25} 4 & \cellcolor{red!25} 12 & \cellcolor{red!25} 2 & \cellcolor{red!25} 256 & 158 & 21.0 M & 4.41 B & 41.18 \\
                R9 & 6 & 12 & 2 & 256 & 172 & 20.0 M & 4.20 B & 42.26  \\
              \toprule[1pt]
              \multicolumn{9}{c}{\textbf{Varying DeLighT transformation 's width $w_m$ (Eq. \ref{eq:mw})}} \\
              \midrule
                R10 & \cellcolor{red!25} 4 & \cellcolor{red!25} 12 & \cellcolor{red!25} 2 & \cellcolor{red!25} 256 & 158 & 21.0 M & 4.41 B & 41.18 \\
                R11 & 4 & 12 & 3 & 256 & 158 & 23.8 M & 4.99 B & 39.92  \\
                R12 & 4 & 12 & 4 & 256 & 158 & 27.1 M & 5.69 B & 39.10 \\
              \toprule[1pt]
              \multicolumn{9}{c}{\textbf{Varying model width $d_m$}} \\
              \midrule 
                R13 & \cellcolor{red!25} 4 & \cellcolor{red!25} 12 & \cellcolor{red!25} 2 & \cellcolor{red!25} 256 & 158 &  21.0 M & 4.41 B & 41.18 \\
                R14 & 4 & 12 & 2 & 384 & 158 & 29.9 M & 6.28 B & 35.14 \\
                R15 & 4 & 12 & 2 & 512 & 158 & 43.8 M & 9.20 B & 30.81 \\
              \toprule[1pt]
              \multicolumn{9}{c}{\textbf{Deeper and wider near the Input}} \\
              \midrule 
               R16 & 12 &  4 & 2 &  256 & 158 &  21.0 M & 4.41 B & 43.10 \\
            \bottomrule[1.5pt]
            \end{tabular}
        }
    \caption{\textbf{Ablations on different aspects of the DeLighT ~block}, including uniform vs. block-wise scaling, depth scaling, and width scaling. Rows partially highlighted in color have the same configuration (repeated for illustrating results). Our experimental setup is similar to Section \ref{sec:results}, except that we train our models for 50K iterations. Multiplication and addition operations (MACs) are computed for 20 time steps. }
    \label{tab:scaling_ablte}
\end{table}

\vspace{1mm}
\noindent{\bf Impact of DeLighT transformation :} We replace DeLighT transformation ~in the DeLighT ~block (Figure \ref{fig:redefine_transformer_sa}) with (1) the DeFINE transformation and (2) a stack of linear layers. Figure \ref{fig:dextra_define} shows that DeLighT transformation ~delivers similar performance with significantly fewer parameters compared to the DeFINE unit and linear layers. In these experiments, the settings are the same as R13-R15 (Table \ref{tab:scaling_ablte}), except, $N_{max}=8$, because models with a stack of linear layers learn too many parameters.

\begin{figure}[b!]
    \centering
    \begin{minipage}{0.45\columnwidth}
        \includegraphics[width=0.9\columnwidth]{images/define_dextra.pdf}
        \caption{\textbf{Impact of different transformations.} DeLighT ~transformations are more parametric efficient than DeFINE and linear transformations. Lower perplexity value means better performance.}
    \label{fig:dextra_define}
    \end{minipage}
    \hfill
    \begin{minipage}{0.45\columnwidth}
        \centering
        \includegraphics[width=0.9\columnwidth]{images/shuffle.pdf}
        \caption{\textbf{Impact of feature shuffling.} Feature shuffling allows us to learn representations from global information and improves performance. Lower perplexity value means better performance.}
        \label{fig:shuffling}
    \end{minipage}
\end{figure}

\vspace{1mm}
\noindent{\bf Feature shuffling:} Figure \ref{fig:shuffling} shows that feature shuffling improves the performance of DeLighT ~by 1-2 perplexity points. Here, we use the same settings as in R13-R15 (Table \ref{tab:scaling_ablte}).

\vspace{1mm}
\noindent{\bf Light-weight FFN:} Figure \ref{fig:reduction_fac} shows the impact of varying the reduction factor $r$ in the light-weight FFN. We use the same settings as in R13 (Table \ref{tab:scaling_ablte}). We did not observe any significant drop in performance until $r=4$. Beyond $r=4$, we see a drop in performance (perplexity increases by ${\sim}2$ points). In such cases, the inner dimensions of the light-weight FFN are very small and hurt performance. Notably, the light-weight FFN with $r=2^2$ delivered the same performance as $r=2^{-2}$, but with $1.28\times$ fewer network parameters. At $r=2^{-2}$, the light-weight FFN is the same as the FFN in \cite{vaswani2017attention}. This suggests that the ability of DeLighT transformation ~to learn representations in high-dimensional spaces efficiently allows us to reduce the computational burden on the FFN. 

We also tested removing the light-weight FFN and while it reduced parameters by $\sim$0.5-1 M, performance dropped by about 2-3 perplexity points across different parametric settings.

\begin{figure}[t!]
    \centering
    \includegraphics[width=0.45\columnwidth]{images/reduction.pdf}
    \caption{\textbf{Impact of reduction factor $r$ in light-weight FFN.} The ability of DeLighT transformation ~to learn representations in high-dimensional spaces efficiently allows us to reduce the computational burden on the FFN. Lower perplexity value means better performance.}
    \label{fig:reduction_fac}
\end{figure}

\vspace{1mm}
\noindent{\bf Uniform vs. block-wise scaling:} Figure \ref{fig:appendix_block_unifrom} compares the performance of DeLighT ~with uniform and block-wise scaling. For a given model dimension $d_m$, DeLighT ~models with block-wise scaling delivers better performance.

\begin{figure}[t!]
    \centering
    \begin{subfigure}[b]{0.5\columnwidth}
        \centering
        \resizebox{!}{120px}{
            \input{tikz/scaling_new.tikz}\scaling
        }
        \caption{}
    \end{subfigure}
    \hfill
    \begin{subfigure}[b]{0.48\columnwidth}
        \includegraphics[width=\columnwidth]{images/layer_scaling.pdf}
        \caption{}
    \end{subfigure}
    \caption{\textbf{Uniform vs. block-wise scaling.} (a) contrasts the uniform and block-wise scaling methods. (b) compares the results of DeLighT ~with uniform and block-wise scaling methods on the WikiText-103 dataset. DeLighT ~networks with block-wise scaling delivers better performance across different settings. Lower perplexity value means better performance.}
    \label{fig:appendix_block_unifrom}
\end{figure}

\paragraph{Position of DeLighT transformation :}
%\label{ssec:ablate_position}
We studied three configurations for the DeLighT transformation ~on the WikiText-103 validation set (Table \ref{tab:dextra_position}): (1) DeLighT transformation ~followed by single-headed attention and light-weight FFN, (2) single-headed attention followed by DeLighT transformation , and (3) single-headed attention followed by DeLighT transformation ~and light-weight FFN. For similar number of parameters, we found that (2) and (3) drops the performance of (1) significantly across different parametric settings. This suggests that deeper and wider representations helps learn better contextual representations; allowing us to replace multi-headed attention with single-headed attention.

\begin{table}[t!]
    \centering
    \resizebox{0.9\columnwidth}{!}{
    \begin{tabular}{lrr}
        \toprule[1.5pt]
        \textbf{Configuration}  & \textbf{Parameters} & \textbf{Perplexity} \\
        \midrule[1pt]
        DeLighT transformation  + Single-head attention + Light-weight FFN & 31 M & \textbf{34.20} \\ 
        Single-head attention + DeLighT transformation  & 30 M & 39.02 \\ 
        Single-head attention + DeLighT transformation  + Light-weight FFN & 31 M & 39.43 \\ 
        \midrule
        DeLighT transformation  + Single-head attention + Light-weight FFN & 99 M & \textbf{23.16} \\ 
        Single-head attention + DeLighT transformation  & 96 M & 28.33 \\ 
        Single-head attention + DeLighT transformation  + Light-weight FFN & 99 M & 27.94 \\
        \bottomrule[1.5pt]
    \end{tabular}
    }
    \caption{\textbf{Effect of the position of DeLighT transformation }. Lower value of perplexity means better performance.}
    \label{tab:dextra_position}
\end{table}

\vspace{1mm}
\noindent{\bf Scaling up DeLighT :} Figure \ref{fig:appendix_delight_scaling} shows the results of DeLighT ~models obtained after varying configuration parameters of DeLighT ~transformations ($N_{min}$=\{4, 6\}, $N_{max}$=\{8, 12\}, $w_m$=\{2, 3, 4\}, and $d_m$=\{256, 384, 512\}). We can see that scaling one configuration parameter (e.g., $d_m$) while keeping other configuration parameters constant (e.g., $N_{min}$, $N_{max}$, and $w_m$) consistently improves performance.

This work investigates relationships between $N_{min}$, $N_{max}$, $w_m$, and $d_m$, manually. We believe that a more principled approach, such as compound scaling of \citet{tan2019efficientnet}, that establishes relationships between these parameters would produce more efficient and accurate models. %We will explore such methods in the future.

\begin{figure}[t!]
    \centering
        \begin{subfigure}[b]{0.49\columnwidth}
            \centering
            \includegraphics[width=0.9\columnwidth]{images/plot_4_8.pdf}
            \caption{$N_{min}$=4, $N_{max}$=8}
            \label{fig:arch_4_8}
        \end{subfigure}
        \hfill
         \begin{subfigure}[b]{0.49\columnwidth}
            \centering
            \includegraphics[width=0.9\columnwidth]{images/plot_6_8.pdf}
            \caption{$N_{min}$=6, $N_{max}$=8}
            \label{fig:arch_6_8}
        \end{subfigure}
        \vfill
         \begin{subfigure}[b]{0.49\columnwidth}
            \centering
            \includegraphics[width=0.9\columnwidth]{images/plot_4_12.pdf}
            \caption{$N_{min}$=4, $N_{max}$=12}
            \label{fig:arch_4_12}
        \end{subfigure}
        \hfill
         \begin{subfigure}[b]{0.49\columnwidth}
            \centering
            \includegraphics[width=0.9\columnwidth]{images/plot_6_12.pdf}
            \caption{$N_{min}$=6, $N_{max}$=12}
            \label{fig:arch_6_12}
        \end{subfigure}
        \caption{\textbf{Scaling up DeLighT }. Scaling one configuration parameter (e.g., $d_m$) while keeping other configuration parameters constant (e.g., $N_{min}$, $N_{max}$, and $w_m$) consistently improves performance. The numbers on top of each bar represents network parameters (in million). Lower value of perplexity means better performance.}
        \label{fig:appendix_delight_scaling}
\end{figure}

\section{Source code for group linear transformation}
\label{sec:append_source}
The source code for implementing group linear transformation (GLT) in PyTorch is shown in Listing \ref{lst:navie_glt}. The source code for efficiently implementing the grouping function in GLT is shown in Listing \ref{lst:group_kernel}. Since the ungrouping kernel is similar to grouping kernel, we have not shown it here.

The reshape and transpose operations in naive PyTorch implementation for grouping and ungrouping are replaced with a dedicated CUDA kernels, resulting in reduced memory footprint and faster training.

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{frame=H,
  language=Python,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3
}


\begin{minipage}{\columnwidth}
\begin{lstlisting}[caption="Naive implementation of GLT in Pytorch", label={lst:navie_glt}]
import torch
def glt_function(x, n_groups, weights, bias=None):
    '''
    :param x: Input tensor of size [B x N], where B is batch size and N is input dimension
    :param n_groups: number of groups in GLT
    :param weights: glt weights [g x N/g x M/g]
    :param bias: GLT bias (optional) of size [g x 1 x M/g]
    :return: output tensor of size [B x M]
    '''
    bsz = x.size(0)
    
    ## GROUPING FUNCTION: Converts [B x N] tensor to [g x B  x N/g] ##
    # [B x N] --> [B x g  x N/g]
    x = x.contiguous().view(bsz, n_groups, -1)
    # [B x g x N/g] --> [g x B  x N/g]
    x = x.transpose(0, 1)  # transpose so that group is first

    ## TRANSFORMATION FUNCTION: Transforms from N/g-dimensional space to M/g-dimensional space ##
    # [g x B  x N/g] x [g x N/g x M/g] --> [g x B x M/g]
    x = torch.bmm(x, weights)  # multiply with Weights
    # add bias
    if bias is not None:
        x = torch.add(x, bias)
        
    ## REGROUPING FUNCTION: Converts [g x B x M/g] tensor to [B x M] ##
    # [g x B x M/g] --> [B x g x M/g]
    x = x.transpose(0, 1)  # transpose so that batch is first
    # [B x g x M/g] --> [B x M]
    x = x.contiguous().view(bsz, -1)
    return x
\end{lstlisting}
\end{minipage}


\lstset{language=C++}
\begin{minipage}{\columnwidth}
\begin{lstlisting}[caption="Grouping kernel in CUDA", label={lst:group_kernel}]

/* Grouping Kernel: Transforms input from [B x N] to [g x B x N/g] */
template<typename scalar_t>
__global__ void grouping_kernel_forward(const scalar_t* input,
                            const int groups, const int total_elements,
                            const int input_features, const int group_features,
                            const int batch_size, scalar_t* output){
    const int index = IMUL(blockIdx.x, blockDim.x) + threadIdx.x;
    if (index >= total_elements){
        return;
    }
    const int b_idx = index / group_features;
    const int g_f_idx = (index % group_features);
    int in_offset, out_offset;
    #pragma unroll
    for(int g=0; g <  groups; g++){
        in_offset = (b_idx * input_features) + (g * group_features) + g_f_idx;
        out_offset = ((g * batch_size + b_idx) * group_features) + g_f_idx;
        output[out_offset] = input[in_offset];
    }
}
\end{lstlisting}
\end{minipage}

\end{document}