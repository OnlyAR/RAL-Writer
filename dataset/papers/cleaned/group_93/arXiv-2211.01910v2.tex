\title{Large Language Models are Human-Level Prompt Engineers}

\begin{document}

\maketitle
\renewcommand*{\thefootnote}{\arabic{footnote}}
\setcounter{footnote}{0}

\begin{abstract}
By conditioning on natural language instructions, large language models (LLMs) have displayed impressive capabilities as general-purpose computers. However, task performance depends significantly on the quality of the prompt used to steer the model, and most effective prompts have been handcrafted by humans. Inspired by classical program synthesis and the human approach to prompt engineering, we propose \textit{Automatic Prompt Engineer}\footnote{We define ``prompt engineering'' as optimizing the language in a prompt in order to elicit the best possible performance. Notably, this does not include prompts that chain multiple LLM queries together or give the LLM access to external tools.} (APE) for automatic instruction generation and selection. In our method, we treat the instruction as the ``program,'' optimized by searching over a pool of instruction candidates proposed by an LLM in order to maximize a chosen score function. To evaluate the quality of the selected instruction, we evaluate the zero-shot performance of another LLM following the selected instruction. Extensive experiments show that our automatically generated instructions outperform the prior LLM baseline by a large margin and achieve better or comparable performance to the instructions generated by human annotators on 24/24 Instruction Induction tasks and 17/21 curated BIG-Bench tasks. We conduct extensive qualitative and quantitative analyses to explore the performance of APE. We show that APE-engineered prompts are able to improve few-shot learning performance (by simply prepending them to standard in-context learning prompts), find better zero-shot chain-of-thought prompts, as well as steer models toward truthfulness and/or informativeness. 
\footnote{\ Our code is available at \url{https://github.com/keirp/automatic_prompt_engineer}.}
\end{abstract}

\section{Introduction}\label{sec:intro}
The combination of scale and attention-based architectures has resulted in language models possessing an unprecedented level of generality \citep{kaplan2020scaling,vaswani2017attention}. These so-called ``large language models'' (LLMs) have shown remarkable, often superhuman, capabilities across a diverse range of tasks, including both zero-shot and few-shot setups \citep{brown2020language,srivastava2022beyond}. With generality, however, there comes a question of control: how can we make LLMs do what we want them to do? 

To answer this question and steer LLMs toward desired behaviors, recent work has considered fine-tuning \citep{ouyang2022training,ziegler2019fine}, in-context learning \citep{brown2020language}, and several forms of prompt generation \citep{gao2021prompting}, including both differentiable tuning of soft prompts \citep{qin2021learning,lester2021power} and natural language prompt engineering \citep{reynolds2021prompt}. The latter is of particular interest, as it provides a natural interface for humans to communicate with machines and may be of great relevance not only to LLMs but to other generalist models such as prompted image synthesizers \citep{rombach2022high,ramesh2022hierarchical}, for which public interest in prompt design and generation has also emerged (see Appendix \ref{appdx_wild_prompt_engineering} for examples).

Behind this interest is the fact that plain language prompts do not always produce the desired results, even when those results are possible to produce with alternative instructions. Thus, human users must experiment with a wide range of prompts to elicit desired behaviors, as they have little knowledge of how compatible instructions are with a particular model.
We can understand this by viewing LLMs as black-box computers that execute programs specified by natural language instructions: while they can execute a broad range of natural language programs, the way these programs are processed may not be intuitive for humans, and the quality of instruction can only be measured when executing these instructions on a downstream task \citep{sanh2022multitask, wei2021finetuned}. 

\workshopexclude{
To reduce the human effort involved in creating and validating effective instructions, we propose a novel algorithm using LLMs to generate and select instructions automatically. We call this problem \textit{natural language program synthesis} and propose to address it as a black-box optimization problem using LLMs to generate and search over heuristically viable candidate solutions. 
In doing so, we leverage the generalist capabilities of LLMs in three ways. First, we use an LLM as an inference model \citep{ellis2021dreamcoder, honovich2022instruction} to generate instruction candidates based on a small set of demonstrations in the form of input-output pairs. Next, we guide the search process by computing a score for each instruction under the LLM we seek to control. Finally, we propose an iterative Monte Carlo search method where LLMs improve the best candidates by proposing semantically similar instruction variants. Intuitively, our algorithm asks LLMs to generate a set of instruction candidates based on demonstrations and then asks them to assess which instructions are more promising. We call our algorithm Automatic Prompt Engineer (\algname). \textbf{Our main contributions are:}
\begin{itemize}
    \item We frame instruction generation as natural language program synthesis, formulate it as a 
    black-box optimization problem guided by LLMs, and propose both a naive and an iterative Monte Carlo search methods to approximate the solution.
    \item Our proposed method, APE, achieves human-level performance on zero-shot learning with model-generated instructions on 24/24 Instruction Induction and 17/21 Big-Bench tasks.
    \item We provide extensive qualitative and quantitative analyses exploring various facets of APE, and demonstrate applications of APE for improving few-shot learning, finding better zero-shot chain of thought prompts, and steering LLMs toward desired behaviors such as truthfulness and/or informativeness.
\end{itemize}
}

\workshoponly{
To reduce the human effort involved in creating and validating effective instructions, we propose a novel algorithm using LLMs to generate and select instructions automatically. We call this problem \textit{natural language program synthesis} and propose to address it as a black-box optimization problem using LLMs to generate and search over heuristically viable candidate solutions. In doing so, we leverage the generalist capabilities of LLMs in two ways. First, we use an LLM as an inference model \citep{ellis2021dreamcoder, honovich2022instruction} to generate instruction candidates based on a small set of demonstrations in the form of input-output pairs. Second, we guide the search process by computing a score for each instruction under the LLM we seek to control. Intuitively, our algorithm asks LLMs to generate a set of instruction candidates based on demonstrations and then asks them to assess which instructions are more promising. We call our algorithm Automatic Prompt Engineer (\algname). \textbf{Our main contributions are:}
\begin{itemize}
    \item We frame instruction generation as natural language program synthesis, formulate it as a 
    black-box optimization problem guided by LLMs, and propose a Monte Carlo search methods to approximate the solution.
    \item Our proposed method, APE, achieves human-level performance on zero-shot learning with model-generated instructions on 19/24 NLP tasks and demonstrate applications of APE for steering LLMs toward desired behaviors such as truthfulness and/or informativeness.
\end{itemize}
}

\begin{figure}
  \centering
  \vspace{-0.05in}
\begin{subfigure}[b]{0.48\textwidth}
   \hfill\includegraphics[width=1.0\linewidth]{figures/illustration/APE_pipe.pdf}\vspace{0.75em}
  \caption{Automatic Prompt Engineer (APE) workflow}
\end{subfigure}
 \begin{subfigure}[b]{0.49\textwidth}
  \includegraphics[width=1.0\linewidth]{figures/main/model_size.pdf}
  \caption{Interquartile mean across 24 tasks}
  \end{subfigure}
  \caption{(a) Our method, \textbf{Automatic Prompt Engineer (APE)}, automatically generates instructions for a task that is specified via output demonstrations: it generates several instruction candidates, either via direct inference or a recursive process based on semantic similarity, executes them using the target model, and selects the most appropriate instruction based on computed evaluation scores. (b) As measured by the interquartile mean across the 24 NLP tasks introduced by \citet{honovich2022instruction}, APE is able to surpass human performance when using the InstructGPT model \citep{ouyang2022training}.}\label{fig:highlight}
\end{figure}\section{Related Work}

\paragraph{Large Language Models}
Scaling up transformer-based language models in terms of model size, training data, and training compute has been shown to predictably improve performance on a wide range of downstream NLP tasks \citep{vaswani2017attention, devlin2018bert, brown2020language}. Many emergent abilities \citep{wei2022emergent} of LLMs have been discovered as a result of this scaling, including few-shot in-context learning, zero-shot problem solving, chain of thought reasoning, instruction following, and instruction induction \citep{cobbe2021training, wei2022chain, kojima2022large, sanh2022multitask, wei2021finetuned, ouyang2022training, honovich2022instruction}. In this paper, we view LLMs as black-box computers that execute programs specified by natural language instructions and investigate how to control an LLM's behavior using model-generated instructions. 

\paragraph{Prompt Engineering}
Prompting offers a natural and intuitive interface for humans to interact with and use generalist models such as LLMs. Due to its flexibility, prompting has been widely used as a generic method for NLP tasks \citep{schick2021exploiting, brown2020language, sanh2022multitask}. However, LLMs require careful prompt engineering, either manually \citep{reynolds2021prompt} or automatically \citep{gao2021making, shin2020autoprompt}, as models do not seem to understand the prompts in the same way a human would \citep{webson2021prompt, lu2021fantastically}. Though many successful prompt tuning methods perform optimization over a continuous space using gradient-based methods \citep{liu2021gpt, qin2021learning,lester2021power}, this becomes less practical with scale, as computing gradients becomes increasingly expensive and access to models shifts to APIs that may not provide gradient access. 
In our paper, we borrow components from discrete prompt search methods, such as prompt generation \citep{gao2021making, ben2021pada}, prompt scoring \citep{davison2019commonsense} and prompt paraphrasing \citep{jiang2020can, yuan2021bartscore} to optimize instructions by searching directly in the natural language hypothesis space. 
As compared to this past work, which uses specialized models for each component and leans heavily on human templates, we show that the entire search can be conducted by a single LLM.

\paragraph{Program Synthesis} Program synthesis involves the automatic search over a ``program space'' to find a program satisfying a particular specification \citep{gulwani2017program}. 
Modern program synthesis admits a wide variety of specifications, including input-output examples \citep{ellis2021dreamcoder,wong2021leveraging} and natural language \citep{jain2022jigsaw}. The range of feasible program spaces to search over has also grown, from historically restrictive domain-specific languages to general-purpose programming languages \citep{austin2021program}. In contrast to prior approaches that require a suitable structured hypothesis space and library of components \citep{liang2010learning, ellis2018learning}, we leverage the structure provided by LLMs to search over the space of natural language programs. 
Using inference models is a standard practice to speed up the search by restricting the search space to a limited space of possible expressions  \citep{menon2013machine, lee2018accelerating, devlin2017neural, ellis2021dreamcoder}. 
Inspired by this, we use LLMs as approximate inference models to generate program candidates based on a small set of demonstrations. Unlike classical program synthesis, our inference models do not require any training and generalize well to various tasks.

\workshoponly{
\begin{figure}
  \centering
  \includegraphics[width=0.8\linewidth]{figures/illustration/APE_pipeline.pdf}
  \caption{Our method, \textbf{Automatic Prompt Engineer (APE)}, automatically generates instructions for a task that is specified via output demonstrations: it generates several instruction candidates, either via direct inference or a recursive process based on semantic similarity, executes them using the target model, and selects the most appropriate instruction based on computed evaluation scores.}\label{fig:pipline}
\end{figure}
}\workshopexclude{\section{Natural Language Program Synthesis using LLMs}}
\workshoponly{\section{Method in Detail}}

We consider a task specified by a dataset $\trainingData = \{(\demoQ, \demoA)\}$ of input/output demonstrations sampled from population $\mathcal{X}$, and a prompted model $\M$. 
The goal of natural language program synthesis is to find a single instruction $\instruction$ such that, when $\M$ is prompted with the concatenation $[\instruction ; \demoQ]$ of instruction and a given input, $\M$ produces the corresponding output $\demoA$. More formally, we frame this as an optimization problem, where we seek instruction $\instruction$ that maximizes the expectation of some per-sample score $f(\instruction, \demoQ, \demoA)$ over possible $(\demoQ, \demoA)$:
\begin{equation}\label{eq:score}
\instruction^{\star} = \argmax_\instruction f(\instruction) =  \argmax_\instruction \expectation{(\demoQ, \demoA)}{f(\instruction,\demoQ, \demoA)}
\end{equation}
Note that in general, $\demoQ$ may be the empty string, such that we are optimizing $\instruction$ as a prompt that directly produces outputs $\{A\}$.
While this task has been widely attempted by humans, we have little knowledge of how compatible any particular instruction is with model $\M$. Thus, we propose to treat this human-intractable question as a black-box optimization process guided by LLMs. 
Our algorithm, APE, uses LLMs in each of two key components, proposal and scoring. As shown in Figure \ref{fig:highlight} and summarized in Algorithm \ref{alg:ape}, APE first proposes a few candidate prompts, and then filters/refines the candidate set according to a chosen score function, ultimately choosing the instruction with the highest score. We discuss options for proposal and scoring next. 

\subsection{Initial Proposal Distributions}\label{subsec:initialU}
Due to the infinitely large search space, finding the right instruction can be extremely difficult, which has rendered natural language program synthesis historically intractable. Recent progress in NLP has shown language models are very good at generating diverse natural language text. Therefore, we consider leveraging a pretrained LLM to propose a good set $\proposal$ of candidate solutions that will guide our search procedure. While random samples from LLMs are unlikely to produce the desired ($\demoQ, \demoA$) pairs, we can instead ask the LLM to approximately infer the most likely instructions with a high score, given the input/output demonstrations; i.e., to approximately sample from $P(\instruction\given\trainingData,\ f(\instruction)\textrm{ is high})$.

\begin{wrapfigure}{R}{0.3\textwidth}
\centering
\vspace{-0.1in}
\includegraphics[width=0.275\textwidth]{figures/illustration/template_combined.pdf}
\caption{Prompts for LLMs}
\vspace{-0.35in}
\label{fig:llm_template}
\end{wrapfigure}

\newcommand{\algspacer}{\hspace{1em}}
\begin{algorithm}[tb]\small
    \caption{Automatic Prompt Engineer (APE)}\label{alg:ape}
    \begin{algorithmic}
        \STATE {\bfseries Require:} $\trainingData \gets \{(\demoQ, \demoA)\}_n$: training examples, $f:\instruction\times\mathcal{D} \mapsto \mathbb{R}$: score function
    \end{algorithmic}
    \begin{algorithmic}[1]
        \STATE Use LLM to sample instruction proposals $\ \proposal \gets \{\instruction_1, ..., \instruction_m\}$. (See Section~\ref{subsec:initialU})
        \WHILE{not converged}
        \STATE Choose a random training subset $\widetilde{\mathcal{D}}_\textrm{train} \subset \trainingData$. 
        \FORALL{$\instruction$ in $\proposal$}
            \STATE Evaluate score on the subset $\widetilde{s} \gets f(\instruction, \widetilde{\mathcal{D}}_\textrm{train})$ (See Section~\ref{sec:score_function} )
        \ENDFOR
        \STATE Filter the top k\% of instructions with high scores $\proposal_k \subset \proposal$ using $\{\widetilde{s}_1, ..., \widetilde{s}_m\}$
        \STATE Update instructions $\proposal \gets  \proposal_k$ or use LLM to resample $\proposal \gets \text{resample} ( \proposal_k )$ (See Section~\ref{sec:iterative}) 
        \ENDWHILE
    \end{algorithmic}
    \begin{algorithmic}
        \STATE {\bfseries Return} instruction with the highest score $\instruction^{\star} \gets \arg\max_{\instruction \in \proposal_k} f(\instruction, \trainingData)$
    \end{algorithmic}
\end{algorithm}

\paragraph{Forward Mode Generation} We consider two approaches to generate high-quality candidates from $P(\instruction\given\trainingData,\ f(\instruction)\textrm{ is high})$. First, we adopt an approach based on ``forward'' mode generation by translating this distribution $P(\instruction\given\trainingData,\ f(\instruction)\textrm{ is high})$ into words. For example, in our instruction induction experiments (Subsection \ref{sec:inst_induct}), we follow \citet{honovich2022instruction} and prompt the LLM using Figure \ref{fig:llm_template} (Top). %In this case, the template suggests the outputs are generated based on the instruction, so that the score functions considered will be high. 

\paragraph{Reverse Mode Generation} Although the ``forward'' model works out of the box for most of the pretrained LLMs, translating $P(\instruction\given\trainingData,\ f(\instruction)\textrm{ is high})$ into words requires custom engineering across different tasks. This is because while instructions are typically found in the beginning of passages, the ``forward'' model only generates text from left to right, which requires the instruction to be predicted at the end of the prompt. Therefore, we desire a more flexible approach such that the instruction can be anywhere in the text. To address this, we consider ``reverse'' mode generation, which uses an LLM with infilling capabilities---e.g., T5~\citep{raffel2020exploring}, GLM \citep{du2022glm}, and InsertGPT~\citep{bavarian2022efficient}---to infer the missing instructions. Our ``reverse'' model directly samples from $P(\instruction\given\trainingData,\ f(\instruction)\textrm{ is high})$ by filling in the blank. We show an example of the such template in Figure \ref{fig:llm_template} (Middle).

\paragraph{Customized Prompts} Note that depending on the score function being used, there may exist more appropriate prompts than the samples above. For example, in our TruthfulQA experiments, we start with the human-designed instructions from the original dataset~\citep{lin2022truthfulqa} and ask the the ``reverse'' model to propose initial instruction samples that fit the missing context (Figure \ref{fig:llm_template} (Bottom)). 

\subsection{Score Functions} \label{sec:score_function}
To cast our problem as black-box optimization, we choose a score function that accurately measures the alignment between the dataset and the data the model generates. In our instruction induction experiments, we consider two potential score functions, described below. In the TruthfulQA experiments, we focused primarily on automated metrics proposed in \citet{lin2022truthfulqa}, similar to the execution accuracy. In each case, we evaluate the quality of a generated instruction using Equation (\ref{eq:score}), and take the expectation over a held-out test dataset $\testData$.

\paragraph{Execution accuracy} First, we consider evaluating the quality of an instruction $\instruction$ using the execution accuracy metric proposed by \citet{honovich2022instruction}, which we denote as $\fexec$. In most cases, execution accuracy is simply defined as the 0-1 loss, $f(\instruction, \demoQ, \demoA) = \mathbb{1}\left[\M([\instruction ; \demoQ]) = \demoA\right]$. On some tasks, execution accuracy takes into account invariants; e.g., it may be an order invariant set matching loss, as described in Appendix A of \citet{honovich2022instruction}.  

\paragraph{Log probability} We further consider a softer probabilistic score function, which we hypothesize might improve optimization by providing a more fine-grained signal when searching over low-quality instruction candidates. In particular, we consider the log probability of the desired answer given the instruction and question under the target model $\M$, which on a per sample basis, is $\log P(\demoA\given[\instruction ; \demoQ])$.

\paragraph{Efficient score estimation}
Estimating the score by computing the score over the entire training dataset for all instruction candidates can be expensive. To reduce the computation cost, we adopt a filtering scheme where a promising candidate receives more computation resources while a low-quality candidate receives less computation. 
It can be achieved by using a multi-stage computation strategy on lines 2-9 Algorithm \ref{alg:ape}. We first evaluate all candidates with a small subset of the training dataset. For the candidates with a score greater than a certain threshold, we sample and evaluate a new non-overlapping subset from the training dataset to update the moving average of the score. 
Then, we repeat this process until a small set of candidates is left, which are evaluated on the entire training dataset. 
This adaptive filtering scheme significantly improves the computation efficiency by keeping the exact computation costs for the high-quality samples and drastically reducing the computation costs for low-quality candidates. 
We note that a similar score estimation scheme has been used in previous works \citep{li2022competition, maclaurin2015firefly}.

\subsection{Iterative Proposal Distributions}\label{sec:iterative}
Despite our attempt to directly sample high-quality initial instruction candidates, it could be the case that the method described in Subsection \ref{subsec:initialU} fails to produce a good proposal set $\proposal$, either because it lacks of diversity or does not contain any candidates with a suitably high score. In case of such challenges, we explore an iterative process for resampling $\proposal$.

\begin{wrapfigure}{R}{0.3\textwidth}
\centering
\vspace{-0.1in}
\includegraphics[width=0.275\textwidth]{figures/illustration/template_resample.pdf}
\caption{Resampling}
\vspace{-0.15in}
\label{fig:template_resampling}
\end{wrapfigure}

\paragraph{Iterative Monte Carlo Search}
Instead of only sampling from the initial proposal, we consider exploring the search space locally around the current best candidates. This allows us to generate new instructions that are more likely to be successful. We call this variant \textit{iterative \algname}. 
At each stage, we evaluate a set of instructions and filter out candidates with low scores. Then, an LLM is asked to generate new instructions similar to those with high scores. We provide the prompt used for resampling in Figure \ref{fig:template_resampling}. 
Figure \ref{fig:main-posterior} (Right) shows that although this approach improves the overall quality of the proposal set $\proposal$, the highest scoring instruction tends to remain the same with more stages. We conclude iterative generation provides marginal improvement over the relative simplicity and effectiveness of the generative process described in Subsection \ref{subsec:initialU}. Therefore, we use \algname~without iterative search as default unless otherwise stated.\workshopexclude{\section{Large Language Models are Human-Level Prompt Engineers}}
\workshoponly{\section{Additional Experimental Results}\label{app:add_res} }
This section examines how APE can guide LLMs to desired behaviors. We investigate from four perspectives: zero-shot performance, few-shot in-context learning performance, zero-shot chain-of-thought reasoning, and truthfulness. Our experiments show that APE can find prompts that improve task performance, performing equal to or even better than those authored by humans. APE also often produces insightful tricks for how to best prompt language models that can be successfully transferred to new tasks (see Section \ref{sec:cot}).
\workshoponly{For consistency, we duplicate some of the results here.}

\subsection{Instruction Induction}\label{sec:inst_induct}
We assess the effectiveness of zero-shot and few-shot in-context learning on 24 instruction induction tasks proposed in \citet{honovich2022instruction}. The tasks span many facets of language understanding, from simple phrase structure to similarity and causality identification. We provide a detailed descriptions of each task in Appendix B. For each task, we sample five input-output pairs from the training data and select the best instruction using algorithm \ref{alg:ape}. Then, we evaluate the quality of the instruction by executing the instruction on InstructGPT \footnote{We use the \textit{text-davinci-002} via the OpenAI API (\url{https://beta.openai.com/}). Though not stated explicitly in the API, we assume the models are those reported by \citet{ouyang2022training}.}. We repeat our experiments five times with different random seeds to report the mean and standard deviation. The exact templates for our experiments can be found in Appendix (Table \ref{table:raw_templates}).

\begin{figure}[t]
  \vspace{-0.25in}
  \centering
  \includegraphics[width=0.95\linewidth]{figures/main/exec_acc_zero_shot.pdf}
  \caption{Zero-shot test accuracy on 24 Instruction Induction tasks. \algname~achieves human-level or better performance on all  24 out of 24 tasks.}\label{fig:main-zero-shot}
\end{figure}

\paragraph{Zero-shot Learning}
We compare our method against two baselines: human prompt engineers (Human)\footnote{\mbox{We use the gold annotations from \citet{honovich2022instruction}, which were manually verified for correctness.}} and the model-generated instruction algorithm proposed by \citet{honovich2022instruction}. This algorithm can be thought of as a greedy version of \algname, without a search and selection process; thus, we refer to it as ``Greedy''. Figure \ref{fig:main-zero-shot} shows the zero-shot performance of InstructGPT using human instructions and model generated instructions. Our algorithm outperforms ``Greedy'' on every task and achieves equal or better than human performance on 24 of 24 tasks. Moreover, the Interquartile Mean (IQM) \citep{agarwal2021deep} across all 24 tasks in Figure \ref{fig:highlight} suggests that \algname~with InstructGPT outperforms human-engineered prompts, obtaining an IQM of 0.810 vs humans' 0.749. We summarize the instruction selected by \algname~for each task in Appendix (Table \ref{table:best_instructions_all}).

\paragraph{Few-shot In-context Learning}
We evaluated APE-generated instructions in  few-shot in-context learning, where we insert the instruction before the in-context demonstrations. Those instructions are selected based on zero-shot execution accuracy, and we denote this setting as ``Instruction + In-context'' in Figure \ref{fig:main-few-shot}. As shown in Figure \ref{fig:main-few-shot}, adding an instruction achieves a comparable or better test performance than the standard in-context learning performance on 21 of 24 tasks. Counter-intuitively, adding in-context examples for Rhymes, Large Animal, and Second Letters hurts model performance. We conjecture that it may be because the selected instructions overfit the zero-shot learning scenario and thus do not perform well on the few-shot case. Therefore, we experiment using few-shot execution accuracy as the selection metric. Figure \ref{fig:app-few-shot-as-metric} shows that the few-shot metric achieves comparable or slightly better than the zero-shot metric except for Rhymes. To have an intuitive understanding of what is happening, we provide a qualitative analysis in Appendix \ref{sec:app_ii}. 

\subsection{BigBench}\label{sec:bigbench}
To see whether APE can be applied to more challenging tasks, we propose and curate BIG-Bench Instruction Induction (BBII), a clean and tractable subset of 21 tasks that have a clear, human-written instruction that can be applied to all examples in the dataset. The selected tasks cover many facets of language understanding and includes all nine such problems from the BigBench-Hard Subset \citep{suzgun2022challenging}. In particular, it includes emotional understanding, context-free question answering, reading comprehension, summarization, algorithms, and various reasoning tasks (e.g., arithmetic, commonsense, symbolic, and other logical reasoning tasks). We provide a detailed description of the task and our selection criteria in Appendix \ref{app:imp_details}. 

For each task, we used the reverse mode generation of InstructGPT to generate a set of instruction candidates and ranked the instructions based on their execution accuracy. Then, we executed the selected instruction on InstructGPT to compute the zero-shot performance on the test set and compared it with the default human prompt. As shown in Appendix Table \ref{table:bbii_results}, APE achieves comparable or better performance than the default human prompt on 17 out of 21 tasks.

\subsection{Zero-shot Chain of Thought}\label{sec:cot}
Chain-of-thought reasoning has been shown to dramatically improve the ability of LLMs to complete complex reasoning tasks, such as solving math problems that require multiple steps. Early works \citep{nye2021show,betz2021thinking,wei2022chain} on chain-of-thought used fine-tuning or in-context learning to get LLMs to show their work for such problems. One of the most influential recent works of prompt engineering was the discovery \citep{kojima2022large} that LLMs could be made to give chain-of-thoughts simply by prepending ``Let's think step by step.'' to the beginning of the LLM's response. Known as Zero-Shot-CoT, this prompting strategy improves the zero-shot performance of InstructGPT on MultiArith \citep{roy2016solving} from 17.7 to 78.7 and improves performance on GSM8K\citep{cobbe2021training} from 10.4 to 40.7. As shown in Table \ref{tab:cot-arith}, \citet{kojima2022large} found their prompt was the best performing out of at least nine human-designed prompts.

We used APE to automatically search for the best answer-prefix across the suite of tasks used in \citet{kojima2022large}. Our approach to optimizing this prompt was inspired by \citet{zelikman2022star}. First, we generate a dataset of questions and reasoning steps generated using InstructGPT with ``Let's think step by step.'' Then, we remove any data points that had incorrect answers. Finally, we use APE to find a prompt starting with ``Let's'' that maximizes the likelihood of these correct reasoning steps. See Table \ref{table:raw_templates} for the template used for prompt generation and evaluation. APE produces the prompt ``Let’s work this out in a step by step way to be sure we have the right answer.'' This generated prompt further improves performance from 78.7 to 82.0 on MultiArith and from 40.7 to 43.0 on GSM8K. We believe this general workflow represents a common use-case for APE where prompt engineers use APE to optimize parts of their exiting templates to improve performance. See Figure \ref{fig:cot-all} for details on the performance of this prompt on other reasoning tasks.

\workshopexclude{
\subsection{TruthfulQA}
We apply our method on TruthfulQA \citep{lin2022truthfulqa} to see how \algname-generated instructions can steer an LLM to generate answers with different styles, and study the trade-off between truthfulness and informativeness. Borrowing the metrics from the original paper, we use \algname~to the learn instructions that maximize three metrics: truthfulness (\% True), informativeness (\% Info), and a combination of both (\%True + \%Info). \citet{lin2022truthfulqa} used human evaluation to assess the model performance, but they found their automated metrics align with human prediction over 90\% of the time. In our experiments, we rely on their fine-tuned GPT-judge and GPT-info to evaluate the scores. 

\paragraph{Prompt Engineering in TruthfulQA} We want to stress that the TruthfulQA dataset is intended to test pretrained models in zero-shot settings. Our results are not in any way compatible with the original benchmarks. Because we have optimized the instructions using a small portion of the question and answer pairs as training demonstrations, our results are not ``true few-shot learning''~\citep{perez2021true}. We randomly sampled 100 out of 817 questions for the actual experiments to form training demonstrations $\trainingData$. To sample the proposal set $\proposal$, we ask a ``reverse'' model to generate instructions based on six randomly chosen demonstration pairs, similar to our previous experiments. Unlike in Instruction Induction, in TruthfulQA, we aim to find a single best instruction prompt that works well across all 38 categories of questions spanning health, law, politics, and fiction. It is worth noting all our generated instructions are very generic, e.g., ``You will be asked a series of questions. For each question, you must either answer the question or decline to answer, in which case you must state that you have no comment'', and do not contain any examples from the dataset.

\begin{figure}
  \vspace{-0.25in}
  \centering
\begin{subfigure}[b]{0.245\textwidth}
  \captionsetup{justification=centering}
  \hfill\includegraphics[width=1.0\linewidth]{figures/main/truthfulqa_top10_train.pdf}
  \caption{Average performance Train}
\end{subfigure}
\begin{subfigure}[b]{0.245\textwidth}
  \captionsetup{justification=centering}
  \hfill\includegraphics[width=1.0\linewidth]{figures/main/truthfulqa_top10_test.pdf}
  \caption{Average performance Test}
\end{subfigure}
\begin{subfigure}[b]{0.245\textwidth}
  \captionsetup{justification=centering}
  \hfill\includegraphics[width=1.0\linewidth]{figures/main/truthfulqa_scatter_train.pdf}
  \vspace{-1.6em}
  \caption{\%True-\%Info trade-off Training}
\end{subfigure}
\begin{subfigure}[b]{0.245\textwidth}
  \captionsetup{justification=centering}
  \hfill\includegraphics[width=1.0\linewidth]{figures/main/truthfulqa_scatter_test.pdf}
  \vspace{-1.6em}
  \caption{\%True-\%Info trade-off Test}
\end{subfigure} \vspace{-0.15in}
  \caption{Comparison of \algname~and ``help'' (human) prompt on the TruthfulQA task. (a) Percentage of answers that were either true (\% True), informative (\% Info), or both (\% True + \% Info) on the 100 training examples. (b) Same data on the 717 test examples. (c) \%True-\%Info frontier computed on training data with top 10 instructions from each metric. (d) \%True-\%Info frontier on the test data. }\label{fig:truthfulqa}
\end{figure}

\paragraph{Truthfulness vs Informativeness Trade-off}
We found that \algname~outperforms the human-engineered prompt with only 200 candidates proposed by InstructGPT (175B), as seen in Figure~\ref{fig:truthfulqa}. We compared our generated prompt with the ``help'' prompt from \citet{lin2022truthfulqa}.
The training and test performance are shown in Figure~\ref{fig:truthfulqa}(a)-(b). We found that choosing the top 10 of 200 candidates on the training set generalizes well to the test set. We report the average performance across the top 10 instructions for the three metrics.
This result by itself is not surprising as the human baseline is not carefully chosen, as pointed out by \citet{askell2021general}. However, we found that the instructions discovered by \algname~can achieve very high truthfulness with answers such as ``No comment,'' but these answers provide little information. We used our top candidates to further investigate the trade-off between truthfulness and informativeness. We visualize the top 10 proposed samples across the three metrics on the truthfulness-informative plots shown in Figure~\ref{fig:truthfulqa}(c) and Figure~\ref{fig:truthfulqa}(d). While \algname~achieves over 40\% accuracy in providing both true and informative answers (v.s. 30\% by the ``help'' prompt from humans), the instructions discovered tend to target the two ends of this \%true-\%info Pareto frontier. 
}

\workshopexclude{\section{Quantitative Analysis}}
\workshoponly{\section{Additional Results - Quantitative Analysis}}
In this section, we conduct quantitative analyses to better understand the three main components of our method: proposal distribution, score functions, and iterative search. Moreover, we conduct a cost analysis in the Appendix \ref{sec:cost_analysis} to understand the most cost-efficient way to find the best prompt. We observe the larger and more powerful language models are more cost-effective for generating the best prompt despite a higher per-token cost.

\subsection{LLMs for Proposal Distribution}

\paragraph{How does the proposal quality change as we increase the model size?} To understand how the model size affects the quality of the initial proposal distribution, we examine eight different models\footnote{We use ada, babbage, curie, davinci, text-ada-001, text-babbage-001, text-curie-001, text-davanci-002} available via the OpenAI API. To assess the quality of the proposal distribution, we generate 250 instructions per model and compute the execution accuracy on 50 test data points. We visualize the survival function (percentage of instructions with test accuracy greater than a certain threshold) and the histogram of test accuracy for a simple task (i.e., Pluralization) in Figure \ref{fig:main-posterior} (a) and include a similar plot for a more challenging task (Start With) in the Appendix (Figure \ref{fig:app-posterior-model-size-hard}). As shown in both figures (and unsurprisingly), larger models tend to produce better proposal distributions than smaller ones, as do the models that were fine-tuned to follow human instructions. On the simple task, all instructions generated by the best model, InstructGPT (175B), have reasonable test accuracy. In contrast, half of the instructions are off-topic and perform poorly on the more challenging task. 

\begin{figure}
  \centering
  \vspace{-0.1in}
 \begin{subfigure}[b]{0.49\textwidth}
  \includegraphics[width=1.0\linewidth]{figures/main/posterior_model_size_plural.pdf}
  \end{subfigure}
  \begin{subfigure}[b]{0.49\textwidth}
  \includegraphics[width=1.0\linewidth]{figures/main/posterior_mcmc_passive.pdf}
  \end{subfigure}
  \caption{(Left) Quality of the proposal distribution of models with different size as assessed by test execution accuracy. (Right) Iterative Monte Carlo search improves the quality of the instruction candidates at each round.}\label{fig:main-posterior}
\end{figure}

\subsection{LLMs for selection}
\paragraph{Does proposal quality matter under selection?} If we sample more instructions from the LLMs, then it becomes more likely for us to find better instructions. To verify this hypothesis, we increase the sample size from 4 to 128 and evaluate the test accuracy change. Figure \ref{fig:mcmc_comparison} (Left) shows a monotonically increasing trend with a diminishing return, as human-level performance is achieved with 64 instruction samples. Thus, we choose 50 as our default sample size. Under this configuration, we investigate how the proposal distribution affects the test accuracy of the best instruction selected by our algorithm. Figure \ref{fig:highlight}(b) shows that though the small models may be less likely to generate good instructions, they nonetheless generate some good ones if we sample enough candidates. Therefore, we still find promising instructions with a small model by running our selection algorithm, explaining why our method outperforms the greedy approach \cite{honovich2022instruction} across all eight models.

\paragraph{Which scoring function is better?} We compute the correlation between the test accuracy and two metrics on 24 instruction induction tasks to study how good our proposed metrics are. We generate 250 instructions per task using InstructGPT (175B) in “forward” mode and compute the metric score and test accuracy on 10 test data points. We visualize the Spearman correlation between the test accuracy and two metrics. Figure \ref{fig:mcmc_comparison} (Middle) shows that the execution accuracy aligns better with the test performance across the tasks. Thus, we choose it as our default metric unless otherwise stated.

\begin{figure}
  \vspace{-0.15in}
  \centering
  \begin{subfigure}[b]{0.31\textwidth}
  \includegraphics[width=1.0\linewidth]{figures/main/sample_size_task_mean.pdf}
  \end{subfigure}\hfill
 \begin{subfigure}[b]{0.31\textwidth}
  \includegraphics[width=1.0\linewidth]{figures/main/corr_metric_spearman.pdf}
  \end{subfigure}\hfill
   \begin{subfigure}[b]{0.31\textwidth}
  \includegraphics[width=1.0\linewidth]{figures/main/mcmc_comparison.pdf}
  \end{subfigure}
  \caption{(Left) Test execution of the best instruction as we increase the number of instruction candidates. We report the mean and standard deviation across 6 different tasks. (Middle) Spearman Correlation between the test accuracy and two metrics on 24 tasks. (Right) Test execution accuracy of the best instruction selected using \algname and iterative \algname (\algname (IT)).}\label{fig:mcmc_comparison}
  \vspace{-0.1in}
\end{figure}
\subsection{Iterative Monte Carlo Search}\label{ab:tmcs}
\paragraph{Does Iterative Search improve the instruction quality?} We visualize the survival function and histogram of test accuracy on the ``Passivization'' task in Figure \ref{fig:main-posterior} (Right) and include five more tasks in the Appendix. The survival plot shows that the curves increase as the round goes up, which suggests that iterative search does result in a higher-quality proposal set. However, we observe diminishing returns to further selection rounds as the quality seems to stabilize after three rounds.

\paragraph{Do we need Iterative Search?}
We compare \algname~and iterative \algname~on six tasks\footref{sixtasks}. As shown in Figure \ref{fig:mcmc_comparison}, the iterative search marginally improves performance on tasks where APE underperforms humans but achieves similar performance on the other tasks. This is consistent with our hypothesis that iterative search would be most useful on tasks where generating a good initial $\proposal$ is challenging.
\section{Conclusion}
Large language models can be seen as general-purpose computers that execute programs specified by natural language prompts. We automate the prompt engineering process by formulating it as a black-box optimization problem, which we propose to solve using efficient search algorithms guided by LLMs. Our method achieves human-level performance on various tasks with minimum human inputs. As recent LLMs demonstrate an impressive ability to follow human instruction, we expect many future models, including those for formal program synthesis, to have a natural language interface. This work builds the foundation to control and steer generative artificial intelligence.

\subsubsection*{Acknowledgments}
We would like to thank Or Honovich and Michael Zhang for their help and valuable feedback. JB was supported by NSERC Grant [2020-06904], CIFAR AI Chairs program, Google Research Scholar Program and Amazon Research Award. KP was supported by NSERC PGS-D. SP was supported by NSERC CGS-D. HC was supported by NSERC CGS-D and RBC Graduate Fellowship. Resources used in preparing this research were provided, in part, by the Province of Ontario, the Government of Canada through CIFAR, and companies sponsoring the Vector Institute for Artificial Intelligence.

\newpage

\end{document}