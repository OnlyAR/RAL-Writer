{
    "instruction": "You are an experienced researcher, I will give you some scientific research papers in the same field. Please read them carefully and write a summary about them.\n\nHere are the papers:\n\n<paper 1>\n\\title{Mars: Semantic-aware Contrastive Learning for \\\\ End-to-End Task-Oriented Dialog}\n\n\\begin{document}\n\n\\maketitle\n\\begin{abstract} \nTraditional end-to-end task-oriented dialog systems first convert dialog context into belief state and action state before generating the system response. The  system response performance is significantly affected by the quality of the belief state and action state. We first explore what dialog context representation is beneficial to improving the quality of the belief state and action state, which further enhances  the generated response quality. To tackle our exploration, we propose \\textbf{Mars}, an end-to-end task-oriented dialog system with two contrastive learning strategies to model the relationship between dialog context and  belief/action state representations. Empirical results  show  dialog context representations, which are more different from semantic state representations, are more conducive to multi-turn task-oriented dialog.\nMoreover, our proposed  Mars achieves state-of-the-art  performance on the MultiWOZ 2.0, CamRest676, and CrossWOZ\\footnote{The code is available at \\url{https://github.com/hpsun1109/Mars}.}.\n\\end{abstract}\n\n\\section{Introduction}\n\\label{sec:first}\nTask-oriented dialog system~\\cite{DBLP:journals/corr/abs-2003-07490} aims to assist users in completing  some specific tasks such as table reservations, hotel reservations,  ticket booking, and online shopping.\nTraditional  task-oriented dialog system has been built through  dialog state tracking~\\cite{lee-etal-2019-sumbt,wu-etal-2019-transferable}, dialog policy~\\cite{DBLP:journals/corr/SchulmanWDRK17,takanobu-etal-2019-guided} and natural language generation~\\cite{wen-etal-2015-semantically} tasks.\ndialog state tracking  transfers dialog context to belief state, which is the structured semantic state capturing  the whole dialog context information. The belief state is used for the dialog system to query the database to  obtain  matched entities.\nDialog policy    selects an action state,  a semantic state guiding the dialog system to generate a system response based on the current dialog context and database information. System response is generated through a  natural language generation task.  \n\\begin{figure}[!t]\n  \\centering\n  \\includegraphics[width=3in]{representation.pdf}\n  \\caption{Illustration of the dialog context composition. Context to state represents dialog state tracking and dialog policy tasks. The previous dialog context $\\{C_{t-1},U_{t-1}\\}$ is included in the dialog context $\\{C_{t},U_t\\}$ of turn $t$. The database state is omitted for clarity.}% $t$ represents the dialog turn, $C$ represents  the dialog context, $U$ represents  the  user utterance, $D$ represents  the belief state,  $A$ represents  the action state, and $R$ represents  the system response. } %For clarity, database state is omitted from the figure.}\n  \\label{fig:representation}\n\\end{figure}\n\nWith the widespread application of large-scale pre-training models~\\cite{devlin-etal-2019-bert,radford2019language,2020t5}, researchers gradually focus on the end-to-end task-oriented dialog system~\\cite{lin-etal-2020-mintl,DBLP:conf/nips/Hosseini-AslMWY20,DBLP:conf/aaai/YangLQ21}, which  converts the whole dialog context into system response through multi-task training.\nGenerally, an end-to-end task-oriented dialog modeling task is formulated as a cascaded generation problem~\\cite{DBLP:journals/corr/abs-2109-14739}. \nBefore generating a system response, the end-to-end task-oriented dialog system must first  transfer dialog  context into belief and action states, respectively.  The quality of the belief state and action state greatly influence on the end-to-end task-oriented dialog performance\\footnote{The detailed  analysis is provided in Appendix~\\ref{sec:state}.}.\n\nIn this paper, we explore what dialog context representation is beneficial to improving the quality of the belief/action state, which further enhances the generated response quality.\nAs illustrated in Figure~\\ref{fig:representation}, dialog context is recursively hybrid of previous dialog context and semantic states\\footnote{These previous semantic states are  helpful references for the generation of the current turn~\\cite{DBLP:conf/aaai/YangLQ21}.}, i.e., belief and action states, for multi-turn dialog.  \nIntuitively, the representation of dialog context $\\{C_{t-1},U_{t-1}\\}$, which is more similar with that of semantic states $B_{t-1}/A_{t-1}$, is beneficial to generate semantic states of the  turn $t-1$. However, if their representations are too similar, there may be information redundancy in the representation of dialog context $\\{C_{t},U_{t}\\}$ in  turn $t$, as shown in Figure~\\ref{fig:representation}. Thus we raise another conjecture: whether representations of dialog context, which are more different from that of semantic states, are more conducive to multi-turn task-oriented dialog?\n\nTo tackle our conjectures, we propose \\textbf{Mars}, an end-to-end task-oriented dialog system with two contrastive learning strategies, i.e., pair-aware context\\&state and group-aware context\\&state contrastive learning, to model the relationship between dialog context and semantic states from two different levels.\nSpecifically, (1) the pair-aware context\\&state contrastive learning strategy focuses more on narrowing the gap in the continuous representation space between dialog context and corresponding semantic states for the same dialog turn.\nThis strategy aims to obtain a continuous representation of the dialog context that is  semantically more consistent with that of its semantic states.\n(2) Group-aware context\\&state contrastive learning strategy enlarges the overall continuous representation margin between dialog context and semantic states.\nThe meaning behind this is to make representations between dialog context and semantic states more different.\nExtensive experiments and analysis on the response generation and dialog state tracking tasks verify our raised conjectures and the effectiveness of Mars.\nMars achieves state-of-the-art performance on the MultiWOZ 2.0, CamRest676, and CrossWOZ.   Moreover, Mars  achieves remarkable performance in the low-resource scenario. Finally, we perform detailed error analysis and visualization to better apply our proposed Mars to real-world scenarios.\n\nThis paper primarily makes the following contributions:\n (1) We  explore what dialog context representation is beneficial to improving  task-oriented dialog performance.\n\t(2) We propose two contrastive learning strategies to model the relationship between dialog context and semantic state representations. \n\t(3) Empirical results show   Mars achieves state-of-the-art  performance on the MultiWOZ 2.0, CamRest676, and CrossWOZ.\n\n\\section{Related Work}\nEnd-to-end  task-oriented dialog systems~\\cite{lei-etal-2018-sequicity,zhang-etal-2020-probabilistic,DBLP:conf/aaai/ZhangOY20} are established via copy-augmented seq2seq learning~\\cite{gu-etal-2016-incorporating}.  \\citet{DBLP:conf/aaai/ZhangOY20} proposes a multi-action data augmentation method to improve the diversity of generated system responses.\nLarge-scale pre-trained language models, including  BERT~\\cite{devlin-etal-2019-bert},  GPT-2~\\cite{radford2019language},   T5~\\cite{2020t5}, and UniLM~\\cite{DBLP:conf/nips/00040WWLWGZH19}, have been  demonstrated effective for improving the performance of task-oriented dialog systems~\\cite{DBLP:conf/nips/Hosseini-AslMWY20,peng2020soloist,lin-etal-2020-mintl,DBLP:conf/aaai/YangLQ21,DBLP:journals/corr/abs-2103-06648,DBLP:journals/corr/abs-2111-14592} on MultiWOZ 2.0~\\cite{budzianowski-etal-2018-multiwoz},  a large-scale English multi-domain task-oriented dialog dataset. Recently, auxiliary tasks and auxiliary dialog corpora have been introduced to further improve dialog modeling ability. MTTOD~\\cite{lee-2021-improving-end} introduces a span prediction task to enhance the natural language understanding performance. BORT~\\cite{2021BORTAnonymous} proposes reconstruction strategies to alleviate the error   propagation problem. \nPPTOD~\\cite{DBLP:journals/corr/abs-2109-14739} proposes a dialog multi-task pre-training strategy to model task completion from  auxiliary heterogeneous dialog corpora. \nGALAXY~\\cite{DBLP:journals/corr/abs-2111-14592} introduces a\ndialog act prediction task to explicitly learn dialog policy from auxiliary dialog corpora.\n\nRecently, contrastive Learning~\\cite{DBLP:conf/cvpr/He0WXG20,DBLP:conf/icml/ChenK0H20,DBLP:conf/nips/GrillSATRBDPGAP20,DBLP:conf/cvpr/ChenH21} has attracted much attention in the computer vision community and has been applied to   natural language processing to enhance sentence representation learning~\\cite{DBLP:journals/corr/abs-2005-12766,DBLP:journals/corr/abs-2012-15466,yan-etal-2021-consert,gao-etal-2021-simcse,giorgi-etal-2021-declutr}.  In contrast, we propose  contrastive learning strategies to model the relationship between dialog context and semantic state representations for task-oriented dialog. In addition, we don't introduce data augmentation methods, which are  used in most  contrastive learning works.\n\n\\section{Task-Oriented Dialog Framework}\n\\label{sec:third}\n\nGenerally, an end-to-end task-oriented dialog modeling task is formulated as a cascaded generation problem~\\cite{DBLP:journals/corr/abs-2109-14739}. Before generating a system response, the end-to-end task-oriented dialog system would transfer dialog  context into belief state and action state, respectively.\nBelief state is  a semantic state of dialog context, including dialog domain, slot name, and slot value. \nAction state is a  semantic state of system response, including dialog domain, dialog act, and slot name.  For example, the belief state is `\\textit{[attraction] type theatre}', and the action state is `\\textit{[attraction] [inform] name area}'.%, as shown in Figure~ \\ref{fig:baseline}.\n\nWe construct an end-to-end task-oriented dialog  system  via the seq2seq framework, including one shared encoder and two different decoders,\nas illustrated in Figure \\ref{fig:baseline}.\nOne shared encoder encodes dialog context, one decoder $decoder_b(\\cdot)$ decodes belief state, and  another decoder $decoder_a(\\cdot)$ decodes action state and system response.\n\\begin{figure}[t]\n  \\centering\n  \\includegraphics[width=2.85in]{base.pdf}\n  \\caption{Illustration of a general  task-oriented dialog system. For clarity, we take dialog turn $t=1$ as an example. $C_t$ is formulated as $\\{U_0,B_0,DB_0,A_0,R_0\\}$. [db\\_3] denotes the amount of matched entities.}\n  \\label{fig:baseline}\n\\end{figure}\nConsider a dialog in turn $t$, dialog history $C_t$, which contains  dialog information for all previous turns, is formulated as $\\{C_{t-1},U_{t-1},B_{t-1},DB_{t-1},A_{t-1},R_{t-1}\\}$, where $U$ represents  the  user utterance, $B$ represents  the belief state, $DB$ represents  the database state, $A$ represents  the action state, and $R$ represents  the system response.\n\nFor end-to-end dialog modeling, a belief state is first generated. \nThe dialog history $C_t$ and the  current user utterance $U_t$ are firstly encoded into hidden representation $H_{cb}$ through the shared encoder, and the belief state $B_t$ is generated through the belief state decoder:\n\n{\\footnotesize\n\\setlength{\\abovedisplayskip}{0.005cm}\n\\setlength{\\belowdisplayskip}{0.005cm}\n\\begin{equation}\n\\begin{aligned}\nH_{cb} &= encoder(C_{t},U_t),\\\\\nB_t &= decoder_b(H_{cb}).\\\\\n\\end{aligned}\n\\end{equation}}%\nThe dialog state tracking process is optimized by minimizing the following objective function:\n\n{\\footnotesize\n\\begin{equation}\n\\mathcal{L}_{B} =  -log P(B_t|C_{t},U_t).\n\\end{equation}}%\nWe use the generated belief state $B_t$ to query the specific database to achieve the database state $DB_t$, which means the amount of matched entities.\n\nAs described by MTTOD~\\cite{lee-2021-improving-end}, the second decoder would be used to generate action state and system response simultaneously.\nThe combination of the dialog history $C_t$, the  current user utterance $U_t$, and  the database state $DB_t$ are encoded into hidden representation $H_{ca}$ through the shared encoder. The action state $A_t$  and system response $R_t$  are  generated in turn through the action state decoder:\n\n{\\footnotesize\n\\setlength{\\abovedisplayskip}{0.005cm}\n\\setlength{\\belowdisplayskip}{0.005cm}\n\\begin{equation}\n\\begin{aligned}\nH_{ca} &= encoder(C_{t},U_t,DB_{t}),\\\\\nA_t,R_t &= decoder_a(H_{ca}).\\\\\n\\end{aligned}\n\\end{equation}}%\n Therefore, the action state  and  response generation process is optimized by minimizing the following objective function:\n \n {\\footnotesize\n\\setlength{\\abovedisplayskip}{0.005cm}\n\\setlength{\\belowdisplayskip}{0.005cm}\n\\begin{equation}\n\\mathcal{L}_{AR} =   -log P(A_t,R_t|C_{t},U_t,DB_{t}).\n\\end{equation}}%\n In summary, the entire end-to-end task-oriented dialog system can be optimized by minimizing:\n \n {\\footnotesize\n \\setlength{\\abovedisplayskip}{0.005cm}\n\\setlength{\\belowdisplayskip}{0.005cm}\n\\begin{equation}\n\\begin{aligned}\n\\mathcal{L}_{all} = \\mathcal{L}_{B} + \\mathcal{L}_{AR}.\n\\end{aligned}\n\\end{equation}}%\n\\section{Methodology}\n\n\\begin{figure*}[t]\n  \\centering\n  \\includegraphics[width=6.2in]{methods.pdf}\n  \\caption{Illustration of the  task-oriented dialog system with contrastive learning strategies. We take dialog turn $t=0$ and batch size $N=3$ as an example.}  %For dialog context in the pairwise contrastive learning method, the dialog/ action states of the same color are taken  as positive samples, and the dialog/ action states of the different colors are taken  as negative samples. For dialog context in the decoupled contrastive learning method, any  other dialog context in the same batch is taken  as a positive sample, and all dialog/ action states  are taken  as negative samples.}\n  \\label{fig:methods}\n\\end{figure*}\n\nTo tackle our conjectures and enhance the relationship modeling between dialog context and corresponding semantic state representations of   the task-oriented dialog system  described in Section~\\ref{sec:third}, we propose two contrastive learning methods: pair-aware context\\&state and group-aware context\\&state  contrastive learning. Figure \\ref{fig:methods} illustrates the architecture of a task-oriented dialog system with our  proposed  methods.\nGenerally, for any contrastive learning method,  contrastive learning objective functions $\\mathcal{L}_{bscl}$ and $\\mathcal{L}_{ascl}$ are added for dialog state tracking and response generation tasks, respectively, to enhancing the relationship modeling between dialog context and semantic state representations  during end-to-end dialog training. The general objective function can be reformulated as follows:\n\n{\\footnotesize\n\\setlength{\\abovedisplayskip}{0.005cm}\n\\setlength{\\belowdisplayskip}{0.005cm}\n\\begin{equation}\n\\begin{aligned}\n\\mathcal{L}_{all} &= \\mathcal{L}_{B'} + \\mathcal{L}_{AR'},\\\\\n\\mathcal{L}_{B'} &= \\mathcal{L}_{B} +\\lambda_{1}\\mathcal{L}_{bscl} ,\\\\\n\\mathcal{L}_{AR'} &= \\mathcal{L}_{AR} + \\lambda_{2}\\mathcal{L}_{ascl},\\\\\n\\end{aligned}\n\\end{equation}}%\nwhere $\\lambda_{1}$ and $\\lambda_{2}$ are hyper-parameters that adjust the weight of the  objective functions.\n\\subsection{Pair-aware Context\\&State Contrastive Learning}\nTo achieve dialog context representation, which is  semantically more consistent with  its semantic state representation,  we propose a pair-aware context\\&state contrastive learning strategy (Mars-P) to close the continuous representation gap between  dialog context $\\{C_t,U_t\\}$ and corresponding semantic states, including belief state $B_t$  and action state $A_t$, for the same dialog turn.\n\nWe consider the dialog context $\\{C_t,U_t\\}$ and the belief state $B_t$ from the same dialog  to be as consistent as possible in the representation space, while the dialog context is as far away from other belief states as possible.\nAs illustrated in Figure~\\ref{fig:methods}, the source continuous representation of the dialog context `\\textit{can you find a theater to go to in town?}' should be similar to that of the belief state `\\textit{[attraction] type theatre}' rather than other belief states  `\\textit{[attraction] type college}' and `\\textit{[restaurant] name la margherita}'.\n\nSpecifically, the belief state $B_t$ would be encoded into a hidden representation $H_{bb}$ through the shared encoder:\n\n{\\footnotesize\n\\setlength{\\abovedisplayskip}{0.005cm}\n\\setlength{\\belowdisplayskip}{0.005cm}\n\\begin{equation}\n\\begin{aligned}\nH_{bb} &= encoder(B_{t}).\\\\\n\\end{aligned}\n\\end{equation}}%\nFor every dialog context input in a batch, we treat  the corresponding belief state from the same dialog  as a positive sample and other belief states and dialog contexts in the same batch as  negative samples.\nTherefore, this dialog model is optimized by minimizing the objective function:\n\n{\\footnotesize\n\\setlength{\\abovedisplayskip}{0.005cm}\n\\setlength{\\belowdisplayskip}{0.005cm}\n\\begin{equation}\n\\begin{aligned}\n\\mathcal{L}_{bscl} &\\triangleq \\mathcal{L}_{bscl\\_P}\\\\&= -log \\frac{e^{cos(H_{cb}^i, H_{bb}^i)/T}}{\\sum\\limits_{\\substack{k=1\\\\k\\neq i}}^{N}\\! e^{cos(H_{cb}^i,H_{cb}^k)/T} \\!+ \\!\\sum\\limits_{k=1}^{N}\\! e^{cos(H_{cb}^i,H_{bb}^k)/T}},\n\\end{aligned}\n\\end{equation}}%\nwhere $cos(\\cdot)$ denotes the cosine similarity function. $T$ is a temperature hyperparameter. $N$ is the batch size.\nIn a batch, $H_{cb}^i$ denotes the $i$th dialog context hidden representation after average pooling, and $H_{bb}^k$ denotes the $k$th  belief state hidden representation after average pooling.\n\nDuring response generation,  %the dialog history $C_t$, the  current user utterance $U_t$ and  the database state $DB_t$ are taken as the dialog context to generate the action state $A_t$ and system response $R_t$.\nwe would close the continuous representation gap of dialog context $\\{C_t,U_t,DB_t\\}$ and action state $A_t$. \nAs illustrated in Figure~\\ref{fig:methods}, the source continuous representation of the user utterance `\\textit{i am looking for a restaurant called la margherita.}' \nand database information `\\textit{[$db_1$]}' should be similar to that of the action state `\\textit{[restaurant] [inform] food price area [general] [reqmore]}' rather than other action states  `\\textit{[attraction] [request] area}' and `\\textit{[attraction] [select] area [inform] type choice}'.\nSpecifically, the action state $A_t$ would be encoded into a hidden representation $H_{aa}$ through the shared encoder:\n\n{\\footnotesize\n\\setlength{\\abovedisplayskip}{0.005cm}\n\\setlength{\\belowdisplayskip}{0.005cm}\n\\begin{equation}\n\\begin{aligned}\nH_{aa} &= encoder(A_{t}).\\\\\n\\end{aligned}\n\\end{equation}}%\nFor every dialog context input  in a batch, we treat the corresponding action state from the same dialog  as  a positive sample and other action states and dialog contexts in the same batch as  negative samples.\nTherefore, this dialog model is optimized by minimizing the objective function:\n\n{\\footnotesize\n\\setlength{\\abovedisplayskip}{0.005cm}\n\\setlength{\\belowdisplayskip}{0.005cm}\n\\begin{equation}\n\\begin{aligned}\n\\mathcal{L}_{ascl} &\\triangleq \\mathcal{L}_{ascl\\_P}\\\\&= -log \\frac{e^{cos(H_{ca}^i, H_{aa}^i)/T}}{\\sum\\limits_{\\substack{k=1\\\\k\\neq i}}^{N}\\! e^{cos(H_{ca}^i,H_{ca}^k)/T} \\!+ \\!\\sum\\limits_{k=1}^{N}\\! e^{cos(H_{ca}^i,H_{aa}^k)/T}},\n\\end{aligned}\n\\end{equation}}%\nwhere $H_{ca}^i$ denotes the $i$th dialog context hidden representation after average pooling, and $H_{aa}^k$  denotes the $k$th  action state hidden representation after average pooling.\n\n\\subsection{Group-aware Context\\&State  Contrastive Learning}\nTo explore whether representations of dialog context, which are more different from that of semantic states, are more conducive to multi-turn task-oriented dialog, \n we propose a group-aware context\\&state contrastive learning strategy (Mars-G). \nTakes turn $t$ as an example,\nMars-G enlarges the overall continuous representation margin between dialog context and semantic states, regardless of the pairing relationship between specific dialog context, e.g., $\\{C_i,U_i\\}$, and semantic states, e.g.$B_i/A_i$ (turn $i=0,...,t$).\nThe meaning behind is to make representations between dialog context and semantic states more different, which makes it easy to distinguish dialog context $\\{C_i,U_i\\}$ and the corresponding semantic states $B_i/A_i$ (turn $i=0,...,t$) inside the entire dialog context $\\{C_{t+1},U_{t+1}\\}$ and achieve much richer dialog context representations.\n\nSpecifically, for every dialog context input, we treat all semantic states in the same batch as negative samples and any one dialog context in the same batch as a positive sample.\nBesides, considering that every dialog input contains a unique context, narrowing the in-batch context distance makes it hard to distinguish different contexts, which may be counterproductive to deriving  the context representation. To resolve such an issue, we also select the rest in-batch dialog context inputs except the positive one as negative samples for every dialog context input.\nTherefore,  the contrastive learning objective function can be reformulated as:\n\n{\\footnotesize\n\\setlength{\\abovedisplayskip}{0.005cm}\n\\setlength{\\belowdisplayskip}{0.005cm}\n\\begin{equation}\n\\begin{aligned}\n\\mathcal{L}_{bscl} &\\triangleq \\mathcal{L}_{bscl\\_G}\\\\&= -log \\frac{e^{cos(H_{cb}^i, H_{cb}^j)/T}}{\\sum\\limits_{\\substack{k=1\\\\k\\neq i}}^{N}\\! e^{cos(H_{cb}^i,H_{cb}^k)/T} \\!+ \\!\\sum\\limits_{k=1}^{N}\\! e^{cos(H_{cb}^i,H_{bb}^k)/T}},\n\\end{aligned}\n\\end{equation}%\n\\begin{equation}\n\\begin{aligned}\n\\mathcal{L}_{ascl} &\\triangleq \\mathcal{L}_{ascl\\_G}\\\\&= -log \\frac{e^{cos(H_{ca}^i, H_{ca}^j)/T}}{\\sum\\limits_{\\substack{k=1\\\\k\\neq i}}^{N}\\! e^{cos(H_{ca}^i,H_{ca}^k)/T} \\!+ \\!\\sum\\limits_{k=1}^{N}\\! e^{cos(H_{ca}^i,H_{aa}^k)/T}},\n\\end{aligned}\n\\end{equation}}%\nwhere $H_{cb}^j$ and $H_{ca}^j$ denote the $j$th ($j \\neq i$) dialog context hidden representations after average pooling.\n\n\\iffalse\n\\begin{table*}[ht]\n  \\centering\n  \\scalebox{1}{\n\t\\begin{tabular}{lccccc}\n\t\t\\toprule\n\t\\bf Model &\\bf Pre-trained  & \\bf Inform & \\bf Success & \\bf BLEU & \\bf Combined\\\\ \n\t\t\\midrule\n\t\tDAMD~\\cite{DBLP:conf/aaai/ZhangOY20}&-&57.9 &47.6 & 16.4 &69.2\\\\%69.15\\\\\n\t\t\t\tLABES~\\cite{zhang-etal-2020-probabilistic}&-&68.5&58.1&18.9&82.2\\\\\n\t\t\t\tAuGPT~\\cite{DBLP:journals/corr/abs-2102-05126}&GPT-2&76.6&60.5&16.8&85.4\\\\%paper reading\n\t\tMinTL~\\cite{lin-etal-2020-mintl}& T5-small&73.7&65.4&19.4 &89.0\\\\%88.95\\\\\n\t\t\n\t\tSOLOIST~\\cite{peng2020soloist}&GPT-2& 82.3&72.4&13.6&91.0\\\\%90.95\\\\\n\t\t\n\t\tDoTS~\\cite{DBLP:journals/corr/abs-2103-06648}&BERT-base&80.4&68.7&16.8&91.4\\\\%91.35\\\\\n\t\tUBAR~\\cite{DBLP:conf/aaai/YangLQ21}  &DistilGPT2 & 83.4&70.3&17.6 & 94.5\\\\%94.45\\\\\n     PPTOD~\\cite{DBLP:journals/corr/abs-2109-14739}&T5-base&83.1&72.7&18.2&96.1\\\\\n\t\t\tMTTOD~\\cite{lee-2021-improving-end}&T5-base& 85.9&76.5&19.0&100.2   \\\\\n\t\t\t\t\t\tGALAXY~\\cite{DBLP:journals/corr/abs-2111-14592}&UniLM-base &85.4&75.7& 19.6 & 100.2\\\\ \n\t\t   \\cdashline{1-6}[1pt/2pt]\n           BORT& T5-small&85.5 &   77.4 & 17.9 &  99.4 \\\\\n\t\t   Mars& T5-small &\\bf88.9& \\bf 78.0&\\bf 19.9& \\bf 103.4\\\\\n\n\t\t\\bottomrule\n\t\\end{tabular}}\\caption{Comparison of end-to-end models evaluated on MultiWOZ 2.0. The results of previous work are reported on the official leaderboard of MultiWOZ.  \\label{tab:main_results}}\n\\end{table*}\n\\fi\n\n\\begin{table*}[ht]\n  \\centering\n  \\scalebox{.65}{\n\t\\begin{tabular}{lcccccccc}\n\t\t\\toprule\n\t\t\\multirow{2}{*}{\\bf Model} &\\multirow{2}{*}{\\bf Pre-trained} &\\multirow{2}{*}{\\bf Extra corpora}&\\multicolumn{1}{c}{\\bf  Dialog state tracking}&\\multicolumn{5}{c}{\\bf Response Generation}\\\\  %\\cmidrule(l){4}\n\t\t\n\t&  &\t& \\bf Joint Accuracy & \\bf Act F1& \\bf Inform & \\bf Success & \\bf BLEU & \\bf Combined\\\\ \n\t\t\\midrule\n\t\tDAMD~\\cite{DBLP:conf/aaai/ZhangOY20}&-&no &-&-&57.9 &47.6 & 16.4 &69.2\\\\%69.15\\\\\n\t\t\t\tLABES~\\cite{zhang-etal-2020-probabilistic}&-&no&-&-&68.5&58.1&18.9&82.2\\\\\n\t\t\t\tAuGPT~\\cite{DBLP:journals/corr/abs-2102-05126}&GPT-2&yes&-&-&76.6&60.5&16.8&85.4\\\\%paper reading\n\t\tMinTL~\\cite{lin-etal-2020-mintl}& T5-small&no&51.2&-&73.7&65.4&19.4 &89.0\\\\%88.95\\\\\n\t\t\n\t\tSOLOIST~\\cite{peng2020soloist}&GPT-2&yes&53.2&-& 82.3&72.4&13.6&91.0\\\\%90.95\\\\\n\t\t\n\t\tDoTS~\\cite{DBLP:journals/corr/abs-2103-06648}&BERT-base&no&-&-&80.4&68.7&16.8&91.4\\\\%91.35\\\\\n\t\tUBAR~\\cite{DBLP:conf/aaai/YangLQ21}  &DistilGPT2&no&52.6 &-&  83.4&70.3&17.6 & 94.5\\\\%94.45\\\\\n     PPTOD~\\cite{DBLP:journals/corr/abs-2109-14739}&T5-base&yes&53.4&-&83.1&72.7&18.2&96.1\\\\\n\t\tBORT~\\cite{2021BORTAnonymous}& T5-small&no&54.0&-& 85.5 &   77.4 & 17.9 &  99.4 \\\\\n\t\t\tMTTOD~\\cite{lee-2021-improving-end}&T5-base&no&53.6&-& 85.9&76.5&19.0&100.2   \\\\\n\t\t\t\t\t\tGALAXY~\\cite{DBLP:journals/corr/abs-2111-14592}&UniLM-base &yes &-&-&85.4&75.7& 19.6 & 100.2\\\\ \n\t\t   \\cdashline{1-9}[1pt/2pt]\n\t\t    Baseline& T5-small&no&53.8&53.0&      83.2&70.3&19.4&96.2\\\\   \n\t\t    Mars-P& T5-small&no&  54.4 & \\bf 53.9  &  86.6&  75.5& 19.6 &100.7\\\\\n\n\t\t   Mars-G& T5-small&no&\\bf 55.1 & 53.7&\\bf88.9& \\bf 78.0&\\bf 19.9& \\bf 103.4\\\\\n\n\t\t\\bottomrule\n\t\\end{tabular}}\\caption{Comparison of end-to-end models evaluated on MultiWOZ 2.0. The results of previous work are reported on the official leaderboard of MultiWOZ (\\url{https://github.com/budzianowski/multiwoz}).  \\label{tab:main_results}}\n\\end{table*}\n\\section{Experiments}  \n\\label{sec:experiments}\n\\subsection{Datasets and Evaluation Metrics}\n\\label{sec:evaluation}\nWe conduct experiments on three task-oriented dialog datasets: MultiWOZ 2.0~\\cite{budzianowski-etal-2018-multiwoz},  CamRest676~\\cite{wen-etal-2017-network}, and CrossWOZ~\\cite{zhu-etal-2020-crosswoz}. \nMultiWOZ 2.0~\\cite{budzianowski-etal-2018-multiwoz} and CamRest676~\\cite{wen-etal-2017-network} are English task-oriented dialog datasets. \nCrossWOZ~\\cite{zhu-etal-2020-crosswoz} is a Chinese multi-domain task-oriented dialog dataset.\nA detailed description  of the datasets is provided in Appendix~\\ref{sec:dataset}.\n\nWe test our proposed Mars on two benchmark task-oriented dialog tasks: end-to-end dialog modeling response generation  and dialog state tracking. We evaluate the performance of response generation on MultiWOZ 2.0 and CamRest676.\nInconsistencies exist between previous task-oriented dialog works  in data preprocessing and evaluation metrics on  MultiWOZ 2.0~\\cite{nekvinda-dusek-2021-shades}.\nTo fairly compare  our experiments with previous work,  we use the pre-processing strategy~\\cite{DBLP:conf/aaai/ZhangOY20} and  the standalone standardized evaluation script released by ~\\citet{nekvinda-dusek-2021-shades}. We follow the automatic evaluation metrics to evaluate the response quality for  task-oriented dialog system on MultiWOZ 2.0.\n\\textbf{Inform  rate} measures whether  a dialog system has provided an accurate entity; \\textbf{Success rate} measures whether a dialog system has provided an accurate entity and answered all requested information; \\textbf{BLEU score}~\\cite{papineni-etal-2002-bleu}, which is computed with references, which have been obtained from the delexicalized MultiWOZ 2.2 span annotations, measures  the fluency of the generated response; \\textbf{Combined score}, which is calculated  by $ (Inform + Success) \\times 0.5 + BLEU$, measures the overall quality of the dialog system. Moreover, we use the \\textbf{Act F1} to measure the accuracy of generated action states.\nTo make our experiments comparable with previous work \\cite{zhang-etal-2020-probabilistic,DBLP:journals/corr/abs-2111-14592} on CamRest676,\nwe use the same pre-processing strategy and use \\textbf{Inform  rate}, \\textbf{Success F1}, \\textbf{BLEU score}, and \\textbf{Combined score}, which is computed by $ (Inform + Success F1) \\times 0.5 + BLEU$, to evaluate the response quality for the task-oriented dialog system. The  success rate\nwhether if the system answered all requested\ninformation to assess  recall, while Success F1 balances recall and precision.\n\nWe evaluate the performance of dialog state tracking on MultiWOZ 2.0 and CrossWOZ. We use the \\textbf{joint goal accuracy} to measure the accuracy of generated belief states.\n\n\\subsection{Settings}\nWe use a pre-trained T5 language model~\\cite{2020t5} to initialize the dialog system based on the HuggingFace Transformers library~\\cite{wolf-etal-2020-transformers} and follow the settings of ~\\citet{lee-2021-improving-end}. %There are six layers for the encoder and the decoder. The dimension of hidden layers is set to 512, and the head of attention is 8. \nWe select   T5-small~\\cite{2020t5} for MultiWOZ 2.0 and CamRest676 and T5-base-Chinese~\\cite{2020t5,zhao-etal-2019-uer} for CrossWOZ.\nThe batch size is  8. \nThe AdamW optimizer~\\cite{DBLP:conf/iclr/LoshchilovH19} optimizes  the model parameters with linear learning rate decay. The initial learning rate is 0.0005, and the ratio of warm up is 0.2.\nThe hyper-parameters $\\lambda_{1}$ and $\\lambda_{2}$ are set to 1 and 0.1, respectively. $T$ is set to 0.1 for Mars-P, and $T$ is set to 0.5 for Mars-G. The hyper-parameter  analysis is provided in Appendix~\\ref{sec:parameter}.\nWe train all dialog systems on one NVIDIA A100 GPU  for 10 epochs and select the checkpoint model with the best performance on the validation dataset.  One model is trained for approximately five hours. In addition, the model is trained for 20 epochs for the  low resource scenarios.\n  The description  of baseline systems is provided in Appendix~\\ref{sec:baseline}. Another baseline is the general architecture of a task-oriented dialog system, as illustrated in Figure~\\ref{fig:baseline}.\n\n\\subsection{Main Results}\n\n\\begin{figure}[!t]\n\t\\centering\n\t\\subfigure{  \\begin{minipage}[b]{0.3\\linewidth}\n\\includegraphics[width=\\columnwidth]{base_100_belief.jpg}\n\t\t\\end{minipage}\n\t\t\n\t}\n\t\\subfigure{\n\t\t\\begin{minipage}[b]{0.3\\linewidth}\n\\includegraphics[width=\\columnwidth]{mars_p_100_belief.jpg}\n\t\t\\end{minipage}\n\t}\n\t\\subfigure{\n\t\t\\begin{minipage}[b]{0.3\\linewidth}\n\\includegraphics[width=\\columnwidth]{mars_g_100_belief.jpg}\n\t\t\\end{minipage}\n\t}\n\t\t\\subfigure{\n\t\t\\begin{minipage}[b]{0.3\\linewidth}\n\\includegraphics[width=\\columnwidth]{base_100_action.jpg}\n\t\t\\end{minipage}\n\t}\n\t\\subfigure{\n\t\t\\begin{minipage}[b]{0.3\\linewidth}\n\\includegraphics[width=\\columnwidth]{mars_p_100_action.jpg}\n\t\t\\end{minipage}\n\t}\n\t\\subfigure{\\begin{minipage}[b]{0.3\\linewidth}\n\\includegraphics[width=\\columnwidth]{mars_g_100_action.jpg}\n\t\t\\end{minipage}\n\t}\n\\caption{Visualization of dialog context and semantic state representations using t-sne. The three sub-figures on the first row show baseline/Mars-P/Mars-G representations of dialog context and dialog state. The three sub-figures on the second row show baseline/Mars-P/Mars-G representations of dialog context and action state. The coral dots denote dialog context representations. The plum dots denote semantic state representations.  We plot 100 dialog examples.}\\label{tsne}\n\\end{figure}\n\nThe detailed inform rates, success rates, BLEU scores, combined scores, act F1 scores, and joint goal accuracies for end-to-end task-oriented dialog models on the MultiWOZ 2.0 benchmark are presented in Table~\\ref{tab:main_results}. \nOur re-implemented baseline system performs comparable with PPTOD~\\cite{DBLP:journals/corr/abs-2109-14739}, \nand our proposed Mars-P and Mars-G outperform our re-implemented baseline system  by 4.5 and 7.2 combined scores.\nMoreover,  Mars-G, which doesn't use auxiliary corpora, substantially outperforms the previous state-of-the-art GALAXY~\\cite{DBLP:journals/corr/abs-2111-14592} and \tMTTOD~\\cite{lee-2021-improving-end} by 3.2 combined scores, achieving the state-of-the-art performance in terms of inform rate, success rate, BLEU score, and combined score.  In addition, Mar-G achieves the highest joint goal accuracy among the end-to-end task-oriented dialog systems, outperforming BORT~\\cite{2021BORTAnonymous} by 1.1 points.  Compared with the baseline system, Mars-P and  Mars-G achieve a better act F1 score.\nThis demonstrates  our proposed contrastive learning could effectively improve the quality of the belief state and action state, which further improves  the generated response quality. \nRegarding the two proposed methods, Mars-G performs  better than Mars-P. \nFigure~\\ref{tsne} displays the visualization of dialog context and semantic state representations using t-sne.  Compared with the baseline system, Mars-P could achieve dialog context representation that is  semantically more consistent with  its semantic state representation while\nMars-G could make representations between dialog context and semantic states more different.\nThese verify dialog context representations, which are more different from  semantic state representations, are more beneficial to achieving  task completion of task-oriented dialog.\nFurther dialog context representation analysis  is provided in   Appendix~\\ref{sec:Further}.\n \n\n\\begin{table}[!t]\n  \\centering\n  \\scalebox{.6}{\n\t\\begin{tabular}{lcccc}\n\t\t\\toprule\n\t\t\\bf Model  & \\bf Match & \\bf Success F1& \\bf BLEU & \\bf Combined\\\\ \n\t\t\\midrule\nSequicity~\\cite{lei-etal-2018-sequicity}& 92.7  &85.4& 25.3 &114.4 \\\\\n\t\tLABES~\\cite{zhang-etal-2020-probabilistic} &   96.4  &  82.3 &  25.6 &  115.0 \\\\\n\t\tSOLOIST~\\cite{peng2020soloist} &94.7 & 87.1 &25.5& 116.4 \\\\\n GALAXY~\\cite{DBLP:journals/corr/abs-2111-14592}&\\bf 98.5&87.7&24.2&\t117.3\\\\\n        \\cdashline{1-5}[1pt/2pt]\n\n        Mars-P & 97.0 & 87.2 &  25.9 & 118.0\\\\\n         Mars-G& 96.2&\\bf 89.6&  \\bf 26.1& \\bf 119.0\\\\\n\n\t\t\\bottomrule\n\t\\end{tabular}}\\caption{Comparison of end-to-end  task-oriented dialog systems on CamRest676.\\label{tab:camrest}}\n\\end{table}\n\nTable~\\ref{tab:camrest} presents the performance of task-oriented dialog systems on the CamRest676. Mars-G outperforms the previous state-of-the-art GALAXY~\\cite{DBLP:journals/corr/abs-2111-14592} by 1.7 combined scores, achieving the state-of-the-art performance in terms of success F1, BLEU score, and combined score. %This indicates the generalization ability  of Mars.\n\n\\begin{table}[!t]\n  \\centering\n  \\scalebox{.62}{\n\t\\begin{tabular}{lc}\n\t\t\\toprule\n\t\t\\bf Model & \\bf Joint Accuracy \\\\ \n\t\t\\midrule\n\t\tTRADE~\\cite{wu-etal-2019-transferable}&36.1\\\\\n\t\tBART-CSP~\\cite{DBLP:journals/corr/abs-2111-02574}&53.6\\\\\nGEEX~\\cite{li-etal-2021-generation}&54.7\\\\\n\t\t\\cdashline{1-2}[1pt/2pt]\n\t\tMars-P&  59.3  \\\\\nMars-G& \\bf 59.8 \\\\\n\t\t\\bottomrule\n\t\\end{tabular}}\\caption{Comparison of dialog state tracking performance on CrossWOZ.\\label{tab:dst}}\n\\end{table}\n\nTable~\\ref{tab:dst} reports the dialog state tracking performance  on CrossWOZ.   Mars-P and Mars-G substantially outperform the previous state-of-the-art GEEX~\\cite{li-etal-2021-generation}  by  4.6 and 5.1 points, achieving 59.3 and 59.8 joint goal accuracy. This further indicates that our proposed  contrastive learning strategies could improve belief state learning ability, and Mars has good generalization ability. In addition, we provide an example to visualize  our proposed Mars-G's dialog state tracking process in  Appendix~\\ref{app:vis}.\n\n\\subsection{Ablation Study}\n\\iffalse\n\\begin{table}[h]\n  \\centering\n  \\scalebox{.65}{\n\t\\begin{tabular}{lcccc}\n\t\t\\toprule\n\t\t\\bf Model & \\bf Inform & \\bf Success & \\bf BLEU & \\bf Combined\\\\ \n\t\t\\midrule\n\nBaseline& 83.2&70.3&19.4&96.2\\\\\n\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;w/ DSC&86.3&75.1&19.7&100.4\\\\\n\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;w/ ASC &88.3&76.6&19.5& 102.0 \\\\\nMars (w/ DSC \\& ASC)&88.9 & 78.0 & 19.9 & 103.4\\\\\n\t\t\\bottomrule\n\t\\end{tabular}}\\caption{The performance of the different components of our proposed Mars on MultiWOZ 2.0. w/ DSC denotes belief state  contrastive learning strategy, w/ ASC denotes action state  contrastive learning strategy.\\label{tab:ablation}}\n\\end{table}\n\\fi\nTable~\\ref{tab:ablation} shows the performance of the different components of  Mars-P and Mars-G. Both state  modules of Mars-P and Mars-G could improve the performance of the  dialog system.\nRegarding  two modules of contrastive learning strategies Mars-P and Mars-G, the action state  module performs  better than the belief state  module by 1.7 and  1.6 combined scores, respectively, because the quality of the  action state has a  more direct impact on the response generation quality and action state  module could improve action state learning ability. \nMoreover, the combination of both modules  can complement each other to further improve end-to-end dialog modeling performance. The further ablation analysis  is provided in   Appendix~\\ref{app:sim}.\n\n\\begin{table}[!t]\n  \\centering\n  \\scalebox{.59}{\n\t\\begin{tabular}{lcccc}\n\t\t\\toprule\n\t\t\\bf Model & \\bf Inform & \\bf Success & \\bf BLEU & \\bf Combined\\\\ \n\t\t\\midrule\nMars-G&88.9 & 78.0 & 19.9 & 103.4\\\\\n\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;w/o BSC &88.3&76.6&19.5& 102.0 \\\\\n\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;w/o ASC&86.3&75.1&19.7&100.4\\\\\n\n\\midrule\nMars-P&86.6&75.5&19.6&100.7\\\\\n\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;w/o BSC & 85.4 & 75.0& 19.7 & 99.9 \\\\\n\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;w/o ASC&83.7& 73.0& 19.8&98.2\\\\\n\n\\midrule\nBaseline& 83.2&70.3&19.4&96.2\\\\\n\n\t\t\\bottomrule\n\t\\end{tabular}}\\caption{The performance of the different components of our proposed methods on MultiWOZ 2.0.  BSC represents  the belief state  module of contrastive learning,  and ASC represents  the action state module.\\label{tab:ablation}}\n\\end{table}\n\n\\begin{table*}[ht]\n   \\small\n   \\centering\n   \\scalebox{.625}{\n\t\\begin{tabular}{lcccccccccccccccc}\n\t\t\\toprule\n\t\t\\multirow{2}*{\\bf Model} &\\multicolumn{4}{c}{\\bf 5\\% } &\\multicolumn{4}{c}{\\bf 10\\% } &   \\multicolumn{4}{c}{\\bf 20\\%}&  \\multicolumn{4}{c}{\\bf 50\\% }\\\\ \n\\cmidrule(lr){2-5} \\cmidrule(lr){6-9} \\cmidrule(lr){10-13} \\cmidrule(lr){14-17} \n\t\t& \\bf Inform  & \\bf Success & \\bf BLEU & \\bf Combined& \\bf Inform  & \\bf Success & \\bf BLEU& \\bf Combined& \\bf Inform  & \\bf Success & \\bf BLEU& \\bf Combined& \\bf Inform  & \\bf Success & \\bf BLEU& \\bf Combined\\\\ \n\t\t\\midrule\n\nDAMD &   36.8&   17.3&  11.2&   38.3& 40.9  &23.0   & 12.2  &    44.2&  48.3 & 30.3 &   14.2&  53.5&  58.8    & 44.3  &15.7    &67.3   \\\\\nMinTL &  52.5 & 38.1 & 13.9 &59.2  &55.5  & 44.9  & 15.6 &65.8  &  64.3 & 54.9  &  16.2& 75.8 & 70.3&  62.2 & 18.0  &  84.3  \\\\\nUBAR & 37.4 & 22.1 & 11.3  & 41.1  &  50.3& 34.2&  13.5 &55.8 & 65.5  & 48.7  &14.5   &71.6   &77.6   & 63.3  & 16.3  & 86.8 \\\\  \nMTTOD   & 54.3&37.4& 11.3  & 57.2&   66.9&  55.2 & 13.8  &  74.9  & 75.0&  \\bf 63.3& 14.3    &  83.5 & 78.5 &  67.5 &  15.2  &  88.2       \\\\\nPPTOD &    \\bf 65.5&    \\bf  48.3    & \\bf 14.3&   \\bf 71.2       &   68.3 &  53.7&  \\bf 15.7  &76.7& 72.7& 59.2&16.3&82.3&  74.8 &  62.4& 17.0&85.6 \\\\\n\\cdashline{1-17}[1pt/2pt]\nMars-G    &  57.6  & 43.4 & 13.9 & 64.4& \\bf 69.4 & \\bf 55.3  & 15.6 &  \\bf 78.0 & \\bf 76.7  &  62.9 &  \\bf 17.2 & \\bf  87.0&  \\bf  82.2& \\bf 71.2 &  \\bf 18.6 & \\bf 95.3     \\\\\n\n\t\n\t\n\t\t\\bottomrule\n\t\\end{tabular}}\\caption{Comparison of task-oriented dialog systems  in the low resource scenarios on  MultiWOZ 2.0. 5\\% (400 dialogs), 10\\% (800 dialogs), 20\\% (1600 dialogs),   50\\% (4000 dialogs) of training data is used to train each model.\\label{tab:low_resource}}\n\t\n\n\\end{table*}\n\\subsection{ Dialog Turn Analysis}\n\n\\begin{figure}[!t]\n\n\t\\setlength{\\abovecaptionskip}{0pt}\n\t \t\\begin{center}\n\t \t  \\scalebox{.95}{\n\t\t\t\\pgfplotsset{height=5.6cm,width=8.5cm,compat=1.14,every axis/.append style={thick},every axis legend/.append style={\nat={(0.53,0.37)}},legend columns=1}\n\t\t\\scalebox{.88}{\t\\begin{tikzpicture}\n\t\t\t\\tikzset{every node}=[font=\\small]\n\t\t\t\\begin{axis}\n\t\t\t[width=7cm,enlargelimits=0.13, tick align=outside, xticklabels={ {(0,4]},{(4,8]},{(8,12]},{(12,20)}},\n axis y line*=left,\nxtick={0,1,2,3},\n ylabel={Inform Rate},\n axis x line*=left, \n ylabel style={align=left},xlabel={ Dialog Turns},ymax=100,ymin=40,font=\\small]\n\t\t\t\\addplot+ [sharp plot,mark=square*,mark size=1.2pt,mark options={solid,mark color=gray}, color=gray] coordinates \n\t\t\t{ (0,97.6)(1,84.7)(2,75.4)(3,55.0) };\\label{plot_bb}\n\t\t\t\\addlegendentry{\\tiny Baseline Inform Rate} \n\t\t\t\t\t\t\\addplot+ [sharp plot,mark=square*,mark size=1.2pt,mark options={solid,mark color=purple}, color=purple] coordinates\n\t\t\t{ (0,99.2)(1,89.2)(2,84.9)(3,70.0) };\\label{plot_aa}\n\t\t\t\\addlegendentry{\\tiny Mars-G Inform Rate}\n\n\\end{axis}\n\\begin{axis}\n[width=7cm,enlargelimits=0.13, tick align=outside,  xticklabels={ {(0,4]},{(4,8]},{(8,12]},{(12,20)}},\naxis y line*=right,\naxis x line=none,\nxtick={0,1,2,3},  \n ylabel={Success Rate},xlabel={ Dialog Turns},ymax=100,ymin=40,font=\\small]\n \n\\addlegendimage{/pgfplots/refstyle=plot_bb}\\addlegendentry{\\tiny Baseline Inform Rate} \n\\addlegendimage{/pgfplots/refstyle=plot_aa}\\addlegendentry{\\tiny Mars-G Inform Rate}\n\t\t\\addplot+ [sharp plot,densely dashed,mark=triangle*,mark size=1.2pt,mark options={solid,mark color=gray}, color=gray] coordinates\n\t\t\t{ (0,85.0 )(1,74.2)(2,57.4)(3,40.0) };\n\t\t\t\\addlegendentry{\\tiny Baseline Success Rate}\n\t\t\t\t\t\t\\addplot+ [sharp plot,densely dashed,mark=triangle*,mark size=1.2pt,mark options={solid,mark color=purple}, color=purple] coordinates\n\t\t\t{ (0,91.3)(1,79.0)(2,71.0)(3,60.0) };\n\t\t\t\\addlegendentry{\\tiny Mars-G Success Rate}\n\t\t\t\n\t\t\t\\end{axis}\n\t\t\t\\end{tikzpicture}}}\n\n\t\t\\end{center}\n  \t\t\\caption{Performance of dialog systems on the test set with respect to  different dialog turns.  }\\label{fig:turn}\n\\end{figure} \n\nTo better assess the effectiveness of  our proposed  contrastive learning strategies, we investigate the performance (inform rate and success rate) of Mars-G and the baseline system on the test set with respect to different dialog turns.  Specifically, we divide\neach test set into four groups according to the dialog turn. As shown in Figure~\\ref{fig:turn}, Mars-G is superior to the baseline system in every dialog turn group. This indicates our proposed contrastive learning strategies are  beneficial to task-oriented dialog modeling. Especially, as dialog turn increases, the performance of the baseline system\ndecreases rapidly, and the performance gap between the baseline system and our proposed Mars-G is increased. Because the baseline system  is hard to model long-range semantic dependencies to generate inaccurate semantic states and system responses. In contrast,  Mars-G enhances the relationship modeling between dialog context and  semantic state representations  and achieves better dialog context representations to capture long-range semantic dependencies in the long dialog turns.\n\n\\subsection{Low Resource Scenario Analysis}\n\nTo investigate the performance of task-oriented dialog systems in the  low resource scenario, we choose 5\\%, 10\\%, 20\\%, and 50\\% of training dialog sessions   to do stimulated experiments on the MultiWOZ 2.0. \nConsidering the inconsistency of data distribution with different random seeds in the  stimulated low resource scenario, we  re-implement all baseline systems with the same random seed to ensure the consistency of data distribution.\nIn addition, we train all dialog systems five times with different random seeds and report the average scores in Table~\\ref{tab:low_resource}. The detailed results of five runs are provided in Appendix~\\ref{app:low}.\nAs shown in Table~\\ref{tab:low_resource},  PPTOD achieves the best performance in the extreme low-resource  scenario (5\\% training data) because  auxiliary corpora  used in PPTOD have many similar dialog sessions with MultiWOZ 2.0 and this benefits PPTOD in the stimulated low-resource  scenario. In contrast, Mars-G doesnâ€™t use auxiliary corpora to improve performance in the low-resource  scenario.\nApart from this,  Mars-G substantially outperforms all baseline systems  in other low-resource scenarios.\nMoreover, Mars-G trained on the 50\\% training data performs better than some baseline systems such as MinTL and UBAR trained on all training data, as shown in Table~\\ref{tab:main_results}. These further demonstrate that Mars-G is robust, achieving comparable performance in the low-resource scenario.\n\n\\subsection{ Error Analysis}\n\n \n\nTo better apply our proposed Mars-G to real-world scenarios, we perform error analysis based on inform rate (informable slot) and success rate (requestable slot). In detail,  we randomly extract  40 inaccurate dialog sessions from the MultiWOZ 2.0 testing set, respectively. % evaluated by the standalone standardized evaluation script ~\\cite{nekvinda-dusek-2021-shades}, from the MultiWOZ 2.0 testing set, respectively. %Considering the inclusion relationship of the two metrics described in Section~\\ref{sec:evaluation}, we  select dialog sessions with the wrong success rate and accurate inform rate for success rate error analysis.\n\\begin{figure}[t!]\n  \\centering \\scalebox{.88}{\n  \\subfigure{\n  \\begin{minipage}{.4\\linewidth}\n  \\centering\n  \\scalebox{.46}{\n\\begin{tikzpicture}\n\\begin{axis}\n[\n    xbar, enlarge y limits=0.1,\nenlarge x limits={0.1,upper},%ylabel={\\ Domain }, % the ylabel must precede a # symbol.\n    xlabel={\\ Dialog Sessions}, symbolic y coords={  Attraction,Restaurant,Hotel,Train,Taxi},%,[font=\\small]}, % these are the specification of coordinates on the x-axis.\n    ytick=data, nodes near coords, % this command is used to mention the y-axis points on the top of the particular bar.\n    nodes near coords align={horizontal},axis y line*=left,\n\t\taxis x line*=left, yticklabel style={rotate=60}]\n\\addplot  +[color=teal] coordinates { (8,Train) (13,Restaurant) (13,Hotel) (10,Attraction) (0,Taxi)};\n\\addplot +[color=gray] coordinates {(22,Train) (19,Restaurant) (19,Hotel) (16,Attraction) (6,Taxi)};\n\\end{axis}\n\\end{tikzpicture}}\n\\centerline{(a)}\n  \\end{minipage}\n    }\n  \\subfigure{\n\\begin{minipage}{.55\\linewidth}\n\\centering\n  \\scalebox{.46}{\n \\includegraphics[width=2.16in]{inform_error.pdf}\n  }\n  \\centerline{(b)}\\label{fig:inform_b}\n\\end{minipage}}}\n  \t\t\\caption{  The domain distribution (a) and primary  reason distribution (b) of inaccurate dialog sessions according to the inform rate metric. The gray bars denote the total number of dialog sessions that contain the corresponding domain; the teal bars denote the number of  dialog sessions with errors in the corresponding domain. }\\label{fig:inform}\n\\end{figure} \nThe detailed domain distribution and primary  reason  distribution of informable slot errors are presented as shown in Figure~\\ref{fig:inform}. \nGiven that there is no database in the taxi domain, the informable slots are consistently judged to be correct.\nThe error rate of the dialogs in the hotel and restaurant domains is very high because some informable slots in these two domains are often mispredicted, such as  `\\textit{type}' in the hotel domain. As illustrated  in Figure~\\ref{fig:inform_b}, 64 percent of dialog informable slot errors are caused by the inaccurate belief states and action states, and the noisy dialog annotations generate 32 percent. 4 percent of that are caused by automatic evaluation scripts and are judged accurately by human evaluation. \nThe detailed requestable slot error analysis and \nmore examples are provided in  Appendixes~\\ref{app:req_error} and~\\ref{app:error}, respectively.\nIn the future, we will focus on solving  errors caused by  the inaccurate dialog/ action states to better apply  Mars-G to real-world scenarios. \n\n\\section{Conclusion}\nThis study explores what dialog context representation is beneficial to improving  task-oriented dialog performance.\nSpecifically, we propose two contrastive learning strategies to explicitly model the relationship between dialog context and  semantic state representations,  achieving better task completion of a task-oriented dialog system.\nExtensive experiments and analysis demonstrate that dialog context representations that are more different from semantic state representations are more beneficial to multi-turn task-oriented dialog.\nMoreover, our proposed  Mars achieves state-of-the-art  performance on three datasets.\n  \n  \\section*{Limitations}\nThe training process of Mars needs to rely on manually annotated belief states and action states as semantic states to explicitly model the relationship between dialog context and semantic state representations through contrastive learning methods. We propose Mars in the research community and hope it can be better applied to real-world scenarios in the industry. However, the annotated data is expensive, which makes our methods have some limitations in the landing process of real scenarios. In the future, to better apply our proposed Mars to real-world scenarios, we will introduce semi-supervised methods to reduce the dependence on annotated dialog corpus. %Group-aware context\\&state  contrastive learning is one of methods that\n\\section*{Acknowledgments}\nThis work was supported by the National Key R\\&D Program of China under Grant No. 2020AAA0108600.\n\n\\appendix\n\\section{Datasets}\n\\label{sec:dataset}\nMultiWOZ 2.0~\\cite{budzianowski-etal-2018-multiwoz} is a large-scale English multi-domain task-oriented dialog dataset containing 8438, 1000, and 1000 dialog sessions for training, validation, and testing datasets. It consists of seven domains: attraction, hotel, restaurant, taxi,  train, hospital, and police. \nCamRest676~\\cite{wen-etal-2017-network} is a small-scale English restaurant-domain  dataset, which  is split 3/ 1/ 1 for training, validation, and testing datasets. CrossWOZ~\\cite{zhu-etal-2020-crosswoz} is a large-scale Chinese multi-domain task-oriented dialog dataset containing  5012, 500, and 500 dialog sessions for training, validation, and testing datasets. It comprises five domains: attraction, restaurant, hotel, taxi, and metro. \n\\section{Baselines}\n\\label{sec:baseline}\n\nSequicity~\\cite{lei-etal-2018-sequicity}, DAMD~\\cite{DBLP:conf/aaai/ZhangOY20}, and LABES~\\cite{zhang-etal-2020-probabilistic} are copy-augmented GRU-based end-to-end task-oriented dialog systems.\nBidirectional auto-encoding language model BERT~\\cite{devlin-etal-2019-bert} is used for the context encoder in DoTS~\\cite{DBLP:journals/corr/abs-2103-06648}.\nUnidirectional auto-regressive language model GPT-2~\\cite{radford2019language} is used in AuGPT~\\cite{DBLP:journals/corr/abs-2102-05126},  SOLOIST~\\cite{peng2020soloist}, and UBAR~\\cite{DBLP:conf/aaai/YangLQ21}. \nSeq2seq language model T5~\\cite{2020t5} is used in MinTL~\\cite{lin-etal-2020-mintl}, PPTOD~\\cite{DBLP:journals/corr/abs-2109-14739},  and MTTOD~\\cite{lee-2021-improving-end}. The unified language model UniLM~\\cite{DBLP:conf/nips/00040WWLWGZH19} is used in GALAXY~\\cite{DBLP:journals/corr/abs-2111-14592}. In addition, auxiliary task-oriented dialog corpora are used to pre-train in AuGPT~\\cite{DBLP:journals/corr/abs-2102-05126}, SOLOIST~\\cite{peng2020soloist}, PPTOD~\\cite{DBLP:journals/corr/abs-2109-14739}, and  GALAXY~\\cite{DBLP:journals/corr/abs-2111-14592}.\nTRADE~\\cite{wu-etal-2019-transferable}, BART-CSP~\\cite{DBLP:journals/corr/abs-2111-02574}, and GEEX~\\cite{li-etal-2021-generation} are some additional dialog state tracking models. \n\n\\section{States Analysis}\n\\label{sec:state}\n\\begin{table}[t]\n  \\centering\n  \\scalebox{.78}{\n\t\\begin{tabular}{lccc}\n\t\t\\toprule\n\t\t\\bf Model  &\\bf Inform & \\bf Success & \\bf BLEU\\\\ \n\t\t\\midrule\n \nEnd-to-end model &83.2&70.3&19.4\\\\\n\\;\\;\\;\\;\\;\\;\\;\\;\\;\\; w/ oracle state&90.8 & 87.4&30.6 \\\\\n      \\cdashline{1-4}[1pt/2pt]\n  Reference Corpus&     93.7   &  90.9  & 100.0 \\\\  %  91.4  88.2  95.7\n\t\t\\bottomrule\n\t\\end{tabular}}\\caption{Comparison of task-oriented dialog models evaluated on MultiWOZ 2.0. w/ oracle state denotes the system using ground truth belief state and action state for the response generation. Reference results are reported on the official leaderboard of MultiWOZ. \\label{tab:pre-experiment}}\n\\end{table}\nTo investigate  the impact of belief state and action state on the performance of end-to-end task-oriented dialog, we empirically conduct preliminary experiments on MultiWOZ 2.0~\\cite{budzianowski-etal-2018-multiwoz}. \nAs shown in Table~\\ref{tab:pre-experiment}, the system using ground truth belief state and action state substantially outperforms the traditional end-to-end task-oriented dialog systems, achieving performance  comparable  to reference in terms of  task completion. This demonstrates that the quality of belief state and action state greatly influence on the end-to-end task-oriented dialog performance.\n\\section{Dialog Context Representation Analysis}\n\\label{sec:Further}\n\\begin{figure}[t]\n  \\centering\n  \\includegraphics[width=2.8in]{evaluate.pdf}\n  \\caption{The calculation of Euclidean distance between dialog context and semantic state representations.}\n  \\label{fig:evaluate}\n\\end{figure}\nTo further analyze  dialog context and semantic state representations of Mars-P and Mars-G, we  would measure the similarity of continuous encoder  representation between dialog context and corresponding belief/action state on the MultiWOZ 2.0 test set, as illustrated in Figure~\\ref{fig:evaluate}.\nTable~\\ref{tab:context_1} shows the average L2-normalized  Euclidean distance between dialog context and corresponding  belief/action state representations.\nTable~\\ref{tab:context_2} shows the  Euclidean distance between the centroids of these two L2-normalized representation spaces. The centroid is the average of all the points in the representation space.\nT5 denotes the result before training on the MultiWOZ 2.0.\nWe find the distance between dialog context and corresponding semantic state representations changes a little before and after training.\nMars-P achieves a smaller distance, thus obtaining a continuous representation of the dialogue context that is semantically more consistent with its semantic state representation.\nThe distance of Mars-G  is enormous, demonstrating Mars-G  achieves more diverse dialog context representations, different from semantic state representations.\n\n\\begin{table}[!t]\n  \\centering\n  \\scalebox{.7}{\n\t\\begin{tabular}{lcc}\n\t\t\\toprule\n\t\t\\bf Model & \\bf Context\\&Belief State & \\bf Context\\&Action State \\\\ \n\t\t\\midrule\n\nT5& 0.797   &   1.018\\\\   %0.7966 &1.0180\\\\\nBaseline& 0.844 &  1.017  \\\\            %0.8444& 1.0169\\\\\nMars-P&0.340  &  0.542  \\\\            %0.3403&   0.5420  \\\\\nMars-G& 1.996  & 1.993\\\\              %1.9960& 1.9931 \\\\\n\t\t\\bottomrule\n\t\\end{tabular}}\\caption{The distance between dialog context and corresponding semantic state representations on MultiWOZ 2.0.\\label{tab:context_1}}\n\\end{table}\n\n\\begin{table}[!t]\n  \\centering\n  \\scalebox{.7}{\n\t\\begin{tabular}{lcc}\n\t\t\\toprule\n\t\t\\bf Model & \\bf Context\\&Belief State & \\bf Context\\&Action State \\\\ \n\t\t\\midrule\n\nT5& 0.555  &  0.807  \\\\ %0.5545 &0.8072\\\\\nBaseline& 0.598  &   0.699  \\\\  %0.5978  & 0.6986\\\\\nMars-P&  0.042  &  0.046  \\\\%0.0415  &0.0464     \\\\\nMars-G& 1.993 & 1.987\\\\ % 1.9927  & 1.9873 \\\\\n\t\t\\bottomrule\n\t\\end{tabular}}\\caption{The distance between the centroids of these two  representation spaces on MultiWOZ 2.0.\\label{tab:context_2}}\n\\end{table}\n\n\\section{Hyper-parameter Analysis}\n\\label{sec:parameter}\nWe empirically investigate how the hyper-parameters $\\lambda$ and $T$ for both modules of Mars-G affect the  performance of task-oriented dialog on the MultiWOZ 2.0, respectively. The selection of $\\lambda$ influences the role of the contrastive learning objective function across the entire task-oriented dialog training process.  As   Figure \\ref{fig:lambda} shows, $\\lambda$ ranging from 0.01 to 5 nearly all improve task-oriented dialog performance. This indicates our proposed Mars-G is robust and effective.\nWhen  $\\lambda =0.1$, w/ ASC achieves the best performance.\nWhen  $\\lambda =1$, w/ BSC achieves the best performance.\nThe selection of $T$ affects   the differentiation of  hard negative samples. The smaller the value of $T$ is, the more attention is paid to distinguishing complex  negative samples.\nAs shown in Figure \\ref{fig:T}, combined scores increase for almost all $T$ values ranging from 0.01 to 10, and the best performance is achieved when $T =0.5$ for both modules of Mars-G.\n\n \n\n\\begin{figure}[!t]\n\\setlength{\\abovecaptionskip}{0pt}\n\\begin{center}\n\\pgfplotsset{height=5.6cm,width=8.5cm,compat=1.15,every axis/.append style={thick}}\n\\begin{tikzpicture}\n\\tikzset{every node}=[font=\\small]\n\\begin{axis}\n[width=7cm,enlargelimits=0.13, tick align=outside, legend style={cells={anchor=west},legend pos=south west, legend columns=1,every axis legend/.append style={at={(0,0.8)}}}, xticklabels={ $0.01$, $0.05$, $0.1$, $0.5$,$1$,$2$,$5$},\nxtick={0,1,2,3,4,5,6},\n\t\taxis y line*=left,\n\t\taxis x line*=left,\nylabel={Combined score},xlabel={$\\lambda$},font=\\small]\n\n\\addplot+ [sharp plot, solid,mark=square*,mark size=1.2pt,mark options={mark color=purple}, color=purple][smooth] coordinates\n{  (0,98.3) (1,99.4) (2,99.4) (3,100) (4,100.4)(5,99.2)(6,99)};\n\\addlegendentry{\\tiny w/ BSC}\n\n\\addplot+ [sharp plot,solid, mark=diamond*,mark size=1.2pt,mark options={mark color=brown}, color=brown][smooth] coordinates\n{  (0,99.2) (1,99.6) (2,102) (3,101) (4,100.2)(5,99.2)(6,99.2)};\n\\addlegendentry{\\tiny {w/ ASC}}\n\n\\addplot+ [sharp plot,densely dashed,no markers, color=gray] coordinates\n{ (0,96.2) (1,96.2) (2,96.2) (3,96.2) (4,96.2) (5,96.2)(6,96.2)};\n\\addlegendentry{\\tiny Baseline}\n\\end{axis}\n\\end{tikzpicture}\n\\caption{\\label{fig:lambda}The  Mars-G performance with different levels of hyper-parameter $\\lambda$ on the MultiWOZ 2.0. w/ BSC denotes belief state  module, w/ ASC denotes action state  module. $T$ is set to 0.5.}\n\n\\end{center}\n\\end{figure} \n\n\\begin{figure}[!t]\n\\setlength{\\abovecaptionskip}{0pt}\n\\begin{center}\n\\pgfplotsset{height=5.6cm,width=8.5cm,compat=1.15,every axis/.append style={thick}}\n\\begin{tikzpicture}\n\\tikzset{every node}=[font=\\small]\n\\begin{axis}\n[width=7cm,enlargelimits=0.13, tick align=outside, legend style={cells={anchor=west},legend pos=south west, legend columns=1,every axis legend/.append style={at={(0,0.75)}}}, xticklabels={ $0.01$, $0.1$, $0.5$,$1$,$5$,$10$},\nxtick={0,1,2,3,4,5,6},\n\t\taxis y line*=left,\n\t\taxis x line*=left,\nylabel={Combined score},xlabel={$T$},font=\\small]\n\n\\addplot+ [sharp plot, solid,mark=square*,mark size=1.2pt,mark options={mark color=purple}, color=purple][smooth] coordinates\n{  (0,97.6) (1,99.4) (2,100.4) (3,99.71) (4,99.1)(5,99)};\n\\addlegendentry{\\tiny w/ BSC}\n\n\\addplot+ [sharp plot,solid, mark=diamond*,mark size=1.2pt,mark options={mark color=brown}, color=brown][smooth] coordinates\n{  (0,98.8) (1,99.8) (2,102) (3,99.3) (4,98.7)(5,98.1)};\n\\addlegendentry{\\tiny {w/ ASC}}\n\n\\addplot+ [sharp plot,densely dashed,no markers, color=gray] coordinates\n{ (0,96.2) (1,96.2) (2,96.2) (3,96.2) (4,96.2) (5,96.2)};\n\\addlegendentry{\\tiny Baseline}\n\\end{axis}\n\\end{tikzpicture}\n\\caption{\\label{fig:T}The  Mars-G performance with different levels of hyper-parameter $T$ on the MultiWOZ 2.0. $\\lambda_1$ is set to 1 for  w/ BSC, and $\\lambda_2$ is set to 0.1 for w/ ASC.}\n\n\\end{center}\n\\end{figure} \n\n\\section{Visualization}\n\\label{app:vis}\n\\begin{figure*}[ht]\n  \\centering\n  \\includegraphics[width=6.2in]{bs_vis.pdf}\n  \\caption{Visualization of the cross-attention weights between dialog context and generated belief states for our proposed Mars-G. The horizontal axis is the dialog context, and the vertical axis is the generated belief state.}\n  \\label{bs_vis}\n\\end{figure*}\n\\begin{figure*}[ht]\n  \\centering\n  \\includegraphics[width=6.2in]{base_bs_vis.pdf}\n  \\caption{Visualization of the cross-attention weights between dialog context and generated belief states for the baseline system.}\n  \\label{base_bs_vis}\n\\end{figure*}\nWe provide an example to visualize the   dialog state tracking process of our proposed Mars-G and baseline system. The cross-attention weights between dialog context and generated belief states from the last layer of the transformer decoder stack  are shown in Figures~\\ref{bs_vis} and ~\\ref{base_bs_vis}.  Compared with the baseline system,  Mars-G could achieve more accurate attention weights.\nThe slot `\\textit{arrive 09:00}' assigns high attention weights for the user utterance `\\textit{09:00}' and previous belief state `\\textit{arrive 09:00}'. Similarly, the slots `\\textit{destination mumford theatre}' and  `\\textit{departure wagamama}' accurately give  high attention weights for the corresponding user utterance.   The visualization further demonstrates that Mars-G could achieve  more reasonable dialog context representation to generate accurate belief states.\n\n\\section{Further Ablation Analysis}\n\\label{app:sim}\n\n\\begin{table}[!t]\n  \\centering\n  \\scalebox{.75}{\n\t\\begin{tabular}{lcccc}\n\t\t\\toprule\n\t\t\\bf Model & \\bf Inform & \\bf Success & \\bf BLEU & \\bf Combined\\\\ \n\t\t\\midrule\n\nBaseline& 83.2&70.3&19.4&96.2\\\\\nMars-variant& 85.7 &74.8 &19.6  &99.9\\\\\nMars-P&86.6&75.5&19.6&100.7\\\\\n\t\t\\bottomrule\n\t\\end{tabular}}\\caption{The performance of the different methods  on MultiWOZ 2.0. Mars-variant denotes similarity strategy.\\label{tab:ablation2}}\n\\end{table}\nTo  get a more complete picture of the effectiveness of Mars-P, we introduce a  similarity strategy (Mars-variant). We use the cosine similarity function to narrow the distance between the continuous representation of dialog contexts and semantic states for the same dialog session to model the relationship between dialog context and corresponding semantic state representations. We don't distinguish the continuous representation of  dialog context and states for different dialog sessions.\nAs shown in Table~\\ref{tab:ablation2}, Mars-variant outperforms the  baseline system  by  3.7 combined scores, indicating the effectiveness of the relationship modeling between dialog context and corresponding semantic representations. In addition, Mars-variant underperforms\nMars-P by  0.8 combined scores. This demonstrates that  distinguishing the continuous representation of  dialog context and states for different dialog sessions  is beneficial for dialog modeling.\n\\section{Low Resource Scenario Results}\n\\label{app:low}\nWe train all dialog systems five times with different random seeds in the low resource scenario. The detailed results of 5 runs are provided in Table~\\ref{tab:low_resource_detail}.\n\n\\begin{table*}[t]\n   \\small\n   \\centering\n   \\scalebox{.62}{\n\t\\begin{tabular}{lcccccccccccccccc}\n\t\t\\toprule\n\t\t\\multirow{2}*{\\bf Model} &\\multicolumn{4}{c}{\\bf 5\\% } &\\multicolumn{4}{c}{\\bf 10\\% } &   \\multicolumn{4}{c}{\\bf 20\\%}&  \\multicolumn{4}{c}{\\bf 50\\% }\\\\ \n\\cmidrule(lr){2-5} \\cmidrule(lr){6-9} \\cmidrule(lr){10-13} \\cmidrule(lr){14-17} \n\t\t& \\bf Inform  & \\bf Success & \\bf BLEU & \\bf Combined& \\bf Inform  & \\bf Success & \\bf BLEU& \\bf Combined& \\bf Inform  & \\bf Success & \\bf BLEU& \\bf Combined& \\bf Inform  & \\bf Success & \\bf BLEU& \\bf Combined\\\\ \n\t\t\\midrule\n\n\t\t\\multicolumn{17}{c}{\\bf DAMD }\\\\\n\t\t\t\\midrule\n\t\t\t\nrun 1& 35.4 &  17.2& 10.9 &  37.2  &  41.3 & 23.7 & 12.4  & 44.9   &  51.8 &  31.9 &  14.1 &  56.0 &  60.1  &  44.2 & 15.6  &  67.8\\\\\nrun 2& 40.8 &  20.9 &  12.0 & 42.9  & 41.5 & 25.3& 11.2& 44.6 &50.4&  32.4 & 13.8  & 55.2&54.7  &  39.5 &  14.8& 61.9 \\\\%  &44.5&  35.2&15.0&  54.9   \\\\\nrun 3& 38.5 &  14.5&  10.6  &  37.1&  40.0& 23.9&12.3&  44.3  & 42.5& 26.8 & 15.4& 50.1 &59.1 &   45.7 &   15.1&67.5\\\\\nrun 4&35.4 &  16.5&10.2 & 36.2  &  42.3&  20.2& 12.0 &43.3  &46.1& 29.2&  14.0 & 51.7 &57.2& 43.0&16.1&  66.2  \\\\\nrun 5& 34.0& 17.6& 12.4&  38.2  & 39.5  & 21.9  & 13.0  & 43.7  &  50.8 &31.3  & 13.6  & 54.7& 63.1  &   49.3& 17.1  &   73.3                   \\\\\n\n\\cdashline{1-17}[1pt/2pt]\nAverage&   36.8&   17.3&  11.2&   38.3& 40.9  &23.0   & 12.2  &    44.2&  48.3 & 30.3 &   14.2&  53.5&  58.8    & 44.3  &15.7    &67.3     \\\\\n\n\t\t\\midrule\n\t\t\\multicolumn{17}{c}{\\bf MinTL }\\\\\n\t\t\t\\midrule  %51.4 & 41.8 &15.0& 61.6& 61.4  & 52.3 & 17.1&74.0\nrun 1& 54.4  & 41.1  &  14.2 & 62.0  & 55.8 & 44.0 &15.3& 65.2& 62.5& 54.2&17.3&75.7& 71.7  & 62.7  & 16.9  &84.1\\\\\nrun 2&  54.8  & 36.8 & 13.6 & 59.4  & 51.6 & 42.0 & 15.7&62.5 &      65.8  &  56.3   &   15.5  &  76.6  & 67.4  &   59.7& 18.7  & 82.3  \\\\\nrun 3& 53.3&39.3&14.2&60.5       &   55.1       &  44.7  & 16.1& 66.0 &  68.0 &  59.0  & 16.6  &  80.1 & 70.6  &  62.6 &  17.5  &84.1\\\\%46.3 & 32.1 &13.2 &   52.4  &58.3 & 48.4  & 14.4  &67.8\nrun 4& 52.4&37.1&13.8&58.6 & 58.4 & 47.3& 15.2 & 68.1    &   58.3 & 48.4  & 14.4  &67.8& 68.9&  61.3 & 18.2 &  83.3\\\\\nrun 5& 47.5  &  36.3 & 13.8& 55.7  & 56.8 & 46.4 & 15.9 & 67.5 & 66.9 & 56.8  & 17.0  & 78.9  &73.1&  64.5 &  18.6 & 87.4\\\\\n\\cdashline{1-17}[1pt/2pt]\nAverage&  52.5 & 38.1 & 13.9 &59.2  &55.5  & 44.9  & 15.6 &65.8  &  64.3 & 54.9  &  16.2& 75.8 & 70.3&  62.2 & 18.0  &  84.3 \\\\\n\t\\midrule\n\t\t\\multicolumn{17}{c}{\\bf UBAR }\\\\\n\t\t\t\\midrule\nrun 1& 37.4  &  23.0 &  11.6 & 41.8  &52.3&34.8  & 13.0  & 56.6& 61.7   &   45.7 & 15.9   &  69.6  &  77.2 &   61.5 & 15.5 &  84.9\\\\\nrun 2&  33.3  & 20.6  & 11.2  & 38.2  &  48.5 & 35.9& 14.5 & 56.7 &63.4& 47.8& 15.5 &71.1 & 78.0  &  63.8 &16.9  & 87.8  \\\\\n\nrun 3& 40.0   &  23.1 & 11.7  & 43.3 &50.3&33.2&13.6&  55.4&67.8   &   50.0&  13.1 & 72.0  & 77.4  & 64.6 &  16.2 &  87.2\\\\\n\nrun 4& 38.2  & 22.4  &   10.7 &  41.0  & 52.5& 34.6 & 12.5&  56.1 &  68.3 & 51.7  & 14.4  & 74.4&  78.5&  64.1 & 16.8  &  88.1 \\\\\nrun 5&38.0 &  21.3 & 11.3  &  41.0 &  47.8 &  32.3&13.7   & 53.8  &  66.2  &  48.3   &   13.8 &71.1&76.8&  62.4 & 16.2   &   85.8\\\\\n\\cdashline{1-17}[1pt/2pt]\nAverage&  37.4 & 22.1 & 11.3  & 41.1  &  50.3& 34.2&  13.5 &55.8 & 65.5  & 48.7  &14.5   &71.6   &77.6   & 63.3  & 16.3  & 86.8 \\\\\n\t\\midrule%run1 seed 112 run2 80   run3 42 run4 155 run5 557\t\n\t\n\t\t\t\t\\multicolumn{17}{c}{\\bf MTTOD }\\\\%run1 seed 112 run2 80   run3 42 run4 155 run5 557\n\t\t\t\\midrule\n\t\t\t\nrun 1&51.4& 37.5&12.0& 56.5& 70.9& 58.0& 13.8&  78.3&  71.1 &  59.0 & 14.2  &  79.3&   74.7&  64.4& 15.2 & 84.8\\\\\nrun 2&  53.8  & 41.7  & 11.3 & 59.1   &64.1    &   53.7 & 13.8  & 72.7  & 69.5   &  60.7 &  14.0 &  79.1 & 79.3  & 67.7  & 15.0  &  88.5  \\\\\nrun 3& 55.7  & 31.1  & 11.5  & 54.9  & 61.0&  50.8&13.7&69.6 & 78.4 & 65.1& 14.7 & 86.5&  82.3 &  71.1 &   15.5& 92.2  \\\\\nrun 4& 52.4  & 33.3  & 10.6  &  53.5  &  73.0 &   59.3& 14.0 & 80.2& 80.2   & 67.4  &  14.5  &  88.3  &            76.6   &  65.6 &  15.3  &   86.4 \\\\\nrun 5&  58.0 &  43.2 &  11.3 & 61.9  &  65.4 &  54.2 & 13.7  & 73.5  &  75.9 & 64.3  &  14.1&84.2&  79.8 &  68.7 &  15.1  &  89.4  \\\\\n\\cdashline{1-17}[1pt/2pt]\nAverage& 54.3&37.4& 11.3  & 57.2&   66.9&  55.2 & 13.8  &  74.9  & 75.0& 63.3& 14.3    &  83.5 & 78.5 &  67.5 &  15.2  &  88.2  \\\\\n\t\\midrule\n\t\t\t\\multicolumn{17}{c}{\\bf PPTOD }\\\\\n\t\t\t\\midrule\n\t\t\t\nrun 1& 70.7& 46.8& 13.7&72.5   & 65.2& 50.6&14.2&72.1&    72.3     &  55.0  &   14.9&78.6&    74.8&  60.4 & 15.8  &83.4\\\\\nrun 2&  64.6& 45.8 &  13.8 &  69.0 & 69.3  &  52.9 & 15.3  & 76.4&70.5   &  57.7 &  17.7  & 81.8  &74.1 & 64.2 & 16.4 & 85.6\\\\\nrun 3& 64.4 &  51.1 &  15.1 & 72.9 &  65.7 &  53.6 & 15.8  & 75.5   & 74.8  &  64.6 & 16.9  & 86.6   &  74.3 &  61.8 &  17.2 &  85.3 \\\\\nrun 4& 63.9  & 47.0  &  14.7 & 70.2  &  70.1& 55.4  &  17.8 & 80.6  & 71.8  & 57.3  &  16.0  &  80.6  &   76.4 & 63.7  &  18.0&   88.1\\\\\nrun 5& 63.7  & 50.7 &  14.4 &  71.6 & 71.2  & 55.8  &  15.6 &   79.1&  74.1 &  61.6 & 15.8  &  83.7 &  74.4 &   61.9&  17.5  & 85.7 \\\\\n\\cdashline{1-17}[1pt/2pt]\nAverage&      65.5&     48.3    &14.3&  71.2       &   68.3 &  53.7& 15.7  &76.7& 72.7& 59.2&16.3&82.3&  74.8 &  62.4& 17.0&85.6 \\\\\n\n\t\\midrule\n\n\t\t\\multicolumn{17}{c}{\\bf Mars-G }\\\\\n\t\t\t\\midrule%run1 seed 112 run2 80   run3 42 run4 155 run5 557\t\n\nrun 1& 55.8&41.1&14.0&   62.5  &  68.7 &   55.0& 16.7     &    78.6&   72.4&60.2    &   18.1&  84.4&  82.6 & 70.2  &  18.8 &  95.2\\\\\nrun 2&  57.0     &  43.2 &  12.9 &  63.0  &    68.4      & 55.9 & 15.2  &  77.4 &       76.0     &  61.4 &17.1  & 85.8  & 78.4  & 66.9 & 18.7  &91.4    \\\\\nrun 3& 61.4  & 46.7  &  14.5 & 68.6  &  68.9 & 53.8  & 14.0 &  75.4 & 76.6  & 63.8  &17.0   &     87.2      & 82.8  & 73.6  &  17.9   &      96.1   \\\\\nrun 4& 56.1  & 42.4  & 14.1   & 63.4  & 73.1 &  60.3 &  16.6 & 83.3  &  80.6 & 63.9 & 17.1  &      89.4    &   82.5&  71.3 & 19.0      &95.9   \\\\\nrun 5& 57.8  & 43.5  & 13.8  & 64.5   & 67.7  &  51.5&  15.7 &  75.3 &     77.7       &  65.0 & 16.8 & 88.2  &  84.6 &   74.2 & 18.7 &  98.1 \\\\\n\n\\cdashline{1-17}[1pt/2pt]\nAverage& 57.6  & 43.4 & 13.9 & 64.4& 69.4 & 55.3  & 15.6 & 78.0 & 76.7  &  62.9 & 17.2 &  87.0&  82.2& 71.2 & 18.6 &95.3  \\\\\n\t\n\t\t\\bottomrule\n\t\\end{tabular}}\\caption{Comparison of task-oriented dialog systems on the MultiWOZ 2.0 in the low resource scenarios.\\label{tab:low_resource_detail}}\n\t\n\n\\end{table*}\n\\begin{figure}[!t]\n  \\centering\\scalebox{.88}{\n    \\subfigure{\n  \\begin{minipage}{.4\\linewidth}\n  \\centering\\scalebox{.46}{\n\\begin{tikzpicture}\n\\begin{axis}\n[\n    xbar, enlarge y limits=0.1,\nenlarge x limits={0.1,upper},%ylabel={\\ Domain }, % the ylabel must precede a # symbol.\n    xlabel={\\ Dialog Sessions}, symbolic y coords={  Attraction,Restaurant,Hotel,Train,Taxi}, % these are the specification of coordinates on the x-axis.\n    ytick=data, nodes near coords, % this command is used to mention the y-axis points on the top of the particular bar.\n    nodes near coords align={horizontal},axis y line*=left,\n\t\taxis x line*=left, yticklabel style={rotate=60},]\n\\addplot  +[color=brown] coordinates { (7,Train) (8,Restaurant) (11,Hotel) (13,Attraction) (1,Taxi)};\n\\addplot +[color=gray] coordinates {(18,Train) (17,Restaurant) (22,Hotel) (15,Attraction) (9,Taxi)};\n\\end{axis}\n\\end{tikzpicture}}  \\centerline{(a)}\n  \n\n  \\end{minipage}}\n    \\subfigure{\n\\begin{minipage}{.55\\linewidth}\n\\centering\n  \\scalebox{.46}{\n\n \\includegraphics[width=2.16in]{success_error.pdf}\n     \n\n}  \\centerline{(b)}\\label{fig:success_b}\n\\end{minipage}}}\n\t\\caption{\\label{fig:success} The domain distribution (a) and primary  reason distribution (b) of inaccurate dialog sessions according to  success rate metric. The gray bars denote the total number of dialog sessions that contain the corresponding domain; the brown bars denote the number of  dialog sessions with errors in the corresponding domain.}\n\\end{figure} \n\\section{Requestable Slot Error Analysis}\n\\label{app:req_error}\nConsidering the inclusion relationship of the two metrics described in Section~\\ref{sec:evaluation}, we  select dialog sessions with the wrong success rate and accurate inform rate for success rate error analysis.\nThe detailed domain distribution and primary  reason  distribution of requestable slot errors are presented as shown in Figure~\\ref{fig:success}.  The error rate of the dialogs in the taxi and train domains is very low because requestable slots in these two domains are few and simple.  For example, the requestable slot in the taxi domain only has `\\textit{phone}'. The error rate of the dialogs in the attraction domain is very high. \nAs illustrated  in Figure~\\ref{fig:success_b}, 77.5 percent of dialog requestable slot errors are caused by  the noisy dialog annotations and automatic evaluation scripts. 15 percent of generated system responses are acceptable.\nWhen users request some information about something and do not ask for a specific requestable slot, Mars-G generates system responses that lack some requestable slots such as `\\textit{postcode}' and `\\textit{address}'. In addition, Mars-G requests users some other useful information instead of providing booked reference directly. We think system responses generated by Mars-G in both cases are reasonable.\nInaccurate action states cause 7.5 percent of dialog requestable slot errors.\n\n\\section{Examples for Error Analysis}\n\\label{app:error}\n\nTables \\ref{tab:case1} - \\ref{tab:case9} show several examples generated by Mars-G for detailed error analysis. \nAs shown in Table \\ref{tab:case1},  Mars-G generates the inaccurate belief state `\\textit{food jamaican}' rather than `\\textit{food italian}', leading to the informable slot error. \n Table \\ref{tab:case2} shows that  Mars-G generates the inadequate  action state,  not including the slot name `\\textit{name}', leading to the informable slot error. \nTable \\ref{tab:case3} shows that the informable slot error is caused by automatic evaluation. Mars-G provides the accurate response in turn 7. However, the automatic evaluation script estimates the wrong active domain `\\textit{[taxi]}' rather than `\\textit{[attraction]}' from the belief state.\nThe informable slot error in Table~\\ref{tab:case4}  is caused by noisy dialog annotations. The informable slot `pricerange moderate' does not appear in the conversation.\n\nAs shown in Table \\ref{tab:case5},  Mars-G generates the inaccurate action state `\\textit{[request] people}' provided in the belief state `\\textit{people 1}', leading to the requestable slot error. \nTable \\ref{tab:case6} shows that the requestable slot error is caused by automatic evaluation.\nMars-G provides the accurate response in turn 2, while the automatic evaluation script only determines if it offers a reference in turn 3.\nWe think system responses generated by Mars-G in Tables~\\ref{tab:case7} and ~\\ref{tab:case8} are acceptable.\nWhen users request some information about something and do not ask for a specific requestable slot, Mars-G generates system responses, lack of the  requestable slot `\\textit{postcode}', as shown in Table~\\ref{tab:case7}. In addition, Mars-G requests users whether to make a reservation instead of providing booked references directly, as shown in Table~\\ref{tab:case8}.\nNoisy dialog annotations cause the requestable slot error in Table~\\ref{tab:case9}. The requestable slot `postcode' does not appear in the conversation.\n \n \n\\begin{table*}[ht]\n  \\centering\n  \\scalebox{.8}{\n\t\\begin{tabular}{ll}\n\t\t\\toprule\nGoal:& [restaurant]: \\{informable: {\\color{red}food italian} area east\\} \\{requestable: reference\\}\\\\\n\n\t\t\\midrule\n User (Turn 0):& i am looking for a {\\color{red}jamaican} restaurant in the east.\\\\\nGolden R: &there are no [value\\_food] restaurants in the [value\\_area].\\\\ &would you like to try another food type or area?\\\\\nGolden BS: & [restaurant] {\\color{red}food jamaican} area east\\\\\nGolden AS:&   [restaurant] [nooffer] food area [request] area food      \\\\\n Mars-G R:& i am sorry, there are no [value\\_food] restaurants in the [value\\_area]. \\\\&would you like to try another area or another type of food?\\\\\nMars-G BS: &[restaurant] {\\color{red}food jamaican} area east\\\\\n  Mars-G AS:&     [restaurant] [nooffer] food area [request] area food   \\\\\n \n \t\\midrule\nUser (Turn 1): & i am looking for a place that serves {\\color{red}jamaican food} in the east. if not, {\\color{red}italian} will do.\t\\\\\n   Golden R: & there is [value\\_choice] [value\\_food] place in the [value\\_area], [value\\_name]. \t\\\\\n Golden BS: &  [restaurant] {\\color{red}food italian} area east\t\\\\\n Golden AS:&     [restaurant] [inform] choice name food area   \\\\\n  Mars-G R:  &i am sorry, there are no [value\\_food] restaurants in the [value\\_area]. \\\\&would you like to try another type of food?\\\\\n  Mars-G BS: & [restaurant] {\\color{red}food jamaican} area east\\\\\n  Mars-G AS:&    [restaurant] [nooffer] food area [request] food    \\\\\n \n  \t\\midrule\n User (Turn 2):  & ok, i would like to make a reservation there.\t\\\\\n  \tGolden R: & i can do that for you, i just need details such as day, time, and the size of your party. \\\\\n  \tGolden BS: &  [restaurant] {\\color{red}food italian} area east\\\\\nGolden AS:&    [restaurant] [offerbook] [request] time day people    \\\\\n  \t  Mars-G R: &  what day and time would you like to dine? and how many people will be in your party?\\\\\n  \t Mars-G BS: & [restaurant] {\\color{red}food jamaican} area east\\\\\n  Mars-G AS:&    [restaurant] [request] day time people    \\\\\n           \n  \t \n  \t \t\\midrule\n  \t \tUser (Turn 3):   &i need a table for 7 at 14:45 on friday.\\\\\n  \t \t  Golden R: & i booked you a table for [value\\_people] on [value\\_day] at [value\\_time] at \\\\&[value\\_name], reference: [value\\_reference]. can i assist you further today?\\\\\n  \t \t \tGolden BS:  & [restaurant] {\\color{red}food italian} area east time 14:45 day friday people 7 \\\\\n  \t \t \tGolden AS:&    [restaurant] [offerbooked] time reference name day people [general] [reqmore]    \\\\\n  \t \t     Mars-G R: & booking was successful. the table will be reserved for 15 minutes. \\\\&reference number is: [value\\_reference].\\\\\n  \t \t Mars-G BS:  & [restaurant] {\\color{red}food jamaican} area east time 14:45 day friday people 7 \\\\\n  Mars-G AS:&    [restaurant] [offerbooked] reference    \\\\\n    \n\t\t\\bottomrule\n\t\\end{tabular}}\\caption{An example in dialog session pmul0367. The informable slot error is caused by the inaccurate belief state. R denotes response, BS denotes belief state, and AS denotes action state. \\label{tab:case1}}\n\\end{table*}\n\n         \n\n\\begin{table*}[ht]\n  \\centering\n  \\scalebox{.8}{\n\t\\begin{tabular}{ll}\n\t\t\\toprule\nGoal:& [attraction]: \\{informable: area centre\\} \\\\\n\n\t\t\\midrule\n User (Turn 3):& i am also looking for places to go in town. perhaps an attraction in the city centre.\\\\\nGolden R: &i have the {\\color{red}[value\\_name]} located at [value\\_address] and it's [value\\_price] entrance.\\\\\nGolden BS: &[attraction] area centre\\\\\nGolden AS:&   [attraction] [recommend] address price {\\color{red}name}     \\\\\n Mars-G R:& there are [value\\_choice] attractions in the city centre. do you have a preference for type?\\\\\nMars-G BS: &[attraction] area centre  \\\\\n  Mars-G AS:&    [attraction] {\\color{red}[inform] choice} [request] type  \\\\\n \n \t\\midrule\nUser (Turn 4): &\tthat sounds perfect. thanks!\\\\\n   Golden R: & can i help you with anything else?\t\\\\\n Golden BS: &  [attraction] area centre\t\\\\\n Golden AS:&  [general] [reqmore]    \\\\\n  Mars-G R:  &is there anything else i can help you with?\\\\\n  Mars-G BS: & [attraction] area centre \\\\\n  Mars-G AS:&    [general] [reqmore] \\\\\n\t\t\\bottomrule\n\t\\end{tabular}}\\caption{An example in dialog session pmul2563. The informable slot error is caused by the inaccurate action state.\n\\label{tab:case2}}\n\\end{table*}\n\n    \n\n  \\iffalse\n\\begin{table*}[ht]\n  \\centering\n  \\scalebox{.9}{\n\t\\begin{tabular}{ll}\n\t\t\\toprule\nGoal:& [train]: \\{informable: destination cambridge  day saturday arrive 11:45 \\\\&\\;\\; \\;\\;\\;\\;\\;\\;\\;\\;\\;departure birmingham new street\\}\\\\\n\n\t\t\\midrule\n User :& i would like to leave on saturday. any train is fine. i'll just need the departure time and price.\\\\\nGolden R: &where are you leaving from and where are you going to?\\\\\nGolden BS: &[train] leave saturday\\\\\nGolden AS:&   [train] [request] departure destination     \\\\\n Mars-G R:&[value\\_id] leaves at [value\\_leave] and costs [value\\_price]. \\\\\nMars-G BS: &[train] day saturday \\\\\n  Mars-G AS:&   [train] [inform] price leave id     \\\\\n \n \t\\midrule\nUser: &\tthe train should arrive by 11:45 in cambridge. i am leaving on saturday from \\\\&birmingham new street on saturday. {\\color{red}also need places to go in the east side of town.}\\\\\n   Golden R: & i have a train departing [value\\_departure] on saturday at [value\\_leave] and arriving in \\\\&[value\\_destination] at [value\\_arrive]. tickets are [value\\_price], would you like to book this train?\t\\\\\n Golden BS: &  [train] destination cambridge day saturday arrive 11:45 departure birmingham new street \\\\&leave saturday\t\\\\\n Golden AS:&    [train] [inform] departure destination price arrive leave [offerbook]  \\\\\n  Mars-G R:  &there are [value\\_choice] options. do you have a preferred time to leave?\\\\\n  Mars-G BS: &{\\color{red}[attraction] area east} [train] destination cambridge day saturday arrive 11:45 \\\\&departure birmingham new street \\\\\n  Mars-G AS:&  [train] [inform] choice [request] leave   \\\\\n \n  \t\\midrule\n User:  & yes, please book me.\t\\\\\n  \tGolden R: &  how many tickets will you be needing?\\\\\n  \tGolden BS: &  [train] destination cambridge day saturday arrive 11:45 departure birmingham new street \\\\&leave saturday\\\\\nGolden AS:& [train] [offerbook] [request] people      \\\\\n  \t  Mars-G R: & booking was successful, the total fee is [value\\_price] payable at the station.\\\\& reference number is: [value\\_reference].\\\\\n  \t Mars-G BS: & {\\color{red}[attraction] area east} [train] destination cambridge day saturday arrive 11:45 \\\\&departure birmingham new street\\\\\n  Mars-G AS:&   [train] [offerbooked] reference price   \\\\\n           \n  \t \n  \t \t\\midrule\n  \t \tUser:   &just one for myself, please, and thank you.\\\\\n  \t \t  Golden R: & ok, the booking was successful, the total fee is [value\\_price] payable at the station.\\\\& reference number is: [value\\_reference]. can i help with anything else?\\\\\n  \t \t \tGolden BS:  &  [train] destination cambridge day saturday arrive 11:45 departure birmingham new street \\\\&people 1 leave saturday\\\\\n  \t \t \tGolden AS:&    [train] [offerbooked] price reference [general] [reqmore]  \\\\\n  \t \t     Mars-G R: & booking was successful, the total fee is [value\\_price] payable at the station. \\\\&reference number is: [value\\_reference]. is there anything else i can help you with?\\\\\n  \t \t Mars-G BS: & {\\color{red}[attraction] area east} [train] destination cambridge day saturday arrive 11:45 \\\\&departure birmingham new street people 1 \\\\\n  Mars-G AS:&    [train] [offerbooked] reference price [general] [reqmore]  \\\\\n    \n\t\t\\bottomrule\n\t\\end{tabular}}\\caption{The pmul4911.\\label{tab:case4}}\n\\end{table*}\n\\fi\n\n\\begin{table*}[ht]\n  \\centering\n  \\scalebox{.8}{\n\t\\begin{tabular}{ll}\n\t\t\\toprule\nGoal:& [attraction]: \\{informable: area south\\} \\{requestable: postcode\\}\\\\\n\n\t\t\\midrule\n User (Turn 4):& i would also like to go to some attractions in the same area as the restaurant.\\\\\nGolden R: & there are [value\\_choice] attractions in the area. there's a [value\\_type], [value\\_type],\\\\& [value\\_type], [value\\_type], [value\\_type]... do any of these appeal to you in particular?\\\\\nGolden BS: &[attraction] area south [restaurant] food indian pricerange expensive area south\\\\\nGolden AS:&   [attraction] [select] type [inform] choice     \\\\\n Mars-G R:&  there are [value\\_choice] attractions in the area. do you have a preference for type?\\\\\nMars-G BS: &[attraction] area south [restaurant] food indian pricerange expensive area south\\\\\n  Mars-G AS:& [attraction] [inform] choice [request] type       \\\\\n \n \t\\midrule\nUser (Turn 5): &\trestaurant is what i am looking for, entrance fee and postcode please. {\\color{red}get me a taxi }\\\\&{\\color{red}from the attraction by 10.15, get me its contact number and car type.}\\\\\n   Golden R: & just to clarify you are looking for another restaurant and not an attraction?\t\\\\\n Golden BS: &  [attraction] area south [restaurant] food indian pricerange expensive area south\t\\\\\n Golden AS:&    [attraction] [select] [restaurant] [select]  \\\\\n  Mars-G R:  &[value\\_name] is located in postcode [value\\_postcode]. the phone number is \\\\&[value\\_phone]. the entrance fee is [value\\_price]. can i help you with anything else?\\\\\n  Mars-G BS: & {\\color{red}[taxi]} leave 10.15 destination tandoori palace departure the nirala [attraction] \\\\&area south [restaurant] food indian pricerange expensive area south \\\\\n  Mars-G AS:&    [attraction] [inform] price phone name postcode [general] [reqmore] \\\\\n \n  \t\\midrule\n User (Turn 6):  & oh, yeah, i do want information on attractions! in the same area. after that, i will need a taxi.\t\\\\\n  \tGolden R: & if you like parks the [value\\_name] has [value\\_price] admission and is in the \\\\&[value\\_postcode] postcode. or i can tell you about the other attractions? \\\\\n  \tGolden BS: &  [attraction] area south [restaurant] food indian pricerange expensive area south\\\\\nGolden AS:&     [attraction] [recommend] name postcode price [general] [reqmore]  \\\\\n  \t  Mars-G R: & there are [value\\_choice] attractions in the [value\\_area]. [value\\_choice] are \\\\&[value\\_type], [value\\_choice] are [value\\_type], and [value\\_choice] is [value\\_type].\\\\& do you have a preference?\\\\\n  \t Mars-G BS: & [taxi] leave 10.15 destination tandoori palace departure the nirala [attraction] \\\\&area south [restaurant] food indian pricerange expensive area south \\\\\n  Mars-G AS:&  [attraction] [inform] area type choice [request] type    \\\\\n           \n  \t \n  \t \t\\midrule\n  \t \tUser (Turn 7):   &that sounds wonderful, is it also in the south part of town? {\\color{red}if so, i would like a taxi}\\\\& {\\color{red}from there to my hotel.}\\\\\n  \t \t  Golden R: & yes, [value\\_name] is in the [value\\_area]. in order to help you book a taxi between \\\\&the park and your hotel, i need to know what hotel you're at.\\\\\n  \t \t \tGolden BS:  & [taxi] departure wandlebury country park [attraction] area south \\\\&[restaurant] food indian pricerange expensive area south \\\\\n  \t \t \tGolden AS:&    [attraction] [inform] area name [taxi] [request] destination  \\\\\n  \t \t     Mars-G R: &{\\color{red}yes, [value\\_name] is in the [value\\_area].}\\\\\n  \t \t Mars-G BS:  &{\\color{red}[taxi]} leave 10.15 destination tandoori palace departure the nirala [attraction] \\\\&area south [restaurant] food indian pricerange expensive area south \\\\\n  Mars-G AS:&  [attraction] [inform] area name   \\\\\n    \n\t\t\\bottomrule\n\t\\end{tabular}}\\caption{An example in dialog session mul2491. The informable slot error is caused by automatic evaluation.\\label{tab:case3}}\n\\end{table*}\n\n\\begin{table*}[ht]\n  \\centering\n  \\scalebox{.8}{\n\t\\begin{tabular}{ll}\n\t\t\\toprule\nGoal:& [restaurant]: \\{informable: {\\color{red}pricerange moderate} area west \\}\\{requestable: reference\\}\\\\\n\n\t\t\\midrule\n User (Turn 0):& hi! i am planning a trip in cambridge and i am looking for a restaurant in the west part of town.\\\\\nGolden R: &there are [value\\_choice] restaurants in the [value\\_area]. is there any kind of food you're looking for?\\\\\nGolden BS: &{\\color{red}[restaurant] area west}\\\\\nGolden AS:&    [restaurant] [inform] choice area [request] food    \\\\\n Mars-G R:& there are [value\\_choice] restaurants in the [value\\_area] part of town.\\\\& do you have a price range or type of food in mind?\\\\\nMars-G BS: &{\\color{red}[restaurant] area west}\\\\\n  Mars-G AS:&       [restaurant] [inform] choice area [request] food price \\\\\n \n \t\\midrule\nUser (Turn 1): &\thow about you suggest one a book a table for 4 on tuesday at 15:45 and \\\\&i need the reference number too please\\\\\n   Golden R: & i was able to book [value\\_name], reference number is [value\\_reference]\t\\\\\n Golden BS: &  {\\color{red} [restaurant] area west time 15:45 day tuesday people 4}\t\\\\\n Golden AS:&  [restaurant] [offerbooked] name reference    \\\\\n  Mars-G R:  &i have booked you at [value\\_name]. your reference number is [value\\_reference]. \\\\&is there anything else i can help you with?\\\\\n  Mars-G BS: & {\\color{red}[restaurant] area west time 15:45 day tuesday people 4}\\\\\n  Mars-G AS:&   [restaurant] [offerbooked] reference name [general] [reqmore]  \\\\\n \n    \n\t\t\\bottomrule\n\t\\end{tabular}}\\caption{An example in dialog session pmul3992. The informable slot error is caused by  noisy dialog annotations.\\label{tab:case4}}\n\\end{table*}\n\n\\begin{table*}[ht]\n  \\centering\n  \\scalebox{.8}{\n\t\\begin{tabular}{ll}\n\t\t\\toprule\nGoal:& [train]: \\{informable: leave 17:00 destination birmingham new street  day monday departure cambridge\\}\\\\\n&    \\;\\;\\;\\;\\;\\;\\;\\;\\;\\; \\{requestable:  {\\color{red}reference}\\}\n\\\\\n\t\t\\midrule\n User (Turn 0):&what train do i take to get to birmingham new street? i need to leave after 17:00. \\\\\nGolden R: &there are trains departing hourly at 1 minute past the hour [value\\_leave]. all are [value\\_price], \\\\&and take [value\\_time].\\\\\nGolden BS: &[train] destination birmingham new street leave 17:00\\\\\nGolden AS:&    [train] [inform] price leave time   \\\\\n Mars-G R:& where will you be departing from and what day would you like to travel ?\\\\\nMars-G BS: &[train] destination birmingham new street leave 17:00\\\\\n  Mars-G AS:&    [train] [request] departure day  \\\\\n \n  \t \n  \t \t\\midrule\n  \t \tUser (Turn 1):   &i am looking to travel on monday. the first train at 17:01 would be fine.  can i get that train info?\\\\\n  \t \t  Golden R: & sure the trainid is [value\\_id]. it leaves at [value\\_leave] and arrives at [value\\_arrive].\\\\& would you like to make a reservation?\\\\\n  \t \t \tGolden BS:  & [train] destination birmingham new street day monday departure cambridge leave 17:00 \\\\\n  \t \t \tGolden AS:&   [train] [inform] arrive leave id [offerbook]  \\\\\n  \t \t     Mars-G R: &[value\\_id] leaves at [value\\_leave] and arrives at [value\\_arrive]. would you like me to book that for you?\\\\\n  \t \t Mars-G BS:  & [train] destination birmingham new street day monday departure cambridge leave 17:00\\\\\n  Mars-G AS:&   [train] [inform] arrive leave id [offerbook]   \\\\\n   \t \t\\midrule\n  \t \tUser (Turn 2):   &yes please make a reservation and give me the reference number.\\\\\n  \t \t  Golden R: & your reservation is book. the reference number is [value\\_reference].\\\\& can i assist you with anything else today?\\\\\n  \t \t \tGolden BS:  &  [train] destination birmingham new street day monday departure cambridge people 1 leave 17:00 \\\\\n  \t \t \tGolden AS:&   [train]  {\\color{red}[offerbooked] reference} [general] [reqmore]  \\\\\n  \t \t     Mars-G R: &how many tickets do you need?\\\\\n  \t \t Mars-G BS:  &[train] destination birmingham new street day monday departure cambridge  {\\color{red}people 1} leave 17:00 \\\\\n  Mars-G AS:&    [train]  {\\color{red}[request] people}  \\\\   \n\t\t\\bottomrule\n\t\\end{tabular}}\\caption{An example in dialog session mul1624. The inaccurate action state causes the requestable slot error. \\label{tab:case5}}\n\\end{table*}\n\n\\begin{table*}[ht]\n  \\centering\n  \\scalebox{.8}{\n\t\\begin{tabular}{ll}\n\t\t\\toprule\nGoal:& [restaurant]: \\{informable: food international pricerange moderate area centre\\} \\{requestable: {\\color{red}reference}\\}\\\\\n\n\t\t\\midrule\n User (Turn 0):&what restaurants in the centre serve international cuisine? \\\\\nGolden R: &the [value\\_name] and the [value\\_name] serve [value\\_food] food and are in the [value\\_area] of town.\\\\\nGolden BS: &[restaurant] food international area centre\\\\\nGolden AS:& [restaurant] [inform] food area name       \\\\\n Mars-G R:& there are [value\\_choice] restaurants that meet your criteria. do you have a price range in mind?\\\\\nMars-G BS: & [restaurant] food international area centre\\\\\n  Mars-G AS:&   [restaurant] [inform] choice [request] price     \\\\\n \n \t\\midrule\nUser (Turn 1): &how about a place in the moderate price range?\t\\\\\n   Golden R: & [value\\_choice] of the named restaurants are in the [value\\_pricerange] price range.\t\\\\\n Golden BS: &[restaurant] food international pricerange moderate area centre\\\\\n Golden AS:&   [restaurant] [inform] choice price   \\\\\n  Mars-G R:  & there are [value\\_choice] restaurants that meet your criteria. [value\\_name] and [value\\_name].\\\\& would you like me to book one of these for you? \\\\\n  Mars-G BS: &[restaurant] food international pricerange moderate area centre \\\\\n  Mars-G AS:&   [restaurant] [inform] choice name [offerbook]  \\\\\n \n  \t\\midrule\n User (Turn 2):  & {\\color{red}ok, can you book a table for 6 at 12:00 on tuesday at the varsity restaurant?} \\\\&{\\color{red}i will need a reference number too, please.}\t\\\\\n  \tGolden R: & certainly. i will have that reference number for you in just one second. \\\\\n  \tGolden BS: & [restaurant] food international pricerange moderate area centre \\\\\nGolden AS:&    [restaurant] [offerbook]   \\\\\n  \t  Mars-G R: &  {\\color{red}booking was successful. the table will be reserved for 15 minutes. reference number is:}\\\\& {\\color{red}[value\\_reference].} is there anything else i can help you with?\\\\\n  \t Mars-G BS: & [restaurant] food international pricerange moderate area centre time 12:00 day tuesday people 6\\\\\n  Mars-G AS:&     {\\color{red}[restaurant] [offerbooked] reference} [general] [reqmore] \\\\\n           \n  \t \n  \t \t\\midrule\n  \t \tUser (Turn 3):   &thanks. looking forward to it.\\\\\n  \t \t  Golden R: & yes i can. {\\color{red}i have booked you a table for [value\\_time] on [value\\_day] for [value\\_people] people.} \\\\&{\\color{red}your reference number is [value\\_reference].} anything else i can help you with?\\\\\n  \t \t \tGolden BS:  &  [restaurant] food international pricerange moderate area centre time 12:00 day tuesday people 6 \\\\\n  \t \t \tGolden AS:&    [restaurant] {\\color{red}[offerbooked]} time {\\color{red}reference} people day \\\\\n  \t \t     Mars-G R: &you're welcome. have a great day!\\\\\n  \t \t Mars-G BS:  &  [restaurant] food international pricerange moderate area centre time 12:00 day tuesday people 6\\\\\n  Mars-G AS:&  [general] [welcome] [bye]    \\\\\n    \n\t\t\\bottomrule\n\t\\end{tabular}}\\caption{An example in dialog session sng0636. The requestable slot error is caused by automatic evaluation. \\label{tab:case6}}\n\\end{table*}\n\n\\begin{table*}[ht]\n  \\centering\n  \\scalebox{.8}{\n\t\\begin{tabular}{ll}\n\t\t\\toprule\nGoal:& [attraction]: \\{informable: area north\\} \\{requestable: {\\color{red}postcode phone} \\}\\\\\n\t\t\\midrule\n User (Turn 0):& i am looking for something to do in town. are there any interesting attraction in the north part of town?\\\\\nGolden R: &yes , there are [value\\_choice] places: i see a [value\\_type], a [value\\_type], and two [value\\_type]. \\\\&would one of these work for you?\\\\\nGolden BS: &[attraction] area north\\\\\nGolden AS:&     [attraction] [inform] type choice [general] [reqmore]   \\\\\n Mars-G R:& there are [value\\_choice] [value\\_type] and [value\\_type] in the [value\\_area]. do you have a preference? \\\\\nMars-G BS: &[attraction] area north\\\\\n  Mars-G AS:&    [attraction] [inform] area type choice [request] type    \\\\\n \n \t\\midrule\nUser (Turn 1): &ooh, a pool would be fun. {\\color{red}can you give me their contact info?}\t\\\\\n   Golden R: & great! [value\\_address] is located at [value\\_address], kings hedges postcode is [value\\_postcode] \\\\&and their phone is [value\\_phone]. is there anything else i can help you with?\t\\\\\n Golden BS: &  [attraction] area north\t\\\\\n Golden AS:&     [attraction] [inform] name postcode phone address [general] [reqmore] \\\\\n  Mars-G R:  & {\\color{red}[value\\_name] is located at [value\\_address]. their phone number is [value\\_phone].}\\\\\n  Mars-G BS: &[attraction] area north type swimming pool \\\\\n  Mars-G AS:&   {\\color{red}[attraction] [inform] name phone address } \\\\\n \n    \n\t\t\\bottomrule\n\t\\end{tabular}}\\caption{An example in dialog session mul1811.  The requestable slot error is acceptable.\\label{tab:case7}}\n\\end{table*}\n\\begin{table*}[ht]\n  \\centering\n  \\scalebox{.8}{\n\t\\begin{tabular}{ll}\n\t\t\\toprule\nGoal:& [train]: \\{informable: destination stansted airport  day  friday  arrive 15:30 departure cambridge\\} \\\\\n&  \\;\\;\\;\\;\\;\\;\\;\\;\\;\\;  \\{requestable: {\\color{red}reference}\\}\\\\\n\n\t\t\\midrule\n User (Turn 3):& i will also need a train leaving cambridge.\\\\\nGolden R: &sure, what is your arrival information?\\\\\nGolden BS: &[train] departure cambridge\\\\\nGolden AS:&       [train] [request] destination \\\\\n Mars-G R:& what day will you be traveling, and where will you be traveling to?\\\\\nMars-G BS: &[train] departure cambridge\\\\\n  Mars-G AS:&  [train] [request] destination day      \\\\\n \n \t\\midrule\nUser (Turn 4): &i need to go to stansted airport on friday.\t\\\\\n   Golden R: & we have [value\\_choice] different departure times. any time table your looking at? \t\\\\\n Golden BS: & [train] destination stansted airport departure cambridge \t\\\\\n Golden AS:&     [train] [inform] choice [request] leave \\\\\n  Mars-G R:  &there are [value\\_choice] trains that meet your criteria. do you have a preferred departure or arrival time?\\\\\n  Mars-G BS: &  [train] destination stansted airport day friday departure cambridge\\\\\n  Mars-G AS:&  [train] [inform] choice [request] leave arrive   \\\\\n \n  \t\\midrule\n User (Turn 5): & i need to be in stansted airport by 15:30 please.\t\\\\\n  \tGolden R: & the soonest it will get you there is [value\\_arrive] {\\color{red}your reference number is} [value\\_reference], anything else? \\\\\n  \tGolden BS: & [train] destination stansted airport arrive 15:30 departure cambridge people 1 \\\\\nGolden AS:&  [train] {\\color{red}[offerbooked] arrive reference} [general] [reqmore]   \\\\\n  \t  Mars-G R: & [value\\_id] will arrive at [value\\_arrive]. {\\color{red}would you like me to book that for you?}\\\\\n  \t Mars-G BS: &[train] destination stansted airport day friday arrive 15:30 departure cambridge \\\\\n  Mars-G AS:&   [train] [inform] arrive id {\\color{red}[offerbook] }  \\\\\n           \n\n    \n\t\t\\bottomrule\n\t\\end{tabular}}\\caption{An example in dialog session pmul3247. The requestable slot error is acceptable. \\label{tab:case8}}\n\\end{table*}\n\\begin{table*}[ht]\n  \\centering\n  \\scalebox{.8}{\n\t\\begin{tabular}{ll}\n\t\t\\toprule\nGoal:& [attraction]: \\{informable: type architecture area centre\\} \\{requestable: {\\color{red}address phone postcode}\\}\\\\\n\n\t\t\\midrule\n User (Turn 0):& i want to find a place to go in the centre to enjoy some entertainment. can you help?\\\\\nGolden R: &there are [value\\_choice] attraction types in the [value\\_area], did you have one in mind?\\\\\nGolden BS: &[attraction] area centre\\\\\nGolden AS:&   [attraction] [inform] area choice [request] name     \\\\\n Mars-G R:&i am sorry, there are no [value\\_type] attractions in the [value\\_area]. would you like to try another area? \\\\\nMars-G BS: &[attraction] area centre type entertainment\\\\\n  Mars-G AS:&      [attraction] [nooffer] area type [request] area   \\\\\n \n \t\\midrule\nUser (Turn 1): &yes, i am looking for something with the type of architecture. thanks!\\\\\n   Golden R: & i would recommend [value\\_name] as a great place to see interesting [value\\_type].\t\\\\\n Golden BS: & [attraction] area centre type architecture\t\\\\\n Golden AS:&    [attraction] [recommend] name type   \\\\\n  Mars-G R:  &there are [value\\_choice] [value\\_type] attractions in the [value\\_area]. i recommend [value\\_name].\\\\\n  Mars-G BS: & [attraction] area centre type architecture\\\\\n  Mars-G AS:&   [attraction] [recommend] name [inform] type choice area  \\\\\n \n  \t\\midrule\n User (Turn 2):  & okay, {\\color{red}could you give me the address and phone number?}\t\\\\\n  \tGolden R: & sure. the address is [value\\_address]. the phone number is [value\\_phone].\\\\& is there anything else i can help you with today? \\\\\n  \tGolden BS: & [attraction] area centre type architecture \\\\\nGolden AS:&      [attraction] {\\color{red}[inform] address phone} [general] [reqmore] \\\\\n  \t  Mars-G R: & the address is [value\\_address] and the phone number is [value\\_phone]. \\\\\n  \t Mars-G BS: & [attraction] area centre type architecture\\\\\n  Mars-G AS:&     [attraction] {\\color{red}[inform] address phone}  \\\\\n           \n  \t \n\n    \n\t\t\\bottomrule\n\t\\end{tabular}}\\caption{An example in dialog session pmul1320. Noisy dialog annotations cause the requestable slot error. \\label{tab:case9}}\n\\end{table*}\n\n\\end{document}\n</paper 1>\n\n<paper 2>\n\\title{KRLS: Improving End-to-End Response Generation in Task Oriented Dialog with Reinforced Keywords Learning}\n\n\\begin{document}\n\n\\maketitle\n\\begin{abstract}\nIn task-oriented dialogs (TOD), reinforcement learning (RL) algorithms train a model to directly optimize response for task-related metrics.\nHowever, RL needs to perform exploration, which can be time-consuming due to the slow auto-regressive sequence generation process. \nWe investigate an approach to create a more efficient RL-based algorithm to improve TOD performance in an offline setting.\nFirst, we use a faster generation procedure that samples from independent next-word distributions after training the language model (LM) with supervised learning.\nWe then introduce a fine-grained reward function to help the model focus on learning key information in a dialog, by measuring the importance and semantic closeness of each generated token.\nExperiments on the MultiWoZ dataset show our new training algorithm, \\textbf{K}eywords \\textbf{R}einforcement \\textbf{L}earning with Next-word \\textbf{S}ampling (KRLS), achieves state-of-the-art performance on the end-to-end response generation task, with a 15\\% training time reduction compared to a standard RL algorithm using auto-regressive generation\\footnote{Code availale at \\href{https://github.com/jasonyux/KRLS}{https://github.com/jasonyux/KRLS}}.\n\\end{abstract}\n\n\\section{Introduction}\n\nTask-oriented dialog systems help users complete pre-defined tasks such as booking a hotel or reserving a table in a restaurant.\nWith advances in large-scale pre-trained generative models \\cite{GPT3,T5,dialoGPT,godel}, many recent approaches \\cite{DBLP:journals/corr/abs-1910-03756,NEURIPS2020_e9462095,ubar,mttod,galaxy} handle TOD as a holistic task of end-to-end (E2E) generation, as opposed to the traditional modular approach. \n\\begin{figure}[!h]\n  \\centering\n  \\includegraphics[width=1.0\\linewidth]{./images/offline_RL_overview.pdf}\n  \\caption{Overview of episodic training in KRLS. Each turn is treated as a separate episode, and the RL task is to only generate/explore a response at the end. The gold system resp. are also used in our reward computations.}\n  \\label{fig:offline_RL_overview}\n\\end{figure}\n\nIn this E2E setting, the dialog history is often used as input, and reinforcement learning (RL) algorithms can train a model to generate a response that directly optimizes for task-related metrics, such as the task success rate \\cite{multiwoz}.\nHowever, training RL-based dialog models often requires a good user simulator \\cite{user-simulator}, and the training process could be time-consuming as RL often needs to explore and auto-regressively generate many new responses per given input \\cite{rl4lm}.\nFor example, in our experiment, we found that this generation process alone takes 172 minutes/epoch out of the total 362 minutes/epoch during training. \n\\begin{figure*}[!ht]\n    \\centering\n    \\includegraphics[scale=0.57]{./images/RLM_algo.pdf}\n    \\caption{Overview of the KRLS algorithm. During traditional supervised training, the language model learns/imitates the gold response. During offline RL training, the fine-tuned model generates sequences by sampling from next-word distributions conditioned on the gold response and receives a per-token reward.}\n    \\label{fig:KRLS_algo}\n\\end{figure*}\n\nIn this work, we aim to create a more efficient RL procedure for TOD, which does not need a user simulator nor use auto-regressive generation during exploration. We propose a new training algorithm, \\textbf{K}eywords \\textbf{R}einforcement \\textbf{L}earning with Next-word \\textbf{S}ampling (KRLS), which combines a faster sequence generation procedure and a fine-grained per-token reward in an offline setting \\cite{way-off-policy, GOLD}. \nFirst, we treat each turn in a dialog as a separate episode and consider an offline RL task to generate a response only at the end of each episode (see \\Cref{fig:offline_RL_overview}). \nSince this procedure only explores/generates system responses at the last turn, no interactive environment (e.g., a user simulator) is needed.\nDuring this RL process, KRLS generates new sequences by directly sampling from independent next-word distributions, after training a language model with the traditional supervised learning (SL) technique (see \\autoref{fig:KRLS_algo}). %TODO\nThis generation procedure is much faster than the traditional auto-regressive approach, as it only requires a single forward pass. \nNext, KRLS uses a fine-grained per-token reward to help the model focus on learning key information in a dialog, by measuring the importance and semantic closeness of each generated token.\nExperiments on the MultiWoZ dataset show that KRLS achieves state-of-the-art performance on the E2E response generation task, with a 15\\% training time reduction compared to the standard RL approach using auto-regressive generation.\n\nThis paper makes the following contributions:\n\\begin{itemize}\n  \\item We propose an efficient offline RL algorithm that approximates auto-regressive generation by sampling from independent next-word distributions conditioned on the gold response. \n\t\\item We introduce a per-token reward function, which can be used in our offline RL algorithm to promote keyword learning or to incorporate domain knowledge.\n\t\\item We show that our proposed KRLS algorithm can achieve state-of-the-art performance on E2E response generation on MultiWoZ \\cite{multiwoz,multiwoz2.1,multiwoz2.2}.\n\\end{itemize}\n\n\\begin{figure*}[!ht]\n  \\centering\n  \\includegraphics[scale=0.75]{./images/RLM_reward.pdf}\n  \\caption{KRLS reward function. Immediate reward measures the semantic closeness of the generated token and the gold token, scaled by its importance $\\mu$. Return for each sampled token is a combination of individual immediate reward and future rewards. Future rewards will help propagate final overall scores, such as overall task performance. Key tokens in a response are bolded and italicized.}\n  \\label{fig:KRLS_reward}\n\\end{figure*}\n\n\\section{Background}\n\\label{sec:Background}\n\nTo introduce RL in NLP tasks, we begin by formulating the response generation process as an MDP. Given a supervised dataset $\\mathcal{D} = \\{ (\\mathbf{c}^{i}, \\mathbf{x}^{i}) \\}$ where $\\mathbf{c}^{(i)}$ is the context and $\\mathbf{x}^{(i)}$ is a response, the probability of generating $\\mathbf{x}^{(i)}$ can be modeled as:\n\\[\np(\\mathbf{x}^{(i)}|\\mathbf{c}^{(i)}) = \\prod_{t=1}^{T-1} p(x^{(i)}_{t+1}|x^{(i)}_{1:t},\\mathbf{c}^{(i)}),\n\\] \nwhere $x_t^{(i)}$ is the $t$-th token in the $i$-th response, and $T$ is the length of the response. As mentioned in \\citet{rl4lm,lava}, this generation can be formulated as a MDP problem $\\langle \\mathcal{S}, \\mathcal{A}, \\mathcal{R}, \\mathcal{P}, \\gamma \\rangle$. The input context $\\mathbf{c}^{(i)}$ would be the initial state $s_{0} \\in \\mathcal{S}$, and the response $\\mathbf{x}^{(i)}$ would represent the sequence of actions $\\mathbf{a}^{(i)} = \\{a_1^{(i)}, a_2^{(i)}, \\dots, a_{T-1}^{(i)}\\}$ in an episode, where $a_t^{(i)} \\in \\mathcal{A}$ is the $t$-th token in the $i$-th response. The reward function $\\mathcal{R}$ would represent the ``utility'' of each action contributing towards the overall performance, such as task success in TOD. Typically, this is modeled by using $\\mathcal{R}(s,a)=0$ for non-terminal states, and $\\mathcal{R}(s_T,a)$ for terminal states which can be computed by combining scores such as task success and BLEU \\cite{rl4lm, director}. The transition function $\\mathcal{P}: \\mathcal{S}\\times \\mathcal{A}\\to \\mathcal{S}$ would deterministically append the action $a_t$ to the current state $s_t$ so that $s_{t+1} = (c_0, \\dots, c_m, a_0, \\dots, a_{t})$. Finally, $\\gamma \\in [0,1)$ is the discount factor.\n\n\\section{Approach}\nIn the MulitiWoZ dataset \\cite{multiwoz,multiwoz2.1, multiwoz2.2}, we observe that key information, such as restaurant ``phone number'' and ``address'', needs to be \\emph{generated} correctly in a response to achieve a high task success/inform rate.\nHowever, traditional SL uses a negative log-likelihood loss, which asks the language model to uniformly learn all correct tokens $x^{\\mathrm{gold}}$ given input context $c$, without explicitly focusing on achieving task-related objectives:\n\\begin{equation}\\label{eq:lm_loss}\n  \\begin{split}\n    \\mathcal{L}_{\\mathrm{SL}}(\\theta)\n    &= - \\sum\\limits_{x} p(x|c) \\log p_\\theta(x|c) \\\\\n    &= -\\log p_\\theta(x^{\\mathrm{gold}}|c)\n  \\end{split}\n\\end{equation}\nwhere the probability of $p(x|c)=0$ if $x \\neq x^{{\\mathrm{gold}}}$. We will refer to models fine-tuned with this objective as \"$\\mathcal{L}_{\\mathrm{SL}}$-finetuned\".\n\nWe hypothesize that it can be beneficial to use RL and a fine-grained per-token reward function to help promote keyword learning and improve TOD performance. \nFirst, in \\Cref{sec:RL with Next-word Sampling} we propose a fast sequence generation procedure that can be used during RL training/exploration, and utilize policy-gradient based methods \\cite{policy-gradient,REINFORCE, PPO} to optimize response generation for task-related metrics. Then, in \\Cref{sec:Per-Token Reward Function} we design a fine-grained reward function $\\mathcal{R}(x|c)$ according to \\emph{how important} each generated token is, but also \\emph{how close} it is from the gold token, so that the model can focus more on learning key information once it can generate non-key tokens semantically close to the reference. Finally, we describe our KRLS algorithm in \\Cref{sec:KRLS Training Algorithm} and \\Cref{algo:krls_algorithm}, which utilizes RL combined with our proposed generation method and reward function.\n\n\\subsection{RL with Next-word Sampling}\n\\label{sec:RL with Next-word Sampling}\nTo avoid the slow auto-regressive sequence generation process during RL training, we propose an alternative sequence generation mechanism that can be used for RL exploration.\nFirst, we assume that there is a model $p_\\theta$ that generates sequences similar to the gold responses in the \\emph{training set}. \nThen, under this assumption, we can approximate the MDP process of auto-regressive sequence generation by sampling from the next-word distributions conditioned on the gold response.\nThis is because if previously generated tokens are similar to the gold context (e.g., after $\\mathcal{L}_{\\mathrm{SL}}$ training), then conditioning on those generated tokens is similar to conditioning on the gold tokens.\nIn this setting, the next-word sampling process could approximate auto-regressive generation used during RL, but it is much faster as each token is generated in parallel.\n\nSpecifically, we first perform a forward pass to obtain the next-word distributions for $x_{t}^{\\mathrm{gen}}$ given the context and the gold response up to $t-1$:\n\\begin{equation}\\label{eq:next-word-dist}\n  \\left\\{ p_\\theta(x^{\\mathrm{gen}}_{1}|\\mathbf{c}^{(i)}), \\dots, p_\\theta(x^{\\mathrm{gen}}_{T}|x^{(i)}_{1:T-1},\\mathbf{c}^{(i)}) \\right\\}\n\\end{equation}\nThen, we generate each next-token $a_{t}=x^{\\mathrm{gen}}_t$ by sampling from $p_\\theta(X=x|x^{(i)}_{1:t-1},\\mathbf{c}^{(i)};\\tau)$ with temperature $\\tau$. Finally, given some suitable reward function $\\mathcal{R}(s_t, a_t)\\in [-1,1]$ (see \\Cref{sec:Per-Token Reward Function} for details), we can use policy gradient methods \\cite{policy-gradient, REINFORCE} to perform a ``weighted learning'' on each generated token: \n\\begin{equation}\\label{eq:real_policy_gradient}\n  \\nabla \\mathcal{L}(\\theta) = -G_t \\nabla \\log p_\\theta(x_t|c)\n\\end{equation}\n\nNote that this procedure is much faster than auto-regressive generation as it only requires one forward pass. Moreover, it is suitable for training a model to focus on generating key information, because we can use the gold response as an oracle to locate those key positions and penalize each generated token in the reward function accordingly. \n\n\\subsection{Per-Token Reward Function}\n\\label{sec:Per-Token Reward Function}\n\nTo improve a model's keyword generation ability, we design a reward function that measures the \\emph{importance} and \\emph{semantic closeness} of each generated token.\nThis reward aims to prioritize accurate generation of key tokens, and also contextually evaluate how far-off is each generated token from the ground truth.\nWe draw inspiration from BERTScore \\cite{BERTScore}, which uses a separate neural network to compute a contextual semantic score of the generated sequence by comparing it against the gold reference. \nHowever, we found that directly adapting BERTScore to a per-token reward function is sub-optimal in our setting, as our generated sequence is ``sampled'' from the gold response. Therefore, we consider a simpler approach, utilizing the fact that our generation procedure provided a one-to-one mapping between each generated token and the gold token. \n\nFirst, we use a $\\mathcal{L}_{\\mathrm{SL}}$-finetuned decoder network $\\mathrm{Decoder}(\\phi)$ to compute the probability $p_\\phi(X_t=x|x^{(i)}_{1:t-1},\\mathbf{c}^{(i)})$ of generating any token $x$ at time $t$, which can be done in a single forward pass. Then, we index into this probability distribution to find $p_\\phi(X=x^{\\mathrm{gen}}_t|x^{(i)}_{1:t-1},\\mathbf{c}^{(i)})$ of our generated tokens, as a measure of the \\emph{semantic appropriateness} of $x^{\\mathrm{gen}}_t$ in the given context. \nTo ensure that $\\mathcal{R}$ correctly reflects the gold tokens as the optimal choice, we manually set this semantic closeness score to $1$ for \\emph{any token} that is correctly generated $x^{\\mathrm{gen}}_t = x_t^{\\mathrm{gold}}$.\nTo emphasize keyword learning, we also strictly set this closeness score to $-1$ if a \\emph{key token} is incorrectly generated. Otherwise, we use the probability $p_\\phi$ produced by the decoder network as the closeness score.\nFinally, we adjust the reward for key tokens by an \\emph{importance} scale $\\mu>1$, which is a hyper-parameter for specifying the relative importance between keywords and non-keywords. This gives our per-token reward:\n\\begin{equation}\\label{eq:reward}\n  \\mathcal{R}(s_t,a_t) = \\mathrm{closeness}(x^{\\mathrm{gen}}_t, x^{\\mathrm{gold}}_t, \\mathbf{\\bar{c}}) \\cdot \\mu\n\\end{equation}\nWe standardize $\\mathcal{R}$ to $[-1,1]$ to be later compared with other related reward functions in \\Cref{sec:Per-Token Reward Function Ablation}.\n\\begin{algorithm}\n\t\\caption{KRLS Training Algorithm}\\label{algo:krls_algorithm}\n\t\\begin{algorithmic}[1]\n  \\Require generative network $p_\\theta$\n  \\Require semantic scoring network $p_\\phi$\n  \\Require supervised language dataset $\\mathcal{D}$\n  \\Require empty buffer $B_{\\mathrm{L}}, B_{\\mathrm{S}}$\n  \\State Repeat for $n$ epochs:\n\t\\For{batch $b_{i}$ in $\\mathcal{D}=\\{ b_{1}, \\dots, b_{m} \\}$}\n    \\State Perform sup. learning on $b_{i}$ (\\autoref{eq:lm_loss})\n    \\State Update generative network $p_\\theta$\n    \\State Append $b_{i}$ to buffer $B_{\\mathrm{L}}$\n    \\If{$i$\\% $\\kappa == 0$}\n    \\For{each batched episode $b_{j}$ in $B_{\\mathrm{L}}$}\n    \\State Collect $k$ samples per episode \\\\ \\label{lst:line:}\n      \\qquad\\qquad\\qquad by sampling from \\autoref{eq:next-word-dist}\n    \\State Calculate per-token reward \\\\\n      \\qquad\\qquad\\qquad using $p_\\phi$ and \\autoref{eq:reward}\n    \\State Calculate per-token returns $G_t$\n    \\State Append all to replay buffer $B_{\\mathrm{R}}$ \\label{lst:line:replay_buf}\n    \\EndFor\n    \\State Perform RL on $B_{\\mathrm{R}}$ \n    (e.g., PPO)\n    \\State Update generative network $p_\\theta$\n    \\State Clear $B_{\\mathrm{L}}$ and $B_{\\mathrm{R}}$\n    \\EndIf\n\t\\EndFor\n\t\\end{algorithmic}\n\\end{algorithm}\n\\subsection{KRLS Training Algorithm}\n\\label{sec:KRLS Training Algorithm}\n\\Cref{algo:krls_algorithm} describes our KRLS training algorithm. Given a supervised dataset $\\mathcal{D}=\\{\\mathbf{c}_{i}, \\mathbf{x}_i^{\\mathrm{gold}}\\}_{i=1}^N$ consisting of the dialog context $\\mathbf{c}_{i}$ and the gold response $\\mathbf{x}_i^{\\mathrm{gold}}$ at each turn, we train a neural network $p_\\theta$ to generate a response that satisfies the user's need given by $\\mathbf{c}_{i}$. A separate neural network $p_\\phi$ is used to compute the reward function during RL phase (see \\Cref{sec:Per-Token Reward Function}).\n\nFor each epoch, we first perform SL over several batches of training examples and update our network $p_\\theta$. This is because our generation procedure is based on the assumption stated in \\Cref{sec:RL with Next-word Sampling}, so we periodically train $p_\\theta$ with the $\\mathcal{L}_{\\mathrm{SL}}$ objective to imitate the gold responses before passing over to RL (see \\Cref{sec:KRLS Sampled Response Examples} for generated sequences). Then, we store those SL-trained batches into a buffer $B_L$, and perform RL on this learned buffer. During this RL training, we first generate $k$ responses per trained episode by next-word sampling (see \\Cref{sec:RL with Next-word Sampling}), calculate their rewards and returns using a scoring network $p_\\phi$, and append them to a replay buffer $B_R$. Then, we utilize the clipped policy gradient objective from Proximal Policy Optimization \\cite{PPO} to learn from $B_R$ and update the generative policy model $p_\\theta$ (see \\Cref{sec:KRLS RL Details} and \\Cref{sec:KRLS PPO v.s. PG}).\n\nNote that \\Cref{algo:krls_algorithm} only additionally requires prior definitions of keywords to compute the reward. This means that such an approach can be generic to many task-oriented dialogues where keywords can be easily defined (e.g., using entities from a database). For instance, in movie recommendation \\cite{movielens}, correctly generating key information such as ``movie\\_ratings'' and ``movie\\_genres'' could be helpful to improve the system's response. Additionally, we believe that for other dialogue tasks such as QA/social chat, keywords can often be automatically processed and defined, such as using the entities mentioned in WikiQA answers \\cite{yang-etal-2015-wikiqa} and the intent keywords in ESConv \\cite{liu2021emotional}.\n\\begin{table*}[!t]\n  \\centering\n  \\scalebox{0.85}{\n  \\begin{tabular}{l c c c c c} \n     \\toprule\n     \\multirow{2}{*}{{{Model}}} & \\multirow{2}{*}{{{Backbone}}} & \\multicolumn{4}{c}{{Response Generation}} \\\\\n      & & {{Inform}} & {{Success}} & {BLEU} & {Combined}\\\\\n     \\midrule\nSOLOIST \\cite{peng2021soloist} & GPT-2     & 82.3 & 72.4 & 13.6 & 90.9   \\\\\nDoTS \\cite{jeon2021domain} & BERT-base    & 80.4 & 68.7 & 16.8 & 91.4   \\\\\nUBAR \\cite{yang2021ubar} & DistilGPT-2  & 83.4 & 70.3 & 17.6 & 94.4   \\\\\nPPTOD \\cite{su2021multitask} & T5-base     & 83.1 & 72.7 & 18.2 & 96.1   \\\\\nBORT \\cite{sun-etal-2022-bort} & T5-small     & 85.5 & 77.4 & 17.9 & 99.4   \\\\\nMTTOD \\cite{mttod} & T5-base     & 85.9 & 76.5 & 19.0 & 100.2  \\\\\nGALAXY \\cite{galaxy} & UniLM-base & 85.4 & 75.7 & 19.0 & 100.2  \\\\\nMars-G$^{\\dagger}$ \\cite{mars} & T5-small & {88.9} & 78.0 & \\textbf{19.9} & {103.4}  \\\\\n\\addlinespace[0.25em]\n\\hdashline\n\\addlinespace[0.25em]\nBaseline (MTTOD)& GODEL-base & 86.0 & 77.4 & 18.9 & 100.6  \\\\\nKRLS           & GODEL-base \n  &{87.3} (\\small 87.2$\\pm$0.3\\par) & 78.3 (\\small 78.2$\\pm$0.5\\par)\n  &19.2 (\\small 19.1$\\pm$0.3\\par) & 102.0 (\\small 101.9$\\pm$0.5\\par)\\\\\nfinetune+KRLS  & GODEL-base \n  &\\textbf{89.2} (\\small 89.2$\\pm$0.3\\par)& \\textbf{80.3} (\\small 80.0$\\pm$0.4\\par)\n  &{19.0} (\\small 19.0$\\pm$0.2\\par) & \\textbf{103.8} (\\small 103.5$\\pm$0.4\\par)  \\\\\n\\bottomrule\n  \\end{tabular}\n  }\n  \\caption{MultiWoZ 2.2 end-to-end response generation evaluation. Results are ``$\\text{best run}\\ (\\mu, \\sigma)$'' over three runs. The results of previous works are from the official leaderboard of MultiWOZ. $^{\\dagger}$ indicates concurrent work.}\n  \\label{tbl:multiwoz_results}\n  \\vspace{5pt}\n\\end{table*}\n\\begin{table}[]\n  \\centering\n  \\scalebox{0.85}{\n  \\begin{tabular}{l c c} \n     \\toprule\n     {Algo} & {Generation Time} & {Training Time}\\\\\n     \\midrule\n     KRLS& \\phantom{0}48 min/epoch & \\space 306 min/epoch \\\\\n     std. RL  & 172 min/epoch & 362 min/epoch \\\\\n     \\bottomrule\n  \\end{tabular}\n  }\n  \\caption{Training speed comparison between KRLS and RL. In standard RL (\\algo{std. RL}), auto-regressive sequence generation is used for experience collection.}\n  \\label{tbl:training_time}\n\\end{table}\n\\section{Experiments}\n\\label{sec:Experiments}\n\n\\subsection{Dataset and Preprocessing}\n\\label{sec:Dataset and Preprocessing}\nWe evaluate our algorithm on the MultiWoZ dataset \\cite{multiwoz}. MultiWoZ is a large-scale multi-domain TOD dataset consisting of 8438, 1000, and 1000 dialogs for training, validation, and test sets respectively. The dataset consists of seven domains: attraction, hotel, hospital, police, restaurant, taxi, and train. Each dialog consists of a sequence of user utterances and system responses, all annotated with the corresponding dialog state and system action.\n\nWe follow the preprocessing procedure from \\citet{multiwoz-preprocess} to delexicalize slot values for each system response, and use the standardized evaluation script released by \\citet{multiwoz-eval}, which has also been adopted by the official MultiWoZ dataset.\n\n\\subsection{Evaluation Metrics}\n\\label{sec:Evaluation Metrics}\nIn our experiments, we primarily consider the task of end-to-end response generation. In MultiWoZ, response generation performance is evaluated by a combination of three metrics: \\textbf{Inform rate} measures whether the system has provided an appropriate entity; \\textbf{Success rate} measures whether the system has answered all the requested attributes; \\textbf{BLEU} measures the fluency as compared to the references, which are also delexicalized. Finally, the \\textbf{Combined} score is calculated as $(\\mathrm{Inform}+\\mathrm{Success}) \\times 0.5 +\\mathrm{BLEU}$.\n\\subsection{Model Architecture and Baseline}\n\\label{sec:Model Architecture and Baseline}\nIn this work, we use GODEL-base \\cite{godel} as a backbone, which is a T5-base model \\cite{T5} pretrained on both texts and dialog datasets (except MultiWoZ).\n\n\\textbf{Baseline} We use MTTOD \\cite{mttod}, which achieves previous state-of-the-art performance in response generation by performing SL with additional multi-task training. We re-train MTTOD with GODEL-base \\cite{godel} as the backbone, and report this as \\emph{Baseline (MTTOD)}.\n\n\\textbf{KRLS} Since KRLS targets at improving response generation, we replace the SL objective during response training in MTTOD with the KRLS algorithm, which involves both SL and RL training. We report this result as \\emph{KRLS}.\n\n\\textbf{finetune+KRLS} \nAs the generation procedure in KRLS is based on the assumption stated in \\Cref{sec:RL with Next-word Sampling}, we first initialize the model with an $\\mathcal{L}_{\\mathrm{SL}}$-finetuned checkpoint, and then perform the same KRLS training procedure as used in \\emph{KRLS}. \nWe report this result as \\emph{finetune+KRLS}.\n\nMore details in training/hyperparameters can be found in \\Cref{sec:Implementation and Training Details}.\n\n\\subsection{Main Results}\n\\label{subsec:Main Results}\n\\autoref{tbl:multiwoz_results} summarizes the results of end-to-end response generation performance on MultiWoZ. As shown in \\autoref{tbl:multiwoz_results}, when trained with KRLS directly from backbone (\\algo{KRLS} in \\Cref{tbl:multiwoz_results}) we achieve an improvement of 1.4 in Combined Score compared to the baseline, which mostly comes from increased inform and success rate. \nSince inform/success rate evaluates how often informable/requestable slot values (i.e. keywords) are generated correctly, this suggests that KRLS can help reinforce a model's ability to generate key tokens (see \\Cref{subsec:Keyword Learning}).\n\nWhen trained from an $\\mathcal{L}_{\\mathrm{SL}}$-finetuned checkpoint (\\algo{finetune+KRLS}), KRLS further improves to a combined score of 103.8, with major improvements again in the success and inform rate. We believe this is because, as the model has already been finetuned on the entire training dataset, the assumption mentioned in \\Cref{sec:RL with Next-word Sampling} is better satisfied (see \\Cref{sec:KRLS Sampled Response Examples} for examples). \nThen, KRLS can better improve a model's keyword generation ability as compared to the case when trained from backbone.\n\n\\Cref{tbl:training_time} compares the training speed of the KRLS algorithm with standard RL training which uses auto-regressive generation.\nDuring standard RL training, we removed the SL step in \\Cref{algo:krls_algorithm}, and only use a terminal reward during RL as newly generated sequences no longer have a one-to-one mapping to the tokens in gold response (more details in \\Cref{sec:RL with Auto-Regressive Gen. Setup}).\nWe then measure the total wall-clock time per epoch spent by each algorithm during training and separately during experience collection (line 7-14 in \\Cref{algo:krls_algorithm}).\nWhile additionally initializing KRLS with a $\\mathcal{L}_{\\mathrm{SL}}$-finetuned checkpoint (\\emph{finetune+KRLS}) achieves a better performance, we note that the same procedure is often used for RL training in NLP \\cite{rl4lm}. Due to the large exploration space for language models, RL algorithms may require many more epochs to train without initializing from a finetuned checkpoint (see \\Cref{sec:Training KRLS from Scratch}). Therefore, we focus our comparison solely on running the KRLS algorithm and the standard RL algorithm.\n\nAs shown in \\Cref{tbl:training_time}, the experience collection time (\\emph{Generation Time}) for KRLS is much shorter than RL using auto-regressive generation, as in KRLS only a single forward pass is needed for sequence generation. However, since KRLS additionally includes SL (68 min/epoch) and a per-token reward computation, the total training time per epoch becomes 306 min/epoch, though still 15\\% faster than the 362 min/epoch with standard RL, which only includes experience collection and PPO training (190 min/epoch).\n\\begin{table}[!t]\n  \\centering\n  \\scalebox{0.75}{\n  \\begin{tabular}{lccc} \n      \\toprule\n     {Metric} & {ft+KRLS Win}  & {MTTOD Win} & {Tie} \\\\\n     \\midrule\n     Fluency & 34.7\\% & \\textbf{48.0\\%} & 17.3\\% \\\\\n     Appropriateness & \\textbf{55.3\\%*} & 30.7\\% & 14.0\\% \\\\\n     Informativeness & \\textbf{60.7\\%*} & 26.7\\% & 12.7\\% \\\\\n     Overall& \\textbf{59.3\\%*} & 29.3\\% & 11.3\\% \\\\\n  \\bottomrule\n  \\end{tabular}\n  }\n  \\caption{Human evaluation on the generated responses. * indicates $p<0.01$. Fluency result has no statistical significance due to large variances among annotators.}\n  \\vspace{-5pt}\n  \\label{tbl:human_eval}\n\\end{table}\n\n\\subsection{Human Evaluation}\n\\label{subsec:Human Evaluation}\nWe consider the possibility that automatic metrics from MultiWoZ may not correlate well with human judgements \\cite{liu2016not, lubis-etal-2022-dialogue}. \nThus, we ask crowd-workers on Amazon Mechanical Turk to compare responses generated by baseline (\\emph{MTTOD}) and finetune+KRLS (\\emph{ft+KRLS}). The responses are rated in terms of their 1) \\emph{appropriateness}\\footnote{For \\emph{appropriateness} and \\emph{fluency}, we followed the definitions from prior work \\cite{zhang2020task, ramachandran2021causal, gptcritic, feng2023fantastic}.}, \n2) \\emph{fluency}, \n3) \\emph{informativeness}, and 4) \\emph{overall} quality given a dialogue context.\nWe randomly picked 50 turns in the test set, and provided the generated responses without delexicalization and the dialogue history up to that turn. For each metric, the crowd-workers were to choose which response is better, or if it is a tie. \nWe collected preference from 3 crowd-workers per sampled turn. \n\n\\Cref{tbl:human_eval} summarizes the human evaluation results. \nOur method has been rated more appropriate, informative, and overall more preferred by Turkers.\nWe believe this coincides with the results in \\Cref{tbl:multiwoz_results} that our method performs better in inform and success rate, by providing more relevant key information. \nThere is no statistical significance in the fluency result (p > 0.05), which is expected given both models' comparable BLEU scores. Specifically, only 16\\% of the dialogues have more than one annotator rating {MTTOD} as more fluent. We believe this is because many pre-trained LMs can already generate fluent texts, and it is often challenging for humans to notice the difference.\n\n\\begin{table*}[!t]\n  \\centering\n  \\scalebox{0.725}{\n  \\begin{tabular}{l*{12}{c}} % Simplified this for readability; adjust if you add/remove columns.\n     \\toprule\n     \\multirow{2}{*}{{Model}} & \\multicolumn{4}{c}{{5\\%}} & \\multicolumn{4}{c}{{10\\%}} & \\multicolumn{4}{c}{{20\\%}}\\\\\n     \\cmidrule(lr){2-5} \\cmidrule(lr){6-9} \\cmidrule(lr){10-13}\n     & {Inform}& {Success} & {BLEU} & {Combined} & {Inform}& {Success} & {BLEU} & {Combined} & {Inform}& {Success} & {BLEU} & {Combined}\\\\\n     \\midrule\n     MTTOD & 51.1 & 20.7 & 9.5 & 46.6 & 63.1 & 44.4 & 13.8 & 67.7 & 75.0 & 61.0 & 16.8 & 84.8\\\\\n     ft+KRLS & \\textbf{55.0} & \\textbf{22.7} & \\textbf{11.5} & \\textbf{50.3} & \\textbf{64.8} & \\textbf{47.4} & \\textbf{15.4} & \\textbf{71.9} & \\textbf{78.9} & \\textbf{65.0} & \\textbf{17.2} & \\textbf{89.2}\\\\\n     \\bottomrule\n  \\end{tabular}\n  }\n  \\caption{MultiWoZ end-to-end response generation performance using 5\\%, 10\\%, and 20\\% of training data. ``ft+KRLS'' refers to \\emph{finetune+KRLS}. Both models use GODEL-base as backbone. Results are shown as mean values over three runs.}\n  \\label{tbl:multiwoz_low_resource_full}\n\\end{table*}\n\\subsection{Low Resource Experiment}\n\\label{sec:Low Resource Experiment}\nSince large and well-annotated dialogue datasets such as MultiWoZ \\cite{multiwoz} is not easy to create in practice, we also investigate KRLS's performance under a low-resource regime. We use 5\\%, 10\\%, and 20\\% of training data to train both baseline (\\emph{MTTOD}) and \\emph{finetune+KRLS}, and report their performance in \\Cref{tbl:multiwoz_low_resource_full}. In \\Cref{tbl:multiwoz_low_resource_full} we find our method outperforms the baseline in all settings. We also find large contributions often from improving inform and success scores, which indicates the effectiveness of KRLS at key token learning without abundant training data.\n\n\\section{Ablation Studies}\n\\label{sec:Ablation Study}\n\\subsection{KRLS Algorithm Ablation}\n\\label{subsec:KRLS Algorithm Ablation}\nSince KRLS effectively combines SL and RL, we illustrate the contribution of each component in \\Cref{tbl:rl_cmp}. During \\algo{SL Only} and \\algo{RL Only}, we remove the RL training and SL training in KRLS, respectively. In \\emph{SL+GOLD}, we replace our RL procedure with GOLD \\cite{GOLD}, which is an offline and off-policy RL algorithm that learns from the gold demonstrations without any generation (see \\Cref{sec:Ablation Study Setup: GOLD} for more details), so that we can also isolate the impact of additionally generating a sequence in our approach. Since GOLD uses Policy Gradient \\cite{policy-gradient} without clipping, we do the same with KRLS here (denoted \\algo{KRLS(PG)}).\n\nAs shown in \\Cref{tbl:rl_cmp}, using \\algo{SL+GOLD} only achieved a similar performance as compared to \\algo{SL Only}. We believe that this is because \\algo{GOLD} only intends to learn from the gold responses, while KRLS(PG) also attempts to explore other sequences/tokens to reinforce its keyword learning. Additionally, if the SL objective is removed from KRLS when directly trained from backbone, the performance degrades as the assumption mentioned in \\Cref{sec:RL with Next-word Sampling} becomes harder to satisfy (c.f. KRLS in \\Cref{tbl:multiwoz_results}, and discussions in \\Cref{sec:Training KRLS from Scratch}).\\footnote{In our prior study, we also experimented with a simple alternative of only using weighted SL on key tokens, removing RL entirely. However, weighted SL only yields a minor improvement compared to the baselines, reaching a score of 101.2. KRLS using a similar reward function (\\emph{Error}, see \\Cref{sec:Per-Token Reward Function Ablation}) already achieves 102.5. We believe this is because KRLS rewards/penalizes generated tokens sampled from the model's distribution using RL, while SL only uses the gold tokens. This finding motivates KRLS to use RL with a reward function emphasizing on keyword learning.}\n\n\\begin{table}[t]\n  \\centering\n  \\scalebox{0.85}{\n  \\begin{tabular}{lcccc}\n    \\toprule % Instead of \\hline\n    {Algo} & {Inform} & {Success} & {Bleu} & {Total}\\\\\n    \\midrule % Instead of \\hline\n    SL Only & 86.0 & 77.4 & 18.9 & 100.6  \\\\\n    RL Only & 84.2 & 72.2 & 17.5 & 95.7 \\\\\n    \\addlinespace[0.25em]\n    \\hdashline\n    \\addlinespace[0.25em]\n    SL+GOLD & 86.1 & 77.1 & 18.8 & 100.4 \\\\\n    KRLS(PG) & \\textbf{88.7} & \\textbf{78.7} & \\textbf{19.1} & \\textbf{102.8} \\\\\n    \\bottomrule % Instead of \\hline\n  \\end{tabular}\n  }\n  \\caption{KRLS Ablation Study. The first two are trained directly from the backbone, and the latter two are trained from a $\\mathcal{L}_{\\mathrm{SL}}$-finetuned checkpoint (see more details in \\Cref{sec:Ablation Study Setup: GOLD}).}\n  \\label{tbl:rl_cmp}\n\\end{table}\n\n\\subsection{Reward Function Ablation}\n\\label{sec:Per-Token Reward Function Ablation}\nIn \\Cref{tbl:token_level_semantic_score_finetuned}, we empirically compare our proposed reward with 4 different reward functions and show that: a) providing a per-token reward in addition to providing a terminal reward for the entire sequence is helpful, and b) a fine-grained, context-aware reward that correctly factors in our generation procedure can further improve performance.\n\nIn this experiment, we replace our proposed reward in \\Cref{sec:Per-Token Reward Function} (denoted as \\algo{Prob.} in \\Cref{tbl:token_level_semantic_score_finetuned}) with the following alternatives: \\algo{Zero}, which assigns a zero score to all generated tokens, hence only uses the terminal reward for training; \n\\algo{Error}, which assigns a hard penalty of $\\pm \\mu$ whenever the generated token is correct/incorrect; \n\\algo{BERTS.}, which uses the core mechanism in BERTScore \\cite{BERTScore} to measure the semantic similarity between the generated tokens and the gold tokens (see \\Cref{sec:BERTScore for KRLS} for more details); \n\\algo{Static.}, which takes the static, context-\\emph{unaware} token embeddings from the embedding layer of GODEL-base and compute their cosine similarity as reward. In all cases, the same set of hyperparameters is used to make results more comparable.\n\\begin{table}[t]\n  \\centering\n  \\scalebox{0.9}{\n  \\begin{tabular}{l c c c c} \n     \\toprule\n     \\multicolumn{5}{c}{{Finetune+KRLS}}\\\\\n     {Reward} & {Inform} & {Success} & {BLEU} & {Total}\\\\\n     \\midrule\n     \\emph{None} & 86.0 & 77.4 & 18.9 & 100.6  \\\\\n     Zero & 88.3 & 77.9 & {18.9} & 102.0\\\\\n     Error & 88.8 & 78.5 & 18.8 & 102.5\\\\\n     Static. & 88.7 & 78.4 & 18.8 & 102.4\\\\\n     BERTS. & 88.5 & 78.7 & {18.9} & 102.5\\\\\n     Prob.  & \\textbf{89.2} & \\textbf{80.3} & \\textbf{19.0} & \\textbf{103.8} \\\\\n     \\bottomrule\n  \\end{tabular}\n  }\n  \\caption{KRLS using different per-token reward when trained from a finetuned checkpoint. \\emph{None} refers to the baseline of training only with supervised learning.}\n  \\label{tbl:token_level_semantic_score_finetuned}\n\\end{table}\n\nAs shown in \\Cref{tbl:token_level_semantic_score_finetuned}, our proposed token-level reward (\\algo{Prob.}) outperforms all other alternatives. Interestingly, all reward functions that specified a per-token reward (i.e. \\algo{Error}, \\algo{BERTS.}, \\algo{Static.}, \\algo{Prob.}) achieved improvements over \\algo{Zero}, which only relies on the terminal reward. This indicates that a more fine-grained per-token reward function is helpful. Additionally, \\algo{Prob.} improves upon \\algo{Error}, \\algo{BERTS.}, and \\algo{Static.}, because it additionally factors in our generation procedure that the generated sequence is conditioned on the gold response. Therefore, it can also correctly capture the contextual relationship of the generated tokens.\n\\section{Analysis}\n\\label{sec:Analysis}\n\\subsection{Keyword Learning}\n\\label{subsec:Keyword Learning}\nSince KRLS aims to improve the model's ability to generate key information correctly, we track the model's accuracy in generating key tokens during training and validation. \nIn this experiment, we feed in the gold contexts up to the key tokens, and the model is tasked to generate the next token. \nWe then calculate the accuracy by measuring how often the generated token matches the gold key token.\n\nAs shown in \\Cref{fig:keyword_learning}, only performing SL (\\algo{baseline}) leads to a slow increase in keyword generation accuracy during early training, as the model focuses on learning other non-key tokens due to their abundance. On the other hand, KRLS periodically uses RL to help the model focus on learning key tokens, which leads to a higher keyword generation accuracy throughout both training and validation (more details in \\Cref{sec:Additional Keyword Learning Curves}).\n\\begin{figure}[t!]\n  \\centering\n  \\includegraphics[scale=0.4]{./images/keyword_validation.png}%\n  \\caption{Keyword generation accuracy during validation. \\emph{Baseline} is trained with only supervised learning, $\\mathcal{L}_{\\mathrm{SL}}$. Both models are trained directly from backbone to additionally demonstrate the difference during early training.}\n  \\label{fig:keyword_learning}\n  \\vspace{2pt}\n\\end{figure}\n\\begin{table}[t]\n  \\centering\n  \\scalebox{0.9}{\n  \\begin{tabular}{l c c c c} \n     \\toprule\n     {Algo} & {Inform} & {Success} & {BLEU} & {Total}\\\\\n     \\midrule\n     KRLS & {89.2} & {80.3} & {19.0} & {103.8}\\\\\n     \\, +DST & {93.1} & {83.7} & {19.1} & {107.5}\\\\\n     \\, +Both & {93.5} & {90.9} & {29.8} & {122.0}\\\\\n     \\addlinespace[0.21em]\n     \\hdashline\n     \\addlinespace[0.21em]\n     \\emph{Train} & 93.7& 90.9 & - & -  \\\\\n     \\midrule\n  \\end{tabular}\n  }\n  \\caption{Test performance of KRLS when generating with Gold Dialog State (+DST), and with both Gold Dialog State and Gold System Act (+Both). \\emph{Train} is the performance of the training dataset. Note that +DST is the same as the ``policy optimization'' task.}\n  \\label{tbl:using_gold}\n\\end{table}\n\\subsection{Error Analysis}\n\\label{subsec:Error Analysis}\nDespite reaching a higher inform rate and success rate as more key tokens are generated correctly, we still observe responses that miss some key tokens. We found that these errors often originate from incorrectly generated dialog states and system acts (see \\Cref{sec:KRLS Error Examples} for examples). This is understandable, as we only used KRLS to improve the response generation component. \n\nTo quantify these errors, we additionally use our KRLS-trained model to generate responses when a) the gold dialog state is provided (\\algo{+DST}) and b) both the gold dialog state and the gold system action are provided (\\algo{+Both}). We present this result in \\Cref{tbl:using_gold}, and found that \\algo{+DST} improved the overall score by nearly 4 points, and \\algo{+Both} further improved the overall score by 14.5 points, almost reaching the performance of the training dataset\\footnote{\nIn MultiWoZ, the training dataset includes human errors, hence does not have a perfect inform/success score. Validation/test datasets are hand-picked to only include successful dialogs, so that model performance can be fairly evaluated.}. \nThis shows that much error remains in the DST and system act generation process, so the overall performance can further increase if techniques to separately improve DST and system act generation (e.g., \\citet{mars}) can be combined with KRLS. We leave this for future work.\n\\section{Related Work}\n\\label{sec:Related Work}\n\nEnd-to-end dialog systems such as \\citet{e2e-tod,ubar,mttod,galaxy} have shown promising results in TOD benchmarks such as \\dataset{MultiWoZ}. However, as the standard SL objective does not directly account for TOD metrics such as task success rate, much recent work seeks to incorporate RL techniques to improve TOD performance. In this section, we discuss related applications of RL in TOD, as well as other non-RL-based approaches that have similarities in concept.\n\n\\textbf{RL for Text Generation}\n\\citet{mixer, deep-rl-for-gen, mix-on-and-off-policy, rl4lm} applies RL to text generation tasks by treating each word as an action and then uses auto-regressive generation to explore high-reward sequences.\nThis results in a large action space for exploration, and these work focuses on methods to stabilize the training process. In principle, these approaches can be modified for TOD tasks, but they would still generally use a user simulator and/or the slow auto-regressive generation step.\n\n\\textbf{RL for Policy Planning}\nMany direct applications of RL in TOD focus on optimizing dialog policy planning \\cite{multiagent-nlp, jotus, lava}. \\citet{multiagent-nlp, jotus} jointly optimize both a user system and a dialog system to improve a model's TOD task performance and/or domain adaptation ability, but could be resource intensive as additional user-side training is needed.\nAlternatively, \\citet{lava, rethink_action} uses RL to optimize system action generation in a latent space, but tends to result in the model generating very short responses (i.e., a low BLEU score of 10.8 in \\dataset{MultiWoZ}). \n\n\\textbf{Offline RL in TOD}\nMany offline RL applications in TOD consider an actor-critic type algorithm \\cite{gptcritic, chai}, which involves using a critic to choose better responses among several generated candidates. These approaches tend to be vulnerable to errors made by the critic model (especially for OOD actions \\cite{offline-rl-overview}), and is resource intensive as multiple auto-regressive generations are needed per episode.\nAlternatively, \\citet{GOLD} proposes the GOLD algorithm, which uses policy-gradient based method in an off-policy setting, by learning solely from the gold demonstrations without any generation/exploration. KRLS additionally performs sequence generations and utilizes gold demonstrations in computing the reward function (also see \\Cref{subsec:KRLS Algorithm Ablation} for an empirical comparison). \n\n\\textbf{Other Notable Related Techniques} \n\\citet{kun-meta-learning} utilizes a student-teacher architecture and MAML \\cite{MAML} to improve domain adaptation ability of the student model. Specifically, the teacher model provides weights to scale the NLL loss of each gold token when training the student model. In this aspect, this is similar to GOLD, performing a ``weighted learning'' on the gold demonstrations. KRLS aims to directly improve TOD performance and achieves this by utilizing RL to perform a ``weighted learning'' on generated tokens.\n\n\\section{Conclusion}\n\\label{sec:Conclusion}\nIn this work, we explore an approach to utilize RL to improve a model's TOD performance, but also to avoid using a user-simulator or the slow auto-regressive generation process. \nWe propose the Keywords Reinforcement with Next-word Sampling (KRLS) training algorithm, which combines offline RL with a fast sequence generation scheme that directly samples from next-word distributions after supervised training, and a fine-grained per-token reward function that measures the importance and semantic closeness of each generated token. We then evaluate KRLS on the MultiWoZ dataset and show that a) it can help improve E2E response generation performance, reaching new state-of-the-art in the inform rate, success rate, and combined score; b) it can be trained 15\\% faster than using a standard RL algorithm that performs auto-regressive generation during training/exploration.\n\\section{Limitations}\n\\label{sec:Limitations}\nAlthough KRLS is faster to train as it avoids auto-regressive generation, it is difficult for the model to learn/generate sequences significantly different from the gold examples in the dataset. Therefore, this could limit the potential to achieve performance better than the training dataset itself.\n\nAdditionally, since during training KRLS creates sequences by conditioning on the gold response, whereas at inference we use auto-regressive generation, the problem of compounding generation error (exposure bias) is re-introduced \\cite{ss-for-prediction, DAD, mixer}. Therefore, in this aspect KRLS trades its faster training speed with certain benefits brought by standard RL training in NLP. In the future, it would be worthwhile to explore if a more fine-grained trade-off can be found between an efficient sequence exploration strategy and those benefits inferred by using auto-regressive generation.\n\nNext, to make KRLS have minimal requirements of extra resources, we avoid using user simulators and perform offline RL training at turn-level. As a result, KRLS does not perform exploration/planning on a dialog-level, which can be very useful for tasks that require long-horizon planning to be successful (e.g., persuading a person to donate to a charity \\cite{p4g}). We believe one way to extend KRLS could be using a GPT-like model to learn from an entire dialog, and combine with safe policy improvement methods to avoid potentially large bias and poor sample efficiency during dialog-level RL learning \\cite{caspi}. We leave this for future work.\n\nFinally, in our runtime experiments (\\Cref{subsec:Main Results}) we found that performing PPO (as well as PG) is a significant bottleneck, taking up more than half of the total training time. Future work may wish to consider ways to improve the speed/memory efficiency\\footnote{\nIn our implementation, we noticed that certain computations could be cached to save time. However, we found it infeasible in our setting due to limited GPU memory. Future work may also investigate ways to improve memory efficiency in our implementation, to allow for potential speedups.\n} of computing those RL objectives to further reduce training time.\n\\section{Ethical Considerations}\nOur work describes an algorithm to improve a model's TOD performance and to expedite the training process. It is aimed at making current TOD systems easier to train, and also better at helping users to achieve their goals.\n\nGenerally, while most algorithms are not designed for unethical usage, there is often potential for abuse in\ntheir applications. In our experiments, we apply KRLS on the MultiWoZ \\cite{multiwoz} dataset, to improve performance on tasks such as restaurant booking and hotel reservation. However, because TOD training algorithms are typically task-agnostic, it is possible to use them for unethical tasks, such as scamming. We do not condone the use of KRLS for any unlawful or morally unjust purposes.\n\nAdditionally, since our experiments use pre-trained language models, another concern is on their (in)ability to generate safe, respectful content \\cite{challenges-detoxifying, realtoxicityprompts}. Our work specifically focuses on improving TOD performance, and hence we caution users against any potential unsafe/toxic/offensive responses generated from the models. \nWithout safety guardrails such as \\citet{director, quark}, we do not advocate using any of our trained models in production settings.\n\n\\clearpage\n\\appendix\n\n\\section{KRLS RL Details}\n\\label{sec:KRLS RL Details}\nTo avoid high variance during policy gradient:\n\\[\n\\nabla \\mathcal{L}(\\theta) = -G_t \\nabla \\log p_\\theta(x_t|c)\n\\]\nwe consider a clipped version of this objective, borrowing from proximal policy gradient (PPO) \\cite{PPO} to provide a more stable training and prevent the policy from moving too far away from the pretrained language model. Similar to \\citet{TextGAIL}, we consider optimizing the following surrogate objective:\n\\begin{equation}\\label{eq:ppo}\n  \\mathcal{L}_{\\mathrm{RL}}=-\\min \\begin{cases}\n  r(\\theta) \\hat{A}_t,\\\\\n  \\mathrm{clip}(r(\\theta), 1-\\epsilon, 1+\\epsilon) \\hat{A}_t,\n  \\end{cases}\n\\end{equation}\nwhere $\\hat{A}_t = -V_\\theta(s_t) + \\sum_{l}\\gamma^l r_{t+l}$ is the advantage function \\cite{gae}, $\\epsilon$ is the clipping parameter, and $r(\\theta)$ is the ratio of the new policy to the old policy $p_\\theta^{\\mathrm{old}}$:\n\\begin{equation}\n  x^{\\mathrm{gen}} \\sim p_\\theta(x|c), \\quad r(\\theta) = \\frac{p_\\theta(x^{\\mathrm{gen}}|c)}{p_\\theta^{\\mathrm{old}}(x^{\\mathrm{gen}}|c)}\n\\end{equation}\nIn practice, we found that adding additional value function heads $V_\\theta$ would 1) increase model size, making it difficult to train under our GPU setting and 2) since KRLS training is performed over a limited number of epochs (\\Cref{sec:KRLS Hyperparameters}), we found fitting a small value function head can result in high variance during training. As such, we fixed the value function to be zero and used the return as an estimate $\\hat{A}_t \\approx \\sum_{l}\\gamma^l r_{t+l} = G_t$, which also signals the model the correct tokens to generate. We note that according to \\citet{gae} page 4, $G_t$ is a $\\gamma$-just advantage estimator for $\\hat{A}_t$.\n\nFor simplicity, we refer ``KRLS'' to use this clipped policy gradient objective unless explicitly mentioned otherwise. \n\\section{KRLS using PPO v.s. PG}\n\\label{sec:KRLS PPO v.s. PG}\nAs shown in \\Cref{tbl:rl_backbone_cmp}, we found that using the clipped objective (\\Cref{eq:ppo}) in KRLS can achieve better performance as compared to simple PG, which can cause high gradient variance \\cite{TRPO,TextGAIL} during training. We believe that this is also due to the clipped objective preventing the new policy $p_\\theta$ to move too far away from the old policy, which is useful in our approach as we approximated sequence generation by ``sampling'' from the gold response. Therefore, we believe that being more pessimistic \\cite{PPO} about each $\\theta$ update can be beneficial in our setting.\n\\begin{table}[!h]\n  \\centering\n  \\scalebox{0.9}{\n  \\begin{tabular}{l c c c c} \n     \\hline\n     \\multicolumn{5}{c}{Finetune+KRLS}\\\\\n     RL Algo & {Inform} & {Success} & {BLEU} & {Total}\\\\\n     \\midrule\n     PG & {88.7} & {78.7} & \\textbf{19.1} & {102.8} \\\\\n     PPO & \\textbf{89.2} & \\textbf{80.3} & {19.0} & \\textbf{103.8}  \\\\\n     \\bottomrule\n  \\end{tabular}\n  }\n  \\caption{Performance comparison when training KRLS with Policy Gradient (PG) and a clipped version (PPO).}\n  \\label{tbl:rl_backbone_cmp}\n\\end{table}\n\\section{Modeling Details}\n\\label{sec:Modeling Details}\nWe use a GODEL-base model as backbone, which is an encoder-decoder architecture like T5-base, with $\\sim$220M parameters. Similar to MTTOD, an additional decoder is initialized for response generation (the other decoder for DST), which results in an additional $\\sim$160M parameters. The encoder is shared for both DST and response generation. This results in a total model size of $\\sim$380M parameters.\n\n\\section{Implementation and Training Details}\n\\label{sec:Implementation and Training Details}\nFor all experiments (including (re)training MTTOD), we use Adam \\cite{adam} for optimization, a linear schedule with an initial learning rate of $5e^{-5}$ and warm-up steps $=0.2\\times$total training steps.\n\nFor \\algo{Baseline}, we re-train MTTOD \\cite{mttod} using publicly released code and the best set of hyperparameters reported by the author.\n\nFor \\algo{KRLS} and \\algo{finetune+KRLS}, we pick the best set of hyperparameters (see \\autoref{sec:KRLS Hyperparameters} for details) using grid search. As task success and inform rate in MultiWoZ is highly correlated with correctly generating the predefined set of informable/requestable slot values such as ``[value\\_address]'' in the response, we use $\\mu=5$ for those key tokens and $\\mu=1$ for others. In addition, we add a terminal reward by measuring the F1-score of generated key tokens compared to the gold key tokens (see \\autoref{fig:KRLS_reward}) to measure overall performance in keywords generation. \nNote that we did not add a BLEU score for terminal reward, as we found the SL training in KRLS is sufficient.\n\n\\section{KRLS Hyperparameters}\n\\label{sec:KRLS Hyperparameters}\nFor the reported results of KRLS in MultiWoZ, we use $k=3$, $\\kappa=0.5\\times \\text{total steps per epoch}$, sampling temperature during generation $\\tau=1.1$, top-p during generation of 0.9, terminal reward scale of 5, learning rate of 5e$^{-5}$, learning rate decay of $0.2\\times \\text{total steps in training}$, and batch size of 4. When trained from a $\\mathcal{L}_{\\mathrm{SL}}$-finetuned checkpoint, we additionally add a regularization term using KL divergence (against the baseline model) with a weighting of 0.01 to reduce over-optimization on the reward function \\cite{instructGPT, rl4lm, offline-with-kl}. During testing, we used auto-regressive generation with greedy decoding (same as \\citet{mttod}).\n\nAll of our experiments are run on a single GPU, NVIDIA RTX A4000. Running KRLS on a $\\sim$380M encoder-decoder model (see \\Cref{sec:Modeling Details}) for 4 epochs takes about one day, as it consists of 306 min/epoch for training and 32 min/epoch for validation.\n\\section{KRLS Sampled Response Examples}\n\\label{sec:KRLS Sampled Response Examples}\nWe provide example comparisons between our generated response using next-word sampling (\\algo{SAMPLED}), and responses produced with auto-regressive generation (\\algo{GENERATED}) in \\Cref{fig:gen_vs_sample_1}, \\Cref{fig:gen_vs_sample_2}, and \\Cref{fig:gen_vs_sample_3}. All examples are generated from a $\\mathcal{L}_{\\mathrm{SL}}$-finetuned checkpoint. For short responses, we observe that \\algo{GENERATED} are similar to \\algo{SAMPLED}. When responses get longer, \\algo{SAMPLED} responses become less similar to the \\algo{GENERATED} ones.\n\nWhen the model is not yet $\\mathcal{L}_{\\mathrm{SL}}$-finetuned on the dataset, \\emph{SAMPLED} responses tend to repeat keywords and can hardly be interpreted as a sequence. For example, given the input context in \\Cref{fig:gen_vs_sample_1}, a sampled response looks like: \"[value\\_stay] [welcome] [value\\_stay] [value\\_arrive] [taxi] [train] [value\\_stay] [value\\_stay] [value\\_stay] [value\\_stay] [value\\_stay]\".\n\\section{BERTScore for KRLS}\n\\label{sec:BERTScore for KRLS}\nTo apply BERTScore in our setting, we first treat our sampled sequence as a standalone generated sequence, and use the cosine similarity between the embedding of each pair of token $x^{\\mathrm{gen}}_t, x^{\\mathrm{gold}}_t$ after passing through a $\\mathcal{L}_{\\mathrm{SL}}$-finetuned GODEL-base as rewards. Note that as we naturally have a one-to-one mapping between the generated and gold sequences, we can skip the maximal similarity matching step.\n\nHowever, as shown in both \\Cref{tbl:token_level_semantic_score_finetuned} and \\Cref{tbl:token_level_semantic_score}, \\algo{BERTS.} does not perform as well as \\algo{Prob.}. This is because BERTScore is designed to measure the semantic similarity between two standalone sentences, while in our setting the generated sequence is conditioned on the gold response. Therefore, in cases when many generated tokens are incorrect, viewing the sampled sequence as a standalone generated sentence will distort each token's contextual meaning, leading to sub-optimal performance.\n\\begin{figure}[!h]\n  \\centering\n  \\includegraphics[width=0.99\\linewidth]{./images/rlonly_vs_rlm.png}\n  \\caption{Validation performance of \\algo{KRLS} and \\algo{RL Only} over time. In \\algo{RL Only}, we remove the SL objective from KRLS, and for each sampled episode we additionally append its corresponding gold response.}\n  \\label{fig:rl_only_vs_krls}\n\\end{figure}\n\\begin{table}[h]\n  \\centering\n  \\scalebox{0.9}{\n  \\begin{tabular}{l c c c c} \n     \\toprule\n     Algo & {Inform} & {Success} & {BLEU} & {Total}\\\\\n     \\midrule\n     SL only& 86.0 & 77.4 & 18.9 & 100.6\\\\\n     RL only& 84.2 & 72.2 & 17.5 & 95.7\\\\\n     KRLS & \\textbf{87.3} & \\textbf{78.3} & \\textbf{19.2} & \\textbf{102.0} \\\\\n     \\bottomrule\n  \\end{tabular}\n  }\n  \\caption{Performance of individual components of the KRLS Algorithm when trained directly from backbone.}\n  \\label{tbl:ablation_study_large}\n\\end{table}\n\\section{KRLS Directly from Backbone}\n\\label{sec:Training KRLS from Scratch}\n\nIn \\Cref{tbl:ablation_study_large}, we present the results when training directly from from the backbone. \\algo{SL only} refers to the baseline of only training with SL objective. \\algo{RL Only} refers to the KRLS algorithm with SL objective removed. \\algo{KRLS} refers to the full KRLS algorithm. When trained directly from backbone, removing the SL objective (\\algo{RL Only}) degrades the performance as the assumption mentioned in \\Cref{sec:RL with Next-word Sampling} becomes harder to satisfy especially during early training (see \\Cref{fig:rl_only_vs_krls}). This is sensible because, without prior SL training, many sequences generated from our sampling method can be highly different from the auto-regressive generated ones. When SL training is included in KRLS, the overall performance improves by 1.4 points, as the additional SL training makes it easier to satisfy our assumption and also made training much smoother (see \\Cref{fig:rl_only_vs_krls}).\n\\section{Additional Keyword Learning Curves}\n\\label{sec:Additional Keyword Learning Curves}\n\nIn addition to the keyword generation accuracy during validation when trained directly from backbone (see \\Cref{subsec:Keyword Learning}), in this section we also show: a) keyword generation accuracy when trained during both training and validation in \\Cref{fig:keyword_learning_both}; b) overall generation accuracy learning curves in \\Cref{fig:overall_learning}; c) keyword and overall generation accuracy curves when trained from a $\\mathcal{L}_{\\mathrm{SL}}$-finetuned checkpoint in \\Cref{fig:finetune_keyword_overall_learning}. \nOverall generation accuracy is measured by how often a generated token $x_t^{\\mathrm{gen}}|x^{\\mathrm{gold}}_{1:t-1},c$ matches the ground truth $x_t^{\\mathrm{gold}}$, whether $x_t^{\\mathrm{gold}}$ is a key token or a non-key token. Keyword generation accuracy only performs the above comparison when the ground truth token is a key token. \n\nAs shown in \\Cref{fig:keyword_learning_both}, KRLS can achieve higher keyword generation accuracy than baseline during both training and validation. We believe this is because the RL component in KRLS, especially during the early stages of training, can help the model also learn the less abundant but more important keywords as it has a higher reward. As a result, in \\Cref{fig:overall_learning}, KRLS training can also achieve a higher overall generation accuracy.\n\nWhen trained from a $\\mathcal{L}_{\\mathrm{SL}}$-finetuned checkpoint as shown in \\Cref{fig:finetune_keyword_overall_learning}, KRLS further increases its keyword generation accuracy. However, in \\Cref{fig:finetune_overall_validation}, the overall generation accuracy is similar to a $\\mathcal{L}_{\\mathrm{SL}}$-finetuned \\algo{baseline}. We believe this is because, after the model has learned to generate most of the tokens correctly, it needs to maintain a balance between over-generating keywords (lower overall accuracy) and correctly generating the keywords (higher keyword generation accuracy).\n\n\\section{RL with Auto-Regressive Gen. Setup}\n\\label{sec:RL with Auto-Regressive Gen. Setup}\nIn \\Cref{subsec:Main Results}, we compared the training time between normal RL with auto-regressive generation, and our KRLS algorithm. As KRLS has an additional SL step during training, we removed this component to provide a fairer comparison against the normal RL procedure, which usually only includes an auto-regressive sequence generation step during experience collection and PPO training. However, after auto-regressive generation, the generated tokens no longer have a one-to-one mapping to the gold response. Therefore, in this setting we used a zero reward for each token, and a terminal reward of keywords $F_1$ (same as KRLS) as well as a BLEU score (as SL training is removed).\n\nIn addition to a faster training speed as shown in \\Cref{subsec:Main Results}, we found that our approach can also reach a better overall performance in \\Cref{tbl:normal_rl_vs_krls} when trained from a $\\mathcal{L}_{\\mathrm{SL}}$-finetuned checkpoint for 4 epochs. We believe that this is because, without a fine-grained per-token reward, \\algo{RL} might need many more epochs to figure out the importance of those keywords.\n\\begin{table}[h]\n  \\centering\n  \\scalebox{0.9}{\n  \\begin{tabular}{l c c c c} \n     \\toprule\n     Algo & {Inform} & {Success} & {BLEU} & {Total}\\\\\n     \\midrule\n     RL   & 88.5 & 79.3 & 18.8 & 103.1\\\\\n     KRLS & \\textbf{89.2} & \\textbf{80.3} & \\textbf{19.0} & \\textbf{103.8} \\\\\n     \\bottomrule\n  \\end{tabular}\n  }\n  \\caption{Test performance when trained from a $\\mathcal{L}_{\\mathrm{SL}}$-finetuned checkpoint for 4 epochs. \\algo{RL} refers to removing the SL step in KRLS, and replacing sequence ``sampling'' step with auto-regressive generation.}\n  \\label{tbl:normal_rl_vs_krls}\n\\end{table}\n\\section{Ablation Study Setup: GOLD}\n\\label{sec:Ablation Study Setup: GOLD}\nGOLD \\cite{GOLD} is an offline, off-policy RL algorithm that directly learns from the gold examples in the dataset without any generation step. As the RL component in KRLS is also an offline RL algorithm, we compared KRLS to {GOLD} in \\Cref{subsec:KRLS Algorithm Ablation}.\n\nTo implement {GOLD} in our experiments, we followed the descriptions in \\citet{GOLD}, and replaced the RL component in KRLS with {GOLD}. We denoted this as \\algo{SL+GOLD} in \\Cref{tbl:rl_cmp}. \nAdditionally, as {GOLD} uses the simple policy gradient (PG), for a fair comparison we also replaced our PPO objective with PG in KRLS in this experiment. Finally, we kept our per-token reward function $\\mathcal{R}$ in \\algo{SL+GOLD}, as the reward function proposed by \\citet{GOLD} is aimed at optimizing other metrics such as perplexity.\n\n\\section{Proof of SL Equivalence}\n\\label{sec:Proof of SL Equivalence}\n\nApplying our definition of $\\mathcal{R}$ (see \\Cref{sec:Per-Token Reward Function}) in \\autoref{eq:real_policy_gradient} we get, \\emph{if $x^{\\mathrm{gen}} = x^{\\mathrm{gold}}$ is generated correctly and corresponds to $\\mathcal{R}=1$}, and with the discount factor $\\gamma=0$:\n\\[\n\\nabla \\mathcal{L}(\\theta) \\propto -\\nabla \\log p_\\theta(x^{\\mathrm{gen}}|c)\n\\] \nthis gives the same gradient as the traditional supervised learning for SL in \\autoref{eq:lm_loss}.\n\\section{Effect of $\\kappa,\\mu$ and $k$ in KRLS}\n\\label{sec:Effect of kappa and mu in KRLS}\nWe empirically tested a range of hyperparameters for KRLS, including $\\kappa \\in \\{0.1, 0.5, 1.0\\} \\times$ steps per epoch, $\\mu \\in \\{2, 5, 10\\}$, and $k \\in \\{1,3,5\\}$. We present the results in \\Cref{tbl:effect_of_kappa_and_mu} and \\Cref{tbl:effect_of_k}.\n\\begin{table}[th]\n  \\centering\n  \\begin{tabular}{l c c c} \n     \\toprule\n     \\multicolumn{4}{c}{Finetune+KRLS}\\\\\n      & $\\mu=2.0$ & $\\mu=5.0$ & $\\mu=10.0$\\\\\n     \\midrule\n     $\\kappa=0.1 n$   & 102.2 & 102.4 & 102.3 \\\\\n     $\\kappa=0.5 n$   & 103.3 & 103.8 & 103.8 \\\\\n     $\\kappa=1.0 n$   & 102.3 & 102.1 & 102.5 \\\\\n     \\bottomrule\n  \\end{tabular}\n  \\caption{Effect of different $\\kappa$ and $\\mu$ on the combined score in MultiWOZ. $n$ represents the number of training steps in an epoch.}\n  \\label{tbl:effect_of_kappa_and_mu}\n\\end{table}\n\\begin{table}[th]\n  \\centering\n  \\begin{tabular}{l c c c} \n      \\toprule\n     \\multicolumn{4}{c}{Finetune+KRLS}\\\\\n      & $k=1$ & $k=3$ & $k=5$\\\\\n     \\midrule\n     $\\kappa=0.1n,$ &\\multirow{2}{*}{102.9} & \\multirow{2}{*}{103.8} & \\multirow{2}{*}{102.8} \\\\\n     $\\mu=5.0$ &  &  &  \\\\\n     \\bottomrule\n  \\end{tabular}\n  \\caption{Effect of different $k$ on the combined score in MultiWOZ. $n$ represents the number of training steps in an epoch.}\n  \\label{tbl:effect_of_k}\n\\end{table}\n\n\\section{Additional Reward Function Ablation}\n\\label{sec:Additional Reward Function Ablation}\nWe additionally show the effect of several per-token reward functions in our KRLS algorithm when trained directly from backbone (hence the assumption mentioned in \\Cref{sec:RL with Next-word Sampling} is harder to satisfy). As shown in \\Cref{tbl:token_level_semantic_score}, all variants using KRLS still achieved improvement from baseline (also see \\Cref{fig:keyword_learning_both} and \\Cref{fig:overall_learning}). Specifically, \\algo{Zero} reward and \\algo{Prob.} reward achieved the highest and second highest, with 102.2 and 102.0 as Combined Score, respectively.\n\\begin{table}[!th]\n  \\centering\n  \\begin{tabular}{l c c c c} \n     \\toprule\n     \\multicolumn{5}{c}{KRLS}\\\\\n     Reward & {Inform} & {Success} & {BLEU} & {Total}\\\\\n     \\midrule\n     \\emph{None} & 86.0 & 77.4 & 18.9 & 100.6  \\\\\n     Zero & 87.7 & 78.6 & 19.0 & 102.2\\\\\n     Error & 86.2 & 78.6 & 19.2 & 101.6\\\\\n     BERTS. & 87.2& 78.1 & 19.0 & 101.7\\\\\n     Static. & 87.2 & 77.6 & 19.3 & 101.7\\\\\n     Prob.   & {87.3} & {78.3} & {19.2} & {102.0} \\\\\n     \\bottomrule\n  \\end{tabular}\n  \\caption{Performance of Training Directly from Backbone with KRLS using Different per-token Reward}\n  \\label{tbl:token_level_semantic_score}\n\\end{table}\n\n\\section{KRLS Error Examples}\n\\label{sec:KRLS Error Examples}\nWe present three examples in \\Cref{fig:error_1}, \\Cref{fig:error_2}, and \\Cref{fig:error_3} when KRLS trained model does not generate the required key tokens. We observe that in most cases, error originates from incorrectly generated system action and dialog state. This hints at a direction for further improvement in lines of making dialog state and system action generation more robust \\cite{mars}.\n\\begin{figure*}[!t]\n  \\centering\n  \\subfigure[Keyword Learning during Training]{%\n      \\label{fig:keyword_learning_training}%\n  \\includegraphics[scale=0.54]{./images/keyword_training.png}}%\n  \\qquad\n  \\subfigure[Keyword Learning Validation]{%\n      \\label{fig:keyword_learning_validation}%\n  \\includegraphics[scale=0.4]{./images/keyword_validation.png}}%\n  \\caption{Keyword Generation Accuracy during Training and Validation. \\emph{Baseline} is the standard SL training using $\\mathcal{L}_{\\mathrm{SL}}$. Both baseline and KRLS are directly trained from backbone.}\n  \\label{fig:keyword_learning_both}\n\\end{figure*}\n\\begin{figure*}[!h]\n  \\centering\n  \\subfigure[All Tokens Learning during Training]{%\n      \\label{fig:overall_training}%\n  \\includegraphics[scale=0.54]{./images/overall_training.png}}%\n  \\qquad\n  \\subfigure[All Tokens Learning Validation]{%\n      \\label{fig:overall_validation}%\n  \\includegraphics[scale=0.4]{./images/overall_validation.png}}%\n  \\caption{All Token Generation Accuracy during Training and Validation. \\emph{Baseline} is the standard SL training using $\\mathcal{L}_{\\mathrm{SL}}$. Both baseline and KRLS are directly trained from backbone.}\n  \\label{fig:overall_learning}\n\\end{figure*}\n\\begin{figure*}[!h]\n  \\centering\n  \\subfigure[Key Tokens Learning Validation]{%\n      \\label{fig:finetune_keyword_validation}%\n  \\includegraphics[scale=0.4]{./images/finetune_keyword_validation.png}}%\n  \\qquad\n  \\subfigure[All Tokens Learning Validation]{%\n      \\label{fig:finetune_overall_validation}%\n  \\includegraphics[scale=0.4]{./images/finetune_overall_validation.png}}%\n  \\caption{Key and All Token Generation Accuracy during Training and Validation. \\emph{Baseline} is the standard SL training using $\\mathcal{L}_{\\mathrm{SL}}$. \\algo{finetunt+KRLS} is trained from a $\\mathcal{L}_{\\mathrm{SL}}$-finetuned checkpoint, i.e. \\algo{Baseline}.}\n  \\label{fig:finetune_keyword_overall_learning}\n\\end{figure*}\n\\begin{figure*}[]\n  \\centering\n  \\includegraphics[scale=0.7]{./images/gen_vs_sample_1.pdf}\n  \\caption{Example sequence generated by KRLS. Texts in black are the user's utterances. \\algo{GOLD} represents the gold response. \\algo{GENERATED} represents response produced using auto-regressive generation. \\algo{SAMPLED} represents response produced using the next-word sampling method in KRLS.}\n  \\label{fig:gen_vs_sample_1}\n\\end{figure*}\n\\begin{figure*}[]\n  \\centering\n  \\includegraphics[scale=0.7]{./images/gen_vs_sample_2.pdf}\n  \\caption{Example sequence generated by KRLS. Texts in black are the user's utterances. \\algo{GOLD} represents the gold response. \\algo{GENERATED} represents response produced using auto-regressive generation. \\algo{SAMPLED} represents response produced using the next-word sampling method in KRLS.}\n  \\label{fig:gen_vs_sample_2}\n\\end{figure*}\n\\begin{figure*}[]\n  \\centering\n  \\includegraphics[scale=0.7]{./images/gen_vs_sample_3.pdf}\n  \\caption{Example sequence generated by KRLS. Texts in black are the user's utterances. \\algo{GOLD} represents the gold response. \\algo{GENERATED} represents response produced using auto-regressive generation. \\algo{SAMPLED} represents response produced using the next-word sampling method in KRLS.}\n  \\label{fig:gen_vs_sample_3}\n\\end{figure*}\n\\clearpage\n\\begin{figure*}[!t]\n    \\centering\n    \\includegraphics[scale=0.7]{./images/error_1.pdf}\n    \\caption{KRLS Generation Error Example 1. Texts in black are the input context, in blue are the generated tokens, and in yellow/gold are the ground truth. Texts highlighted in red are incorrect/missing key tokens compared to the ground truth.}\n    \\label{fig:error_1}\n\\end{figure*}\n\\begin{figure*}[]\n  \\centering\n  \\includegraphics[scale=0.7]{./images/error_2.pdf}\n  \\caption{KRLS Generation Error Example 2. Texts in black are the input context, in blue are the generated tokens, and in yellow/gold are the ground truth. Texts highlighted in red are incorrect/missing key tokens compared to the ground truth.}\n  \\label{fig:error_2}\n\\end{figure*}\n\\begin{figure*}[]\n  \\centering\n  \\includegraphics[scale=0.7]{./images/error_3.pdf}\n  \\caption{KRLS Generation Error Example 3. Texts in black are the input context, in blue are the generated tokens, and in yellow/gold are the ground truth. Texts highlighted in red are incorrect/missing key tokens compared to the ground truth.}\n  \\label{fig:error_3}\n\\end{figure*}\n\n\\end{document}\n</paper 2>\n\n<paper 3>\n\\title{DiactTOD: Learning Generalizable Latent Dialogue Acts for Controllable Task-Oriented Dialogue Systems}\n\n\\begin{document}\n\n\\maketitle\n\n\\begin{abstract}\n\nDialogue act annotations are important to improve response generation quality in task-oriented dialogue systems.\nHowever, it can be challenging to use dialogue acts to control response generation in a generalizable way because different datasets and tasks may have incompatible annotations.\nWhile alternative methods that utilize latent action spaces or reinforcement learning do not require explicit annotations, they may lack interpretability or face difficulties defining task-specific rewards.\nIn this work, we present a novel end-to-end latent dialogue act model (DiactTOD) that represents dialogue acts in a latent space.\nDiactTOD, when pre-trained on a large corpus, is able to predict and control dialogue acts to generate controllable responses using these latent representations in a zero-shot fashion.\nOur approach demonstrates state-of-the-art performance across a wide range of experimental settings on the MultiWOZ dataset, including zero-shot, few-shot, and full data fine-tuning with both end-to-end and policy optimization configurations.\n\n\\end{abstract}\n\n\\section{Introduction}\n\nTask-oriented dialogue systems have become increasingly prevalent in recent years, leading to a growth in research on related topics such as dialogue response generation. \nPrevious work \\cite{DBLP:conf/aaai/YangLQ21,he2022galaxy} found that incorporating dialogue act annotations, representing the illocutionary level of utterances, can enhance the quality of generated responses.\nDespite the importance of dialogue act annotations, collecting them can be a time-consuming process that requires human effort. \nFurthermore, existing annotations for dialogue acts are scattered across different datasets and may use different labeling schemes, making it difficult to generalize across tasks. \nAs a result, learning to identify and classify general dialogue acts becomes a crucial challenge in the field of task-oriented dialogue systems.\n\n\\begin{figure}[t]\n    \\centering\n    \\includegraphics[scale=0.6]{images/act_example.pdf}\n    \\caption{Given different human-readable dialogue acts, the proposed system can produce different responses based on the context.}\n    \\label{fig:act_example}\n\\end{figure}\n\nDialogue acts refer to the underlying intention or purpose of a response in a conversation. \nFor example, in Figure~\\ref{fig:act_example}, a response might be intended to ask about price or area preference or provide information given the same context.\nIn task-oriented dialogue systems, it can be useful to classify the dialogue acts of responses in order to generate more appropriate and relevant responses.\nOne way \\cite{chen2013dialogue} to improve the quality of generated responses is to use a dialogue policy model to select the most appropriate dialogue act for a given context. \nHowever, this approach can be limited in complex or varied situations and may not work well across different datasets. Instead, more advanced techniques may be needed to generate high-quality responses in a wide range of contexts.\n\nAn alternative way is to discard predefined semantic dialogue acts and instead use latent action spaces to optimize response generation.\nBy using latent action spaces, it is possible to generate responses that are more flexible and adaptable to a wider range of situations, without requiring human experts to define the action spaces in advance.\nLaRL \\cite{zhao2019rethinking} first explores the idea of training an agent to discover underlying patterns and structures in a conversation dataset and to generate responses based on these patterns.\nLater work, such as LAVA \\cite{lubis2020lava} and DialogVED \\cite{chen-etal-2022-dialogved}, extended this idea by using a variational autoencoder (VAE) to improve the performance of the latent action model.\nOther approaches, such as PLATO \\cite{bao-etal-2020-plato}, have explored using latent action spaces to optimize dialogue agents with large-scale pre-training.\n\n\\begin{figure}[t]\n    \\centering\n    \\includegraphics[width=0.48\\textwidth]{images/unseen_act.pdf}\n    \\caption{Different datasets have different dialogue act annotation labelsets. How to generalize to unseen dialogue acts becomes a challenge.}\n    \\label{fig:unseen_act}\n\\end{figure}\n\nWhile previous work \\cite{zhao2019rethinking,lubis2020lava,chen-etal-2022-dialogved,bao-etal-2020-plato} explored the use of latent action spaces and reinforcement learning for dialogue systems, it has not addressed the possibility of learning general dialogue acts that can be applied across multiple datasets. \nThis is an important consideration for task-oriented dialogue systems, which often need to handle a wide range of different tasks and contexts.\nIn Figure~\\ref{fig:unseen_act}, we show examples of the fact that different datasets often have incompatible or inconsistent definitions for dialogue act annotations.\nAnother limitation of previous approaches is that they fully avoid semantic dialogue act annotations, which can lack controllability and interpretability for the learned actions. This can make it difficult to understand why the system is generating certain responses or to modify its behavior in specific situations. \nAs a result, there is a need for new approaches that can learn general dialogue acts across datasets and that provide more control and interpretability for the learned actions.\n\nIn this work, we propose a novel method for learning generalized latent dialogue acts that can be applied to new domains for task-oriented dialogues. \nOur method uses sentence-BERT \\cite{reimers-2019-sentence-bert} to encode seen dialogue acts into latent representations and a separate policy model to handle context and database information.\nTo integrate these two components into a single end-to-end model, we modify a pre-trained encoder-decoder model \\cite{DBLP:journals/corr/abs-1910-10683,DBLP:conf/acl/LewisLGGMLSZ20} to include the policy model, and further train it to select the best latent dialogue act for a given context.\n\nOur model is designed to perform zero-shot and controllable dialogue response generation, meaning that it can generate appropriate responses without requiring any additional training data. \nTo achieve this, we pre-train our model on a large corpus of dialogues and act annotations.\nBefore pre-training, we fine-tune another model, TANL \\cite{DBLP:conf/iclr/PaoliniAKMAASXS21}, with SGD's slot definitions \\cite{rastogi2020towards} from a separate dataset to delexicalize the pre-training data to improve its zero-shot capability. \nThese steps allow our model to learn generalizable latent dialogue act representations and generate appropriate responses that can be applied to new tasks and datasets without additional fine-tuning. \n\nWe evaluate the effectiveness of our model on the MultiWOZ  \\cite{DBLP:conf/emnlp/BudzianowskiWTC18} dataset, a widely-used benchmark for task-oriented dialogue generation.\nDuring inference, we control the dialogue acts using the provided schema and targeted objective to generate better system responses.\nWe test our model in a range of experimental settings, including zero-shot, few-shot, and full fine-tuning response generation for both end-to-end and policy optimization configurations.\nIn all of these settings, our model outperforms previous baselines and achieves state-of-the-art performance.\n\nOur main contributions in this work can be summarized as follows: \n\\begin{itemize}\n\\item We present a novel end-to-end latent dialogue act model that represents arbitrary dialogue acts in latent space and can predict and control these acts to generate better responses.\n\n\\item We pre-train our model with a semi-supervised method for learning latent dialogue acts that can generalize across different datasets with different act labels. \n\n\\item Our model DiactTOD achieves state-of-the-art performance on the MultiWOZ dataset in a range of experimental settings, including zero-shot, few-shot, and full fine-tuning in both end-to-end and policy optimization configurations.\n\n\\end{itemize}\n\n\\section{Related Work}\n\nResponse generation is an important task in task-oriented dialogue systems. There have been many previous approaches \\cite{HosseiniAsl2020ASL,DBLP:conf/eacl/WuZLY21,DBLP:conf/acl/GuWWSY20,DBLP:conf/acl/SuSMG0LZ22,he2022galaxy,https://doi.org/10.48550/arxiv.2211.16773,DBLP:journals/corr/abs-2210-08917,DBLP:journals/corr/abs-2305-13710} proposed to improve the task-oriented dialogue systems.\nOne direction is the use of dialogue act annotations to improve the quality of responses in task-oriented dialogue systems. \nFor example, SimpleTOD \\cite{HosseiniAsl2020ASL} and UBAR \\cite{DBLP:conf/aaai/YangLQ21} generate dialogue acts as part of the response generation process. \nPPTOD \\cite{DBLP:conf/acl/SuSMG0LZ22} uses the context as a prompt and dialogue act generation for multi-task learning. \nRecently, GALAXY \\cite{he2022galaxy} proposed a method that uses pre-training on a large corpus of dialogues with dialogue act annotations as an auxiliary objective to improve the quality of the generated responses.\nHowever, these methods are limited by the fact that different datasets may have incompatible or inconsistent dialogue act annotations for learning generalizable representations.\nTo address this problem, previous work \\cite{he2022galaxy,DBLP:conf/interspeech/PaulGH19} has attempted to define a new universal schema for dialogue acts. \nHowever, these approaches are either overly simplified or require additional human annotations, limiting their effectiveness and practicality.\n\nIn addition to using explicit annotations of dialogue acts, researchers have also explored alternative methods to improve response generation, such as using latent action spaces and implementing reinforcement learning techniques.\nThese approaches aim to improve the overall task success rate of generated responses.\nLaRL \\cite{zhao2019rethinking} uses latent dialogue acts trained with reinforcement learning instead of surface-form dialogue acts to control response generation which results in the best task score. \nLAVA \\cite{lubis2020lava} further improves over LaRL by utilizing a variational autoencoder (VAE) to learn an informed and semantic prior when optimizing the latent action spaces, achieving state-of-the-art Success and Inform scores on MultiWOZ.\nKRLS \\cite{https://doi.org/10.48550/arxiv.2211.16773} is another recent approach that applies reinforcement learning to pre-trained language models.\nThis approach utilizes a specifically designed objective function that focuses on learning the keywords in the input, with the goal of improving the overall performance of the language model.\nIn our work, we adopt a similar approach but use dialogue act annotations to assign semantic meanings to the latent representations, allowing the model to learn generalizable and controllable latent dialogue acts, which improves the quality of generated response.\n\nPre-training with a large corpus of dialogues has been a widely adopted technique to enhance the response generation quality in dialogue systems  \\cite{DBLP:conf/acl/ZhangSGCBGGLD20,DBLP:conf/eacl/RollerDGJWLXOSB21}. \nIn the context of task-oriented dialogue systems, several recently proposed approaches have demonstrated the effectiveness of pre-training.\nGALAXY \\cite{he2022galaxy} pre-trains the model with a collection of dialogue datasets with dialogue act annotations.\nGODEL \\cite{Peng2022GODELLP} uses a larger dataset and model size, and it also incorporates the grounding of database results in the context.\nThis allows it to achieve good performance under few-shot settings on the MultiWOZ dataset.\nIn contrast, our work uses a smaller set of pre-training datasets but with more robust data processing techniques.\nWe use the complete dialogue acts in each dataset without any simplification. \nWe also train another model TANL \\cite{DBLP:conf/iclr/PaoliniAKMAASXS21} to delexicalize the pre-training data to improve the model's zero-shot and few-shot capabilities. \n\n\\begin{figure*}[t]\n    \\centering\n    \\includegraphics[width=0.95\\textwidth]{images/overview.pdf}\n    \\caption{Overview of the training pipeline, which includes three stages: latent dialogue act encoding, policy training, and response generation.\n    During training, dialogue acts are first encoded into latent vectors and then passed to a policy model to control the final response generation.}\n    \\label{fig:overview}\n\\end{figure*}\n\n\\section{DiactTOD Approach}\n\nIn this section, we first provide a brief overview of the traditional end-to-end task-oriented dialogue systems. \nThen, we delve into the specifics of how our proposed latent dialogue act model operates, by providing details on both its training and inference processes, which offers a new approach to modeling dialogue acts.\nFinally, we discuss how this model can be used to control response generation for a more efficient and accurate dialogue system.\n\n\\subsection{End-to-End Task-Oriented Dialogue}\n\nAn end-to-end task-oriented dialogue system generates a system response $R_t$ at turn $t$ based on the dialogue history context $C_t$ and the database result $DB_t$.\nThe history context $C_t$ contains the previous user utterances $U_{1:t}$ and the system responses $R_{1:t}$. \nTo get the database search result $\\text{DB}_t$, a dialogue state tracking (DST) model would need to output the belief state $B_t$.\nTo leverage the dialogue act annotations, the model also generates act $A_t$ for dialogue policy learning.\nThis allows the model to effectively guide the conversation and produce accurate and appropriate responses.\n\\begin{align}\n    \\mathcal{L}_{\\text{act}} &= - \\log p(A_t | C_t, \\text{DB}_t)\n\\end{align}\n\nThe final system response is generated conditional to the history context $C_t$, the database result $\\text{DB}_t$, and the dialogue act $A_t$.\n\\begin{align}\n    \\mathcal{L}_{\\text{response}} &= - \\log p(R_t | C_t, \\text{DB}_t, A_t)\n\\end{align}\n\nIn practice, the dialogue acts $A_t$ and the system response $R_t$ are concatenated during the training and generation process to improve the decoder's performance. \nHowever, the surface form of dialogue acts has limitations in terms of generalization, as different datasets and tasks may have different formats for representing dialogue acts. This can make it difficult to apply the model to different settings.\n\n\\subsection{Generalizable Latent Dialogue Act}\n\nFigure~\\ref{fig:overview} shows the overview of our approach. \nWe divide the pipeline into three parts: latent dialogue act encoding, policy training, and response generation.\n\n\\textbf{Latent dialogue act encoding:} To overcome the generalization issues associated with the surface form of dialogue acts, we use sentence-BERT (S-BERT) to encode the dialogue acts into embeddings and we have:\n\\begin{align}\n     z &= \\text{S-BERT} (A_t)\n\\end{align}\n\nThis allows different annotations with the same meaning to have similar representations while leveraging the semantic knowledge contained in the encoder to improve generalization.\n\n\\hfill\n\n\\textbf{Policy Training:} On top of the encoder-decoder architecture, we have introduced a policy model that serves as a way to learn the dialogue policy. \nThis model operates similarly to the decoder in an autoregressive manner.\nIt takes in the database search result $\\text{DB}_t$ and the encoder's hidden states $h_\\text{encoder}$ as input, and produces a predicted latent dialogue act vector $\\hat{z}$ that is optimized to closely match the true latent dialogue act vector $z$.\nWe use the mean squared error (MSE) loss function to minimize their distance:\n\\begin{align}\n     \\hat{z} &= \\text{Policy} ( \\text{DB}_t, h_\\text{encoder}) \\\\\n  \\mathcal{L}_{\\text{policy}} &= || \\hat{z}  - \\text{sg}(z) ||_2^2\n\\end{align}\nwhere $sg$ means stop gradient. This increases the stability of the training. \nDuring training, the policy model is trained using a technique called teacher forcing, where the true latent dialogue act vector $z$ is provided as input to the model. \nTo ensure that the model does not leak any ground truth dialogue act information, a unidirectional attention mask is used.\n\nThen, the true latent dialogue act vector $z$ is fed into the policy model with teacher forcing to produce the policy model's hidden state:\n\\begin{align}\n     h_\\text{policy} &= \\text{Policy} ( \\text{DB}_t, h_\\text{encoder}, z)\n\\end{align}\n\n\\textbf{Response generation:} The final system response is generated by the decoder, which takes both the hidden states of the encoder $h_\\text{encoder}$ and the hidden states of the policy model $h_\\text{policy}$ as the input.\n\\begin{align}\n    h_\\text{encoder} &= \\text{Encoder} ( C_t) \\\\\n    \\mathcal{L}_{\\text{response}} &= - \\log p(R_t | h_\\text{encoder}, h_\\text{policy})\n\\end{align}\n\nThis allows the decoder to generate appropriate responses while enabling controllability with the policy model, as the decoder can take into account the dialogue context and the predicted latent dialogue act. \n\nThe final training loss is defined as the sum of the policy loss and the response loss: \n\\begin{align}\n    \\mathcal{L}_\\text{training} &= \\alpha \\mathcal{L}_{\\text{policy}} + (1- \\alpha)\\mathcal{L}_{\\text{response}} \n\\end{align}\nwhere $\\alpha$ is a hyperparameter to balance the magnitude of losses.\n\n\\begin{figure}[t]\n    \\centering\n    \\includegraphics[width=0.45\\textwidth]{images/inference.pdf}\n    \\caption{During inference, we select the closest dialogue act based the predicted dialogue act. Note that the set of valid dialogue acts can be filtered based on the task or context.}\n    \\label{fig:inference}\n\\end{figure}\n\\hfill\n\n\\textbf{Inference:} During the inference phase (depicted in Figure~\\ref{fig:inference}), we pre-define a table $S_z$ that includes all possible combinations of dialogue acts. \nThis allows us to create a set of embeddings for the dialogue acts, where each act can be treated as a unique \"word\" in a specialized vocabulary. \nThis table contains all possible combinations of dialogue acts that can be derived from the training dataset. \nAlternatively, if the schema of dialogue acts is known, we can manually construct such a table consisting of valid combinations. \nThis can be particularly useful in a zero-shot setting. \nIn this scenario, where we do not have a training set for a specific domain, having a set of predefined dialogue acts can allow the model to still generate semantically valid responses without any training.\n\nOnce the predicted latent dialogue act vector $\\hat{z}$ is generated, it is used to retrieve the most appropriate latent dialogue act from the embedding table $S_z$. \nThis is done by using a technique called vector quantization, which allows us to select the latent dialogue act that is closest to the predicted vector. \nThis helps reduce the representation mismatch of the predicted latent dialogue between training and inference.\n\\begin{equation}\n    z' = \\argmin_{z \\in S_z} ||z - \\hat{z}||\n\\end{equation}\n\nAfter the closest latent dialogue act is retrieved from the embedding table using vector quantization, it is fed back into the policy model. \nThe decoder then generates the final system response by conditioning on both the encoder's hidden states and the policy model's hidden states.\n\n\\subsection{Controllable Response Generation}\n\nThe policy model uses a pre-processed embedding table to predict dialogue acts.\nBy filtering the embedding table to include only relevant dialogue acts, we can control the predicted dialogue acts during inference. \nThis allows the model to focus on generating more appropriate and relevant responses that are tailored to the specific context or task, which improves the overall efficiency and accuracy of the dialogue system. \n\nFor example, if the dialogue act table contains some combinations that lack requesting or informing for certain slots, we can filter these dialogue acts out of the embedding table during inference. \nThis helps guide the generation of responses to make more requests or provide more information for those specific slots. This can be particularly useful in scenarios where the user's goal is to obtain specific information or complete a certain task and the model can make more requests or provide more information for the relevant slots. \nIn this way, the model can quickly adapt to specific scenarios or domains and respond in a more appropriate and relevant way to the user's needs and goals.\n\n\\section{Pre-training Latent Acts}\n\n\\begin{table}[h]\n    \\centering\n    \\resizebox{0.4\\textwidth}{!}{\n    \\begin{tabular}{c| c c}\n    \\toprule\n    \\textbf{Dataset Name} & \\textbf{Act Label?} & \\textbf{\\# Utterances}  \\\\\n    \\midrule\n    SGD & \\cmark & 463,284 \\\\\n    STAR & \\cmark & 107,846  \\\\\n    MSRe2e & \\cmark & 74,686  \\\\\n    Frames & \\cmark & 19,986 \\\\\n    MetaLWOZ & \\xmark & 356,268 \\\\\n    \\bottomrule\n    \\end{tabular}\n    }\n    \\caption{Pre-training datasets statistics. For datasets without dialogue act labels, we use system responses as a proxy for the dialogue act.}\n    \\label{tab:dataset}\n\\end{table}\n\nTo learn generalizable latent dialogue acts and achieve competitive performance on downstream tasks without any additional fine-tuning, our model undergoes pre-training on a selection of task-oriented dialogue datasets shown in Table~\\ref{tab:dataset}.\nSpecifically, we have chosen four datasets that are annotated with dialogue acts and one dataset that does not contain any dialogue act annotations. \nDetailed descriptions of these datasets can be found in the appendix.\n\nTo ensure consistency across all datasets for pre-training, we pre-process the datasets with the same tokenization and truncation of dialogues when they exceed a certain length. \nAdditionally, we incorporate database search results as an input token to indicate the number of matches.\nA large portion of utterances in these datasets do not have dialogue act annotations.\nTo effectively pre-train on those datasets, we utilize the system response as a proxy for the dialogue act. \nThis allows the policy model to generalize to new and unseen dialogue acts. \nOur experiments have shown this approach to be effective.\n\nIn task-oriented response generation, system responses are typically in a delexicalized form, which means that specific values of certain variables are replaced by placeholders. \nTo enable this automatic delexicalization during response generation, we use the model TANL (Translation between Augmented Natural Languages) \\cite{tanl}. \nThis model can extract slot spans from the input sentence.\nWe fine-tune the TANL model with the SGD's predefined slot definitions.\nFor downstream tasks and evaluation, we ensure compatibility by defining a one-to-one mapping of the SGD's slot definitions with the slots in the MultiWOZ dataset.\n\n\\begin{table*}[t]\n    \\centering\n    \\resizebox{0.7\\textwidth}{!}{\n    \\begin{tabular}{l |c |c c c c }\n    \\toprule\n    \\multirow{2}{*}{\\textbf{Model}} & \\multirow{2}{*}{\\textbf{\\# Examples}} & \\multicolumn{4}{c}{\\textbf{Policy optimization}} \\\\\n    & & \\textbf{Inform} & \\textbf{Success} & \\textbf{BLEU}  & \\textbf{Combined} \\\\\n    \\midrule\n    $\\text{DialoGPT}_\\text{base \\quad}$ & 50 & 38.70 & 3.00 & 0.20  & 21.05 \\\\\n    $\\text{DialoGPT}_\\text{large}$ & 50  & 62.40 & 34.70 & 10.52 & 59.06 \\\\\n    \\midrule\n    $\\text{T5}_\\text{base}$ & 50 & 60.60 & 22.50 & 4.31 & 45.86 \\\\\n    $\\text{T5}_\\text{large}$ & 50  & 71.50 & 56.20 & 12.69 & 76.54 \\\\\n    \\midrule\n    $\\text{GODEL}_\\text{base}$ & 50 & 67.60 & 46.10 & 12.81 & 69.72 \\\\\n    $\\text{GODEL}_\\text{large}$ & 50 & 81.60 & 62.10 & \\textbf{14.07} & 85.90 \\\\\n    $\\text{GODEL}_\\text{GPT-J}$ & 50  & 60.50 & 21.00 & 6.27 & 47.01 \\\\\n    $\\text{GODEL}_\\text{GPT-3}$ & 50 & 68.80 & 19.90 & 6.72 & 51.06 \\\\\n    \\midrule\n    $\\text{DiactTOD}$ & 0  & \\textbf{93.60} & \\textbf{71.40} & 4.20 & \\textbf{86.70} \\\\\n    $\\text{DiactTOD}$ & 50 & \\textbf{94.60} & \\textbf{78.90} & 10.75 & \\textbf{97.05} \\\\\n    \\bottomrule\n    \\end{tabular}\n    }\n    \\caption{Low-resource experimental results. All experiments are done in the policy optimization setting. For few-shot, we fine-tuned the model with 50 examples.}\n    \\label{tab:low-resource}\n\\end{table*}\n\n\\begin{table*}[t]\n    \\centering\n    \\resizebox{0.9\\textwidth}{!}{\n    \\begin{tabular}{l|c c c c | c c c c}\n    \\toprule\n    \\multirow{2}{*}{\\textbf{Model}} & \\multicolumn{4}{c|}{\\textbf{End-to-end}} & \\multicolumn{4}{c}{\\textbf{Policy optimization}} \\\\\n    & \\textbf{Inform} & \\textbf{Success}  & \\textbf{BLEU}   & \\textbf{Combined} & \\textbf{Inform} & \\textbf{Success}  & \\textbf{BLEU}   & \\textbf{Combined} \\\\\n    \\midrule\n    UBAR & 83.4 & 70.3 & 17.6 & 94.4 & - & - & - & - \\\\\n    PPTOD & 83.1 & 72.7 & 18.2 & 96.1 & - & - & - & - \\\\\n    RSTOD & 83.5 & 75.0 & 18.0 & 97.3 & - & - & - & - \\\\\n    BORT & 85.5 & 77.4 & 17.9 & 99.4 & - & - & - & - \\\\\n    MTTOD & 85.9 & 76.5 & 19.0 & 100.2 & - & - & - & - \\\\\n    HDNO & - & - & - & - & 93.3 & 83.4 & 17.8 & 106.1 \\\\\n    GALAXY & 85.4 & 75.7 & 19.6 & 100.2 & 92.7 & 83.5 & \\textbf{19.9} & 108.1 \\\\\n    MarCo & - & - & - & - & 94.5 & 87.2 & 17.3 & 108.1 \\\\\n    Mars & 88.9 & 78.0 & \\textbf{19.9} & 103.4 & - & - & - & - \\\\\n    KRLS & 89.2 & 80.3 & 19.0 & 103.8 & 93.1 & 83.7 & 19.1 & 107.5 \\\\\n    \\midrule\n    DiactTOD & \\textbf{89.5} & \\textbf{84.2} & 17.5 & \\textbf{104.4} & \\textbf{94.8} & \\textbf{90.2} & 17.8 & \\textbf{110.3} \\\\\n    \\bottomrule\n    \\end{tabular}\n    }\n    \\caption{MultiWOZ Response generation evaluation. ``-'' means that this setting's performance is not reported. (Combined Score=(Inform + Success)*0.5 + BLEU)}\n    \\label{tab:full-fine-tune}\n\\end{table*}\n\n\\section{Experiment Setup}\n\nWe initialize our model with T5-base and pre-train our model on the previously mentioned datasets.\nWe evaluate our model on the multi-domain task-oriented dialogue dataset MultiWOZ \\cite{DBLP:conf/emnlp/BudzianowskiWTC18}.\nIt contains 8,438/1,000/1,000 dialogues for training, validation, and testing, respectively.\nThere are seven different domains, including hotel, hospital, police, restaurant, train, and taxi.\nWe use MultiWOZ 2.2 \\cite{zang-etal-2020-multiwoz} to be compatible with the standardized evaluation script \\cite{DBLP:journals/corr/abs-2106-05555}. \nWe evaluate our approach under different scenarios, such as zero-shot, few-shot, and fine-tuning with the full dataset, with both end-to-end and policy optimization configurations to evaluate the robustness and flexibility of our model.\n\nWe use standardized evaluation metrics\\footnote{\\url{https://github.com/Tomiinek/MultiWOZ_Evaluation}} with Inform, Success rates, and BLEU scores. \n\\textbf{Inform} measures the extent to which the system provides sufficient and relevant information to fulfill the user's information needs.\n\\textbf{Success} evaluates the performance in completing the user's goal.\nAlso, we evaluate the modelâ€™s zero-shot dialogue act prediction capabilities on an unseen dataset.\n\nTo provide a comprehensive evaluation, we separately compare our model's performance against several strong baselines in both low-resource settings and full fine-tuning settings.\nIn low-resource settings, we compare our model with DialoGPT \\cite{DBLP:conf/acl/ZhangSGCBGGLD20}, T5 \\cite{DBLP:journals/corr/abs-1910-10683},\nand GODEL \\cite{Peng2022GODELLP}.\nGODEL and DialoGPT are trained with a much larger dialogue corpus.\nThose models require a minimum of 50 training examples to adapt to MultiWOZ training data,\nwhile our work can perform zero-shot response generation without any fine-tuning.\n\nFor the full dataset fine-tuning settings, we compare with models on the existing leaderboard of MultiWOZ.\nWe evaluate both end-to-end and policy optimization settings.\nThis includes UBAR \\cite{DBLP:journals/corr/abs-2106-05555}, PPTOD \\cite{DBLP:conf/acl/SuSMG0LZ22}, RSTOD \\cite{DBLP:journals/corr/abs-2208-07097}, BORT \\cite{DBLP:conf/naacl/Sun0W022}, MTTOD \\cite{Lee2021ImprovingET}, HDNO \\cite{DBLP:journals/corr/abs-2006-06814}, GALAXY \\cite{he2022galaxy}, MarCO \\cite{DBLP:conf/acl/WangTWQY20}, Mars \\cite{DBLP:journals/corr/abs-2210-08917}, and KRLS \\cite{https://doi.org/10.48550/arxiv.2211.16773}.\nTo obtain database search results in the end-to-end setting, we use MTTOD's dialogue state tracker, which is trained jointly during fine-tuning.\nWe follow previous methods and append the dialogue act in front of the system responses to improve performance.\n\n\\section{Experiments}\nIn this section, we first show the experimental results under the low-resource and full fine-tuning settings.\nNext, we analyze the model's zero-shot capability to predict dialogue acts.\nFinally, we perform ablation studies for the proposed model to demonstrate the impact of dialogue act control and pre-training data.\n\n\\subsection{Low-resource Settings}\n\nTable~\\ref{tab:low-resource} shows the performance of our model in low-resource settings.\nWe evaluate the performance of our model under zero-shot settings and also fine-tune it using 50 randomly selected dialogues, similar to the approach used by the GODEL model.\nThe experiments here are done in the policy optimization setting.\n\nOur model outperforms the best GODEL model by achieving a higher combined score of $86.70$ without any fine-tuning, and an even higher score of $97.05$ after fine-tuning.\nIn particular, our model achieves better scores in Inform and Success metrics, indicating that our model is better able to satisfy the users' information needs.\nGODEL model has a higher BLEU score, which is likely due to the larger pre-training corpus used to train the model.\n\n\\subsection{Full Fine-tuning Settings}\n\nTo evaluate the effectiveness of our model in full dataset fine-tuning settings, we conduct experiments with both end-to-end and policy optimization configurations. \nThe results, as shown in Table~\\ref{tab:full-fine-tune}, demonstrate that our model achieves state-of-the-art performance, with a combined score of $104.4$. \nIn particular, our model outperforms the other models in the Inform and Success metrics, indicating that our model is able to provide more relevant and complete information to satisfy the users' information needs.\nOur model receives a slightly worse BLEU score. We suspect this is because the resulting responses contain more information relevant to the user request than the ground truth responses.\n\n\\begin{table}[t]\n    \\centering\n    \\resizebox{0.48\\textwidth}{!}{\n    \\begin{tabular}{l | c c c c}\n        \\toprule\n        \\textbf{Settings} & \\textbf{Inform} & \\textbf{Success} & \\textbf{BLEU} & \\textbf{Comb.}\\\\\n        \\midrule\n        full end-to-end  & 89.5 & 84.2 & 17.5 & 104.4 \\\\\n         \\quad - pretrain & 87.7 & 78.9 & 19.7 & 103.0 \\\\\n         \\quad - control & 84.9 & 76.2 & 19.8 & 100.4 \\\\\n         \\, + gold act & 93.0 & 89.6 & 29.6 & 120.8 \\\\\n         \\midrule\n        zero-shot policy  & 94.6 & 71.4 & 4.2 & 86.7 \\\\\n         \\quad - control & 93.8 & 55.4 & 6.6 & 81.2 \\\\\n         \\bottomrule\n    \\end{tabular}\n    }\n    \\caption{Ablation studies for end-to-end full training settings and zero-shot policy optimization settings.}\n    \\label{tab:ablation}\n\\end{table}\n\n\\subsection{Zero-shot Dialogue Act Prediction}\n\nWe evaluated the model's capability to predict dialogue acts without any downstream fine-tuning. \nWe pre-defined a set of possible dialogue acts by using the dialogue act schema from the training set.\nWe first tested the effects of different pre-training configurations.\nNote that the data is divided into two categories: one with dialogue act labels and one without.\nThus, we evaluated the model pre-trained with unlabeled, labeled, or mix-labeled act annotation data separately.\nAdditionally, we tested the effect of freezing the sentence-BERT model during training to see its impact on the performance of the overall model.\nThe results are shown in Figure~\\ref{fig:act_pred}.\nWe observed that pre-training with mixed-label data has the best performance, and freezing the sentence-BERT model had minimal effects on the dialogue act prediction F1.\n\n\\begin{figure}[t]\n    \\centering\n    \\begin{subfigure}[b]{0.34\\textwidth}\n    \\includegraphics[width=\\textwidth]{images/da_labels_ablation.pdf}\n    \\end{subfigure}\n    \\begin{subfigure}[b]{0.3\\textwidth}\n    \\includegraphics[width=\\textwidth]{images/da_freeze_ablation.pdf}\n    \\end{subfigure}\n    \\caption{Zero-shot dialogue act prediction F1 score.}\n    \\label{fig:act_pred}\n\\end{figure}\n\n\\begin{figure}[t]\n    \\centering\n    \\begin{subfigure}[b]{0.34\\textwidth}\n    \\includegraphics[width=\\textwidth]{images/response_labels_ablation.pdf}\n    \\end{subfigure}\n    \\begin{subfigure}[b]{0.3\\textwidth}\n    \\includegraphics[width=\\textwidth]{images/response_freeze_ablation.pdf}\n    \\end{subfigure}\n    \\caption{Response generation combined score.}\n    \\label{fig:ablations}\n\\end{figure}\n\n\\subsection{Ablations and Analysis}\n\nWe conduct similar experiments to the previous section to evaluate the effects of different pre-training configurations.\nThe experiments here are conducted in the zero-shot setting, without any dialogue act control.\nThe results are shown in Figure~\\ref{fig:ablations}.\nUsing the labeled data during pre-training significantly improves the performance of the model.\nMixing unlabeled data and labeled data leads to even better performance.\nWe also observe that for the small model, freezing sentence-BERT during training can significantly improve the performance, but it has less of an effect for the large model.\n\nThen, we evaluated the effects of pre-training and controllable response generation.\nThe results are shown in Table~\\ref{tab:ablation}.\nIn the full end-to-end fine-tuning setting, we first tested removing pre-training.\nFrom the table, we observed a decrease in the performance of the model for Inform (-2.0\\%) and Success (-6.3\\%), but an increase in the BLEU score (+10.1\\%).\nThen, we further tested the model without pre-training and removing the dialogue act response control, allowing the model to predict the dialogue act without any constraints.\nIt has a combined score of $100.4$, which is close to the reported MTTOD performance, indicating the trade-off when using controlled response generation.\nWe also tested using gold dialogue acts for our final pre-trained model as a reference for comparison.\nIn the zero-shot setting, we observed similar patterns when removing dialogue act control, but the performance decrease is more significant. Specifically, the Success rate dropped from $71.4$ to $55.4$, suggesting that our controlled response generation with dialogue acts is more effective in the low-resource setting than in the full fine-tuning setting.\n\n\\section{Conclusion}\n\nIn this work,  we present a novel end-to-end latent dialogue act model (DiactTOD) that represents dialogue acts in a latent space to improve the quality of response generation in task-oriented dialogue systems. \nDiactTOD addresses the challenge of utilizing generalized dialogue acts to control response generation across different datasets and tasks.\nThe experimental results on the MultiWOZ dataset show that our approach outperforms previous state-of-the-art methods across a wide range of experimental settings, including zero-shot, few-shot, and full data fine-tuning with both end-to-end and policy optimization configurations.  \nOverall, this work demonstrates the effectiveness of DiactTOD, making it possible to build more generalizable end-to-end dialogue systems. \n\n\\section*{Limitations}\n\nDespite the effectiveness of our proposed model DiactTOD, we provide some clear limitations.\nFirst, the model is only tested on the MultiWOZ dataset, which is currently the largest dataset for task-oriented response generation. \nWhile MultiWOZ is a popular dataset in the research community, it is not clear how well the model would perform on other types of datasets or in other domains, particularly those that do not rely on dialogue state annotations. \nIt could be an area for future research, by testing the model on other datasets or in other domains to evaluate its robustness and generalizability.\n\nSecond, our approach requires a pre-defined dialogue act schema to generate all the possible combinations of dialogue acts. \nThis means that it may not be able to generalize well to real-world scenarios where the dialogue acts are not as clearly defined or labeled. \nIn those situations, the model may struggle to generate appropriate responses or understand the context. \nIn future work, we will develop methods that can adapt to different dialogue act schemas or operate without them.\n\nAnother limitation of this work is that the controlled response generation method used is hand-crafted, as opposed to using reinforcement learning. \nWe defined rules to control dialogue acts based on the evaluation metrics \"Inform\" and \"Success\" of the MultiWOZ dataset. \nThis approach may not be suitable for more complex scenarios where the dialogue acts are more varied and thus may require a larger model to build the necessary rules.\nAlso, Inform and Success metrics may not reflect the real performance and have limitations.\nIn those situations, alternative methods such as reinforcement learning may be more appropriate.\n\n\\newpage\n\n\\appendix\n\n\\section{Dataset Details}\n\nWe chose four datasets that are annotated with dialogue acts and one dataset that does not contain any dialogue act annotations. \nTheir detailed descriptions are below:\n\n\\begin{itemize}\n  \\item SGD \\cite{rastogi2020towards} is a dataset with multi-domain and multi-turn task-oriented conversations between a human and a bot.\n  It involves 20 domains including banks, events, media, calendar, travel, and weather.\n \n  \\item STAR \\cite{mosig2020star} is a schema-guided dialogue dataset with human-human conversations across 13 different domains. It designs a flow chart and schema graph for collecting the data.\n \n  \\item MSRe2e \\cite{li2018microsoft} contains 2,890 human-human conversation with three task domains including movie-ticket booking, restaurant reservation, and taxi ordering. \n  \n  \\item Frames \\cite{schulz-etal-2017-frame} is a dataset with 1,369 human-human dialogues. It includes round-trip flights and hotel booking. It uses semantic frames to summarize the dialogue history and states.\n  \n  \\item MetaLWOZ \\cite{shalyminov2020fast} is a large dataset containing 37,884 dialogues with domains including bus schedules, apartment search, alarm setting, banking, and event reservation. However, compared to other task-oriented dialogue datasets, this dataset does not provide natural language understanding annotations, and cannot directly be used for end-to-end task-oriented dialogue systems.\n  \n\\end{itemize}\n\n    \n    \n\n\\begin{table*}[h]\n    \\centering\n    \\begin{tabular}{l|c c c |c c c c }\n    \\toprule\n    \\textbf{Model} & \\textbf{Labeled?} & \\textbf{Gold Act} & \\textbf{S-BERT*} & \\textbf{Inform} & \\textbf{Success} & \\textbf{BLEU} & \\textbf{Combined} \\\\\n    \\midrule\n    $\\text{LaDiact}_\\text{Base}$ & Unlabeled & no & no & 66.1 & 30.6 & 1.43 & 49.78 \\\\\n     & Unlabeled & yes & no & 94.0 & 42.2 & 0.17 & 68.27 \\\\\n     & Unlabeled & no & yes & 89.4 & 51.0 & 0.59 & 70.79 \\\\\n     & Unlabeled & yes & yes & 78.8 & 41.9 & 0.87 & 61.22 \\\\\n    \\midrule\n    $\\text{LaDiact}_\\text{Base}$ & Labeled & no & no & 84.7 & 46.3 & 4.11 & 69.61 \\\\\n     & Labeled & yes & no & 83.8 & 47.0 & 5.21 & 70.62 \\\\\n     & Labeled & no & yes & 84.8 & 47.0 & 4.59 & 70.49 \\\\\n     & Labeled & yes & yes & 91.3 & 51.9 & 6.05 & 77.65 \\\\\n    \\midrule\n    $\\text{LaDiact}_\\text{Base}$ & Mixed & no & no & 84.6 & 47.5 & 4.49 & 70.54 \\\\\n     & Mixed & yes & no & 94.3 & 54.3 & 6.62 & 80.92 \\\\\n     & Mixed & no & yes & 87.8 & 50.6 & 5.18 & 74.38 \\\\\n     & Mixed & yes & yes & 93.2 & 54.6 & 6.56 & 80.46 \\\\\n    \\midrule\n    \\midrule\n    $\\text{LaDiact}_\\text{Large}$ & Unlabeled & no & no & 72.0 & 30.6 & 1.44 & 52.74 \\\\\n     & Unlabeled & yes & no & 81.7 & 46.2 & 0.17 & 63.95 \\\\\n     & Unlabeled & no & yes & 68.0 & 38.8 & 3.73 & 57.13 \\\\\n     & Unlabeled & yes & yes & 79.7 & 42.4 & 2.03 & 63.80 \\\\\n    \\midrule\n    $\\text{LaDiact}_\\text{Large}$ & Labeled & no & no & 87.8 & 49.1 & 4.89 & 73.33 \\\\\n     & Labeled & yes & no & 93.3 & 48.9 & 6.40 & 77.50 \\\\\n     & Labeled & no & yes & 93.1 & 53.9 & 4.79 & 78.29 \\\\\n     & Labeled & yes & yes & 92.5 & 53.7 & 6.25 & 79.35 \\\\\n    \\midrule\n    $\\text{LaDiact}_\\text{Large}$ & Mixed & no & no & 90.5 & 52.8 & 5.11 & 76.76 \\\\\n     & Mixed & yes & no & 92.2 & 55.5 & 6.67 & 80.52 \\\\\n     & Mixed & no & yes & 91.4 & 53.0 & 5.05 & 77.25 \\\\\n     & Mixed & yes & yes & 93.8 & 55.4 & 6.57 & 81.17 \\\\\n    \\bottomrule\n    \\end{tabular}\n    \\caption{Detailed ablation studies of zero-shot performance under different configurations.. * means whether freezes sentence-BERT during pre-training.}\n    \\label{tab:result}\n\\end{table*}\n\n\\end{document}\n</paper 3>\n\nYour summary should follow these steps:\n- Title: Clearly state the main subject or topic of the summary.\n- Introduction: Describe the field and briefly introduce its history. Then introduce current progress and challenges.\n- Introduce the main content of each paper separately. Then summarize their commonalities and innovations.\n- Compare the results of the papers and discuss difference of the results.\n- Conclusion: Summarize the main findings and suggest future research directions.\n\n<keys>\nThe following are the key points to note:\n- If there are important data or mian equation in the given papers, remember to mention them in your summary using Markdown.\n- Use of tables to clearly compare different approaches is encouraged.\n- The first appearance of a professional term must be marked with the full English name and abbreviation.\n- Don't directly copy the papers, write the summary in your own words.\n- Do not include the titles of reference papers directly in your paper.\n</keys>\n\nTotal word count should be about 4000 words.",
    "paper": [
        "arXiv-2210.08917v2.tex",
        "arXiv-2211.16773v5.tex",
        "arXiv-2308.00878v1.tex"
    ],
    "group_id": "group_102",
    "response": "### Title: Advances in End-to-End Task-Oriented Dialogue Systems: Mars, KRLS, and DiactTOD\n\n### Introduction\n\nTask-oriented dialogue systems (TODs) are designed to assist users in completing specific tasks, such as booking a hotel or reserving a table in a restaurant. These systems have traditionally been built using modular approaches, including dialogue state tracking (DST), dialogue policy learning, and natural language generation (NLG). However, recent advancements in large-scale pre-trained language models have enabled the development of end-to-end TODs that directly convert dialogue context into system responses through multi-task training. Despite these improvements, challenges remain in enhancing the quality of generated responses, particularly in terms of task success and inform rates. This summary explores three recent papers that address these challenges by proposing innovative methods to improve the performance of end-to-end TODs: Mars, KRLS, and DiactTOD.\n\n#### Background and History\n\nTask-oriented dialogue systems have been a focal point of research in natural language processing (NLP) since the early 2000s. Initially, these systems were built using a modular approach, where each component (DST, policy, and NLG) was trained separately. The modular approach required explicit annotations for belief states and action states, which were then used to generate system responses. Over time, researchers have shifted towards end-to-end approaches, leveraging large-scale pre-trained models to improve the performance of these systems. These models are typically fine-tuned on task-oriented dialogue datasets such as MultiWOZ \\cite{budzianowski-etal-2018-multiwoz}, CamRest676 \\cite{wen-etal-2017-network}, and CrossWOZ \\cite{zhu-etal-2020-crosswoz}. Despite these advancements, end-to-end systems still face challenges in generating high-quality responses that accurately inform users and successfully complete tasks.\n\n#### Current Progress and Challenges\n\nRecent progress in end-to-end TODs has been driven by the use of large-scale pre-trained models like BERT \\cite{devlin-etal-2019-bert}, GPT-2 \\cite{radford2019language}, and T5 \\cite{2020t5}. These models have been fine-tuned on task-oriented dialogue datasets to improve the quality of generated responses. However, the performance of these systems is significantly influenced by the quality of belief states and action states, which are often derived from the dialogue context. This has led to the exploration of methods that can enhance the relationship between dialogue context and semantic state representations. Additionally, the use of reinforcement learning (RL) has been proposed to directly optimize response generation for task-related metrics, but it often requires a user simulator and can be time-consuming due to the slow auto-regressive sequence generation process.\n\n### Main Content of Each Paper\n\n#### Mars: Semantic-aware Contrastive Learning for End-to-End Task-Oriented Dialogue\n\nMars \\cite{hpsun1109Mars} proposes a novel approach to improve the performance of end-to-end task-oriented dialogue systems by utilizing contrastive learning strategies. The paper explores the relationship between dialogue context and semantic state representations (belief and action states) and introduces two contrastive learning methods: pair-aware context\\&state and group-aware context\\&state contrastive learning. \n\nThe pair-aware context\\&state contrastive learning strategy aims to narrow the gap in the continuous representation space between dialogue context and corresponding semantic states for the same dialog turn. This ensures that the dialogue context is semantically consistent with its belief and action states. The group-aware context\\&state contrastive learning strategy, on the other hand, enlarges the overall continuous representation margin between dialogue context and semantic states. This strategy makes representations between dialogue context and semantic states more different, which helps in distinguishing different contexts and states within the same dialogue.\n\nThe Mars model uses a T5 language model \\cite{2020t5} for its shared encoder and two decoders for belief and action states. The objective function for Mars is formulated as:\n\\[\n\\mathcal{L}_{all} = \\mathcal{L}_{B'} + \\mathcal{L}_{AR'}\n\\]\nwhere $\\mathcal{L}_{B'}$ and $\\mathcal{L}_{AR'}$ are the modified objective functions for belief state tracking and action state/response generation, respectively. The contrastive learning objective functions $\\mathcal{L}_{bscl}$ and $\\mathcal{L}_{ascl}$ are added to enhance the relationship modeling between dialogue context and semantic state representations.\n\n#### KRLS: Improving End-to-End Response Generation in Task-Oriented Dialogue with Reinforced Keywords Learning\n\nKRLS \\cite{https://doi.org/10.48550/arxiv.2211.16773} introduces an efficient reinforcement learning (RL) algorithm to improve the response generation in end-to-end task-oriented dialogue systems. The algorithm combines a faster sequence generation procedure with a fine-grained per-token reward function. The generation procedure involves sampling from independent next-word distributions conditioned on the gold response, which is much faster than traditional auto-regressive generation. The per-token reward function measures the importance and semantic closeness of each generated token, helping the model focus on learning key information in the dialogue.\n\nThe KRLS algorithm is described in \\autoref{algo:krls_algorithm}. It uses a buffer to store SL-trained episodes and then performs RL on these episodes to update the generative network. The algorithm is designed to be generic and can be applied to various task-oriented dialogues where keywords can be easily defined. The paper evaluates KRLS on the MultiWOZ dataset \\cite{budzianowski-etal-2018-multiwoz} and shows that KRLS achieves state-of-the-art performance in response generation, with a 15\\% reduction in training time compared to standard RL approaches.\n\n#### DiactTOD: Learning Generalizable Latent Dialogue Acts for Controllable Task-Oriented Dialogue Systems\n\nDiactTOD \\cite{he2022galaxy} presents a method for learning generalizable latent dialogue acts that can be applied across different datasets and tasks. The model uses sentence-BERT (S-BERT) \\cite{reimers-2019-sentence-bert} to encode dialogue acts into embeddings and a policy model to predict the best latent dialogue act for a given context. The final response generation is conditioned on the encoder's hidden states and the policy model's hidden states.\n\nDiactTOD is pre-trained on a selection of task-oriented dialogue datasets, including SGD \\cite{rastogi2020towards}, STAR \\cite{mosig2020star}, MSRe2e \\cite{li2018microsoft}, and Frames \\cite{schulz-etal-2017-frame}. The model is evaluated on the MultiWOZ dataset \\cite{budzianowski-etal-2018-multiwoz} under different scenarios, such as zero-shot, few-shot, and full data fine-tuning. The results demonstrate that DiactTOD achieves state-of-the-art performance in both end-to-end and policy optimization configurations.\n\n### Commonalities and Innovations\n\n#### Commonalities\n\nAll three papers aim to improve the performance of end-to-end task-oriented dialogue systems. They utilize large-scale pre-trained language models and focus on enhancing the quality of generated responses by addressing specific challenges in the dialogue generation process. The papers also evaluate their methods on the MultiWOZ dataset, a widely-used benchmark for task-oriented dialogue generation.\n\n#### Innovations\n\n- **Mars** introduces contrastive learning strategies to explicitly model the relationship between dialogue context and semantic state representations. This approach helps in achieving more consistent and diverse representations, which in turn improves the generated response quality.\n- **KRLS** proposes a faster generation procedure and a fine-grained per-token reward function to enhance the keyword learning ability of the model. This method avoids the need for a user simulator and reduces training time by 15\\% compared to standard RL approaches.\n- **DiactTOD** leverages latent dialogue acts to control response generation in a more generalizable and controllable manner. The model is pre-trained on a selection of task-oriented dialogue datasets and can predict dialogue acts without any downstream fine-tuning.\n\n### Comparison of Results\n\n#### Performance Metrics\n\nAll three papers report performance metrics on the MultiWOZ dataset, including inform rate, success rate, BLEU score, and combined score. The combined score is calculated as $(\\mathrm{Inform}+\\mathrm{Success}) \\times 0.5 + \\mathrm{BLEU}$.\n\n- **Mars** achieves the highest combined score of 103.4 on MultiWOZ 2.0, outperforming previous state-of-the-art models like GALAXY and MTTOD.\n- **KRLS** achieves a combined score of 103.8, which is slightly better than Mars (103.4) and significantly better than other models like MTTOD (100.2) and GALAXY (100.2).\n- **DiactTOD** achieves a combined score of 104.4 in the full end-to-end fine-tuning setting and 110.3 in the policy optimization setting, outperforming all previous models.\n\n#### Training Time\n\n- **Mars** requires approximately five hours of training on one NVIDIA A100 GPU for 10 epochs.\n- **KRLS** reduces training time by 15\\% compared to standard RL approaches, taking about 306 minutes per epoch.\n- **DiactTOD** is trained for 4 epochs, which takes about one day on a single GPU.\n\n#### Low Resource Scenarios\n\n- **Mars** demonstrates robust performance in low-resource scenarios, outperforming previous models like PPTOD and MTTOD.\n- **KRLS** also shows strong performance in low-resource settings, with significant improvements in inform and success rates.\n- **DiactTOD** achieves state-of-the-art performance in both zero-shot and few-shot settings, indicating its generalizability and flexibility.\n\n### Conclusion\n\n#### Main Findings\n\nThe three papers present innovative methods to improve the performance of end-to-end task-oriented dialogue systems. Mars uses contrastive learning to enhance the relationship between dialogue context and semantic state representations, achieving state-of-the-art performance on MultiWOZ 2.0, CamRest676, and CrossWOZ. KRLS introduces a faster generation procedure and a fine-grained per-token reward function, reducing training time while improving response generation quality. DiactTOD leverages latent dialogue acts to control response generation, demonstrating strong performance in both zero-shot and full data fine-tuning settings.\n\n#### Future Research Directions\n\n- **Enhancing Generalization:** Future work could focus on further enhancing the generalization ability of these models to handle a wider range of tasks and datasets.\n- **Improving DST and System Act Generation:** Techniques like Mars and KRLS could be combined to improve the DST and system act generation components, which are critical for achieving high task success rates.\n- **Addressing Ethical Concerns:** Researchers should consider ethical implications and develop guardrails to ensure that these models generate safe and respectful responses in real-world scenarios.\n\n### Tables for Comparison\n\nBelow are tables summarizing the performance of the models on the MultiWOZ dataset:\n\n#### Table 1: Performance on MultiWOZ 2.0\n\n| Model       | Inform Rate | Success Rate | BLEU Score | Combined Score |\n|-------------|-------------|--------------|------------|-----------------|\n| Baseline     | 83.2        | 70.3         | 19.4       | 96.2            |\n| Mars-P       | 86.6        | 75.5         | 19.6       | 100.7           |\n| Mars-G       | **88.9**    | **78.0**     | **19.9**   | **103.4**       |\n| UBAR         | 83.4        | 70.3         | 17.6       | 94.5            |\n| MTTOD        | 85.9        | 76.5         | 19.0       | 100.2           |\n| GALAXY       | 85.4        | 75.7         | 19.6       | 100.2           |\n\n#### Table 2: Performance on MultiWOZ 2.2\n\n| Model       | Inform Rate | Success Rate | BLEU Score | Combined Score |\n|-------------|-------------|--------------|------------|-----------------|\n| Baseline (MTTOD) | 86.0        | 77.4         | 18.9       | 100.6           |\n| KRLS         | 87.3        | 78.3         | 19.2       | 102.0           |\n| finetune+KRLS | **89.2**    | **80.3**     | **19.0**   | **103.8**       |\n| DiactTOD     | 89.5        | 84.2         | 17.5       | 104.4           |\n| DiactTOD (with gold act) | 93.0        | 89.6       | 29.6            | 120.8           |\n\n#### Table 3: Zero-shot Dialogue Act Prediction\n\n| Settings     | Inform Rate | Success Rate | BLEU Score | Combined Score |\n|--------------|-------------|--------------|------------|-----------------|\n| full end-to-end | 89.5        | 84.2         | 17.5       | 104.4           |\n| full end-to-end (no pretrain) | 87.7        | 78.9       | 19.7            | 103.0           |\n| full end-to-end (no control)  | 84.9         | 76.2       | 19.8            | 100.4           |\n| zero-shot policy | 94.6        | 71.4         | 4.2        | 86.7            |\n| zero-shot policy (no control) | 93.8         | 55.4       | 6.6             | 81.2            |\n\n### Conclusion\n\nIn summary, Mars, KRLS, and DiactTOD represent significant advancements in the field of end-to-end task-oriented dialogue systems. Mars uses contrastive learning to enhance the relationship between dialogue context and semantic state representations, achieving state-of-the-art performance on MultiWOZ 2.0, CamRest676, and CrossWOZ. KRLS introduces a faster generation procedure and a fine-grained per-token reward function, reducing training time while improving response generation quality. DiactTOD leverages latent dialogue acts to control response generation, demonstrating strong performance in both zero-shot and full data fine-tuning settings. Future research could focus on enhancing the generalization ability of these models and addressing ethical concerns to ensure safe and respectful responses in real-world scenarios."
}